<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Fraser's IdM Blog - <code>staticmethod</code> considered beneficial</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Fraser's IdM Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <div id="postContent">
    <h1 id="staticmethod-considered-beneficial"><code>staticmethod</code> considered beneficial</h1>
<p>Some Python programmers hold that the <code>staticmethod</code> decorator, and to a lesser extent <code>classmethod</code>, are to be avoided where possible. This view is not correct, and in this post I will explain why.</p>
<p>This post will be useful to programmers in any language, but especially Python.</p>
<h2 id="the-constructions">The constructions</h2>
<p>I must begin with a brief overview of the <code>classmethod</code> and <code>staticmethod</code> constructions and their uses.</p>
<p><code>classmethod</code> is a function that transforms a method into a class method. The class method receives the <em>class object</em> as its first argument, rather than an <em>instance</em> of the class. It is typically used as a method <em>decorator</em>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">class</span> C:</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="at">@classmethod</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="kw">def</span> f(cls, arg1, arg2, ...): ...</a></code></pre></div>
<p>By idiom, the class object argument is bound to the name <code>cls</code>. You can invoke a class method via an instance (<code>C().f()</code>) or via the class object itself (<code>C.f()</code>). In return for this flexibility you give up the ability to access instance methods or attributes from the method body, even when it was called via an instance.</p>
<p><code>staticmethod</code> is nearly identical to <code>classmethod</code>. The only difference is that instead of receiving the class object as the first argument, it does not receive any implicit argument:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">class</span> C:</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="at">@staticmethod</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="kw">def</span> f(arg1, arg2, ...): ...</a></code></pre></div>
<p>How are the <code>classmethod</code> and <code>staticmethod</code> constructions used? Consider the following (contrived) class:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">class</span> Foo(<span class="bu">object</span>):</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, delta):</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="va">self</span>.delta <span class="op">=</span> delta</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">  <span class="kw">def</span> forty_two(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="cf">return</span> <span class="dv">42</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  <span class="kw">def</span> answer(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    <span class="cf">return</span> <span class="va">self</span>.forty_two()</a>
<a class="sourceLine" id="cb3-11" data-line-number="11"></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">  <span class="kw">def</span> modified_answer(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    <span class="cf">return</span> <span class="va">self</span>.answer() <span class="op">+</span> <span class="va">self</span>.delta</a></code></pre></div>
<p>There are some places we could use <code>staticmethod</code> and <code>classmethod</code>. Should we? Let’s just do it and discuss the impact of the changes:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">class</span> Foo(<span class="bu">object</span>):</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, delta):</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="va">self</span>.delta <span class="op">=</span> delta</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  <span class="at">@staticmethod</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  <span class="kw">def</span> forty_two():</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    <span class="cf">return</span> <span class="dv">42</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  <span class="at">@classmethod</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  <span class="kw">def</span> answer(cls):</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    <span class="cf">return</span> cls.forty_two()</a>
<a class="sourceLine" id="cb4-13" data-line-number="13"></a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  <span class="kw">def</span> modified_answer(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">    <span class="cf">return</span> <span class="va">self</span>.answer() <span class="op">+</span> <span class="va">self</span>.delta</a></code></pre></div>
<p><code>forty_two</code> became a static method, and it no longer takes any argument. <code>answer</code> became a class method, and its <code>self</code> argument became <code>cls</code>. It cannot become a static method, because it references <code>cls.forty_two</code>. <code>modified_answer</code> can’t change at all, because it references an instance attribute (<code>self.delta</code>). <code>forty_two</code> could have been made a class method, but just as it had no need of <code>self</code>, it has no need <code>cls</code> either.</p>
<p>There is an alternative refactoring for <code>forty_two</code>. Because it doesn’t reference anything in the class, we could have extracted it as a top-level function (i.e. defined not in the class but directly in a module). Conceptually, <code>staticmethod</code> and top-level functions are equivalent modulo namespacing.</p>
<p>Was the change I made a good one? Well, you already know my answer will be <em>yes</em>. Before I justify my position, let’s discuss some counter-arguments.</p>
<h2 id="why-not-staticmethod-or-classmethod">Why not <code>staticmethod</code> or <code>classmethod</code>?</h2>
<p>Most Python programmers accept that alternative constructors, factories and the like are legitimate applications of <code>staticmethod</code> and <code>classmethod</code>. Apart from these applications, opinions vary.</p>
<ul>
<li>For some folks, the above are the <em>only</em> acceptable uses.</li>
<li>Some accept <code>staticmethod</code> for grouping utility functions closely related to some class, into that class; others regard this kind of <code>staticmethod</code> proliferation as a code smell.</li>
<li>Some feel that anything likely to only ever be called on an instance should use instance methods, i.e. having <code>self</code> as the first argument, even when not needed.</li>
<li>The decorator syntax “noise” seems to bother some people</li>
</ul>
<p>Guido van Rossum, author and BDFL of Python, <a href="https://mail.python.org/pipermail/python-ideas/2012-May/014969.html">wrote</a> that static methods were an accident. History is interesting, sure, but not all accidents are automatically bad.</p>
<p>I am sympathetic to some of these arguments. A class with a lot of static methods might just be better off as a module with top-level functions. It is true that <code>staticmethod</code> is not required for anything whatsoever and could be dispensed with (this is not true of <code>classmethod</code>). And clean code is better than noisy code. Surely if you’re going to clutter your class with decorators, you want something in return right? Well, you do get something in return.</p>
<h2 id="deny-thy-self">Deny thy <code>self</code></h2>
<p>Let us put to the side the side-argument of <code>staticmethod</code> versus top-level functions. The real debate is <em>instance methods</em> versus <em>not instance methods</em>. This is the crux. Why avoid instance methods (where possible)? Because doing so is a win for readability.</p>
<p>Forget the contrived <code>Foo</code> class from above and imagine you are in a non-trivial codebase. You are hunting a bug, or maybe trying to understand what some function does. You come across an interesting function. It is 50 lines long. What does it do?</p>
<p>If you are reading an instance method, in addition to its arguments, the module namespace, imports and builtins, it has access to <code>self</code>, the instance object. If you want to know what the function does or doesn’t do, you’ll have to read it.</p>
<p>But if that function is a <code>classmethod</code>, you now have <em>more information</em> about this function—namely that it cannot access any instance methods, even if it was invoked on an instance (including from within a sibling instance method). <code>staticmethod</code> (or a top-level function) gives you a bit more than this: not even class methods can be accessed (unless directly referencing the class, which is easily detected and definitely a code smell). By using these constructions when possible, the programmer has less to think about as they read or modify the function.</p>
<p>You can flip this scenario around, too. Say you know a program is failing in some <em>instance</em> method, but you’re not sure how the problematic code is reached. Well, you can rule out the class methods and static methods straight away.</p>
<p>These results are similar to the result of <a href="http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=F63444BB6DD3E18607EA7B3677036F09?doi=10.1.1.38.9875&amp;rep=rep1&amp;type=pdf">parametricity</a> in programming language theory. The profound and <em>actionable</em> observation in both settings is this: knowing <em>less</em> about something gives the programmer <em>more</em> information about its behaviour.</p>
<p>These might not seem like big wins. Because most of the time it’s only a small win. But it’s never a lose, and over the life of a codebase or the career of a programmer, the small readability wins add up. To me, this is a far more important goal than avoiding extra lines of code (decorator syntax), or spurning a feature because its author considers it an accident or it transgresses the <a href="https://www.python.org/dev/peps/pep-0020/">Zen of Python</a> or whatever.</p>
<p>But speaking of the Zen of Python…</p>
<blockquote>
<p>Readability counts.</p>
</blockquote>
<p>So use <code>classmethod</code> or <code>staticmethod</code> wherever you can.</p>
</div>
<div id="postFooter">
    <div id="recent">
Recent posts:
<ul>
    
        <li>
            <a href="../posts/2019-02-07-staticmethod-considered-beneficial.html"><code>staticmethod</code> considered beneficial</a>
        </li>
    
        <li>
            <a href="../posts/2019-02-04-dogtag-installation.html">How does Dogtag PKI spawn?</a>
        </li>
    
        <li>
            <a href="../posts/2019-01-29-name-constraints.html">X.509 Name Constraints and FreeIPA</a>
        </li>
    
        <li>
            <a href="../posts/2018-11-30-dogtag-clone-failure-debugging.html">Diagnosing Dogtag cloning failures</a>
        </li>
    
        <li>
            <a href="../posts/2018-11-20-ca-renewal-master.html">FreeIPA CA renewal master explained</a>
        </li>
    
</ul>

<div id="recentLinks">
    <a type="application/atom+xml" href="../atom.xml">Atom feed</a>
     <!-- em space -->
    <a href="../archive.html">All posts…</a>
</div>

</div>

    <div id="license">
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
        <img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by/4.0/88x31.png">
    </a>
    <br />
    Except where otherwise noted, this work is licensed under a
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
        Creative Commons Attribution 4.0 International License
    </a>.
</div>

</div>

        </div>
        <div class="clear"></div>
        <div id="footer">
            Generated by
            <a href="https://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
