<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Fraser's IdM Blog - Kubernetes DNS Service Discovery limitations</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Fraser's IdM Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <div class="info">
    
    Tags: <a title="All pages tagged 'openshift'." href="../tags/openshift.html">openshift</a>, <a title="All pages tagged 'kubernetes'." href="../tags/kubernetes.html">kubernetes</a>, <a title="All pages tagged 'dns'." href="../tags/dns.html">dns</a>
    
</div>

<div id="postContent">
    <h1 id="kubernetes-dns-service-discovery-limitations">Kubernetes DNS Service Discovery limitations</h1>
<p>Kubernetes <em>Service</em> objects expose applications running in Pods as network services. For each combination of service name, port and associated Pod, the Kubernetes DNS system creates a DNS <code>SRV</code> record that can be used for service discovery.</p>
<p>In this post I demonstrate a deficiency in this system that obstructs important, real-world use cases, and sketch potential solutions.</p>
<h2 id="overview-of-kubernetes-services-and-dns">Overview of Kubernetes Services and DNS <a href="#overview-of-kubernetes-services-and-dns">§</a></h2>
<p>The following Service definition defines an LDAP service:</p>
<pre><code>$ oc create -f service-test.yaml 
apiVersion: v1
kind: Service
metadata:
  name: service-test
  labels:
    app: service-test
spec:
  selector:
    app: service-test
  clusterIP: None
  ports:
  - name: ldap
    protocol: TCP
    port: 389

$ oc create -f service-test.yaml
service/service-test created</code></pre>
<p>The Service controller creates <em>Endpoint</em> objects to associating each of the Service <code>ports</code> with each Pod matching the Service <code>selector</code>. If there are no matching pods, there are no endpoints:</p>
<pre><code>$ oc get endpoints service-test
NAME           ENDPOINTS   AGE
service-test   &lt;none&gt;      8m1s</code></pre>
<p>If we add a matching pod:</p>
<pre><code>$ cat pod-service-test.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: service-test
  labels:
    app: service-test
spec:
  containers:
  - name: service-test
    image: freeipa/freeipa-server:fedora-31
    command: [&quot;sleep&quot;, &quot;3601&quot;]

$ oc create -f pod-service-test.yaml 
pod/service-test created</code></pre>
<p>Then the Service controller creates an endpoint that maps the Service to the Pod:</p>
<pre><code>$ oc get endpoints service-test
NAME           ENDPOINTS         AGE
service-test   10.129.2.13:389   16m

$ oc get -o yaml endpoints service-test
apiVersion: v1
kind: Endpoints
metadata:
  labels:
    app: service-test
    service.kubernetes.io/headless: &quot;&quot;
  ... 
subsets:
- addresses:
  - ip: 10.129.2.13
    nodeName: ft-47dev-2-27h8r-worker-0-f8bnl
    targetRef:
      kind: Pod
      name: service-test
      namespace: test
      resourceVersion: &quot;4556709&quot;
      uid: 296030f5-8dff-4f69-be96-ce6f0aa12653
  ports:
  - name: ldap
    port: 389
    protocol: TCP</code></pre>
<p>Cluster DNS systems (there are different implementations, e.g. <a href="https://github.com/kubernetes/dns">kubedns</a>, and the OpenShift <a href="https://github.com/openshift/cluster-dns-operator">Cluster DNS Operator</a>) use the Endpoints objects to manage DNS records for applications running in the cluster. In particular, it creates <code>SRV</code> records mapping each service <code>name</code> and <code>protocol</code> combination to the pod(s) that provide that service. The behaviour is defined in the <a href>Kubernetes DNS-Based Service Discovery specification</a>.</p>
<p>The SRV record owner name has the form:</p>
<pre><code>_&lt;port&gt;._&lt;proto&gt;.&lt;service&gt;.&lt;ns&gt;.svc.&lt;zone&gt;.</code></pre>
<p>where <code>ns</code> is the project namespace and <code>zone</code> is the cluster DNS zone. The objects created above result in the follow <code>SRV</code> and <code>A</code> records:</p>
<pre><code>$ oc rsh service-test

sh-5.0# dig +short SRV \
    _ldap._tcp.service-test.test.svc.cluster.local
0 100 389 10-129-2-13.service-test.test.svc.cluster.local.

sh-5.0# dig +short A \
    10-129-2-13.service-test.test.svc.cluster.local
10.129.2.13</code></pre>
<p>For more information above DNS <code>SRV</code> records, see <a href="https://tools.ietf.org/html/rfc2782">RFC 2782</a>.</p>
<h2 id="kubernetes-srv-limitation">Kubernetes SRV limitation <a href="#kubernetes-srv-limitation">§</a></h2>
<p>Some services operate over TCP, some over UDP. And some operate over <em>both</em> TCP and UDP. Two examples are DNS and Kerberos. <code>SRV</code> records are of particular importance for Kerberos; they are used (<a href="https://web.mit.edu/kerberos/krb5-devel/doc/admin/realm_config.html#hostnames-for-kdcs">widely</a>, by <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/7fcdce70-5205-44d6-9c3a-260e616a2f04">multiple</a> <a href="https://www.freeipa.org/page/V4/DNS_Location_Mechanism">implementations</a>) for KDC discovery.</p>
<p>So to host a Kerberos KDC in Kubernetes and enable service discovery, we need two sets of SRV records: <code>_kerberos._tcp</code> and <code>_kerberos._udp</code>. And likewise for the <code>kpasswd</code> and <code>kerberos-master</code> service names. There could be (probably are) other protocols where a similar arrangement is required.</p>
<p>So, let’s update the Service object and add the <code>kerberos</code> ServicePort specs:</p>
<pre><code>$ cat service-test.yaml 
apiVersion: v1
kind: Service
metadata:
  name: service-test
  labels:
    app: service-test
spec:
  selector:
    app: service-test
  clusterIP: None
  ports:
  - name: ldap
    protocol: TCP
    port: 389
  - name: kerberos
    protocol: TCP
    port: 88
  - name: kerberos
    protocol: UDP
    port: 88

$ oc replace -f service-test.yaml
The Service &quot;service-test&quot; is invalid:
spec.ports[2].name: Duplicate value: &quot;kerberos&quot;</code></pre>
<p>Well, that’s a shame. Kerberos does not admit this important use case.</p>
<h3 id="endpoints-do-not-have-the-limitation">Endpoints do not have the limitation <a href="#endpoints-do-not-have-the-limitation">§</a></h3>
<p>Interestingly, the Endpoints type does have this limitation. The Service controller automatically creates Endpoints objects for Services. The ServicePorts are (as far as I can tell) copied across to the Endpoints object.</p>
<p>I can manually replace the <code>endpoints/service-test</code> object (see above) with the following spec that includes the “duplicate” <code>kerberos</code> port:</p>
<pre><code>$ cat endpoints.yaml
apiVersion: v1
kind: Endpoints
metadata:
  creationTimestamp: &quot;2020-12-07T03:51:30Z&quot;
  labels:
    app: service-test
    service.kubernetes.io/headless: &quot;&quot;
  name: service-test
subsets:
- addresses:
  - ip: 10.129.2.13
    nodeName: ft-47dev-2-27h8r-worker-0-f8bnl
    targetRef:
      kind: Pod
      name: service-test
      namespace: test
      resourceVersion: &quot;5522680&quot;
      uid: 296030f5-8dff-4f69-be96-ce6f0aa12653
  ports:
  - name: ldap
    port: 389
    protocol: TCP
  - name: kerberos
    port: 88
    protocol: TCP
  - name: kerberos
    port: 88
    protocol: UDP

$ oc replace -f endpoints.yaml
endpoints/service-test replaced</code></pre>
<p>The object was accepted! Observe that the DNS system responds and creates <em>both</em> the <code>_kerberos._tcp</code> and <code>_kerberos._udp</code> <code>SRV</code> records:</p>
<pre><code>$ oc rsh service-test

sh-5.0# dig +short SRV \
    _kerberos._tcp.service-test.test.svc.cluster.local
0 100 88 10-129-2-13.service-test.test.svc.cluster.local.

sh-5.0# dig +short SRV \
    _kerberos._udp.service-test.test.svc.cluster.local
0 100 88 10-129-2-13.service-test.test.svc.cluster.local.</code></pre>
<p>Therefore it seems the scope of this problem is limited to validation and processing of the <code>Service</code> object. Other components of Kubernetes (Endpoint validation and the Cluster DNS Operator, at least) can already handle this use case.</p>
<h2 id="possible-resolutions">Possible resolutions <a href="#possible-resolutions">§</a></h2>
<p>I am not aware of any workarounds, but I see two possible approaches to resolving this issue.</p>
<p>One approach is to relax the uniqueness check. Instead of checking for uniqueness of ServicePort <code>name</code>, check for the uniqueness of the <code>name</code>/<code>protocol</code> pair. This is conceptually simple but I am not familiar enough with Kubernetes internals to judge the feasibility or technical tradeoffs of this approach. For users, nothing changes (except the example above would work!)</p>
<p>Another approach is to add a new ServicePort field to specify the actual DNS service label to use. For the sake of discussion I’ll call it <code>serviceName</code>. It would be optional, defaulting to the value of <code>name</code>. This means <code>name</code> can still be the “primary key”, but the approach requires <em>another</em> uniqueness check on the <code>serviceName</code>/<code>protocol</code> pair. In our use case the configuration would look like:</p>
<pre><code>...
ports:
- name: ldap
  protocol: TCP
  port: 389
- name: kerberos-tcp
  serviceName: kerberos
  protocol: TCP
  port: 88
- name: kerberos-udp
  serviceName: kerberos
  protocol: UDP
  port: 88</code></pre>
<p>From a UX perspective I prefer the first approach, because there are no changes or additions to the ServicePort configuration schema. But to maintain compatibility with programs that assume that <code>name</code> is unique (as is currently enforced), it might be necessary to introduce a new field.</p>
<h2 id="next-steps">Next steps <a href="#next-steps">§</a></h2>
<p>I <a href="https://github.com/kubernetes/kubernetes/issues/97149">filed a bug report</a> and submitted a <a href>proof-of-concept pull request</a> to bring attention to the problem and solicit feedback from Kubernetes and OpenShift DNS experts. It might be necessary to submit a <a href="https://github.com/kubernetes/enhancements/blob/master/keps/README.md">Kubernetes Enhancement Proposal</a> (KEP), but that seems (as a Kubernetes outsider) a long and windy road to landing what is a conceptually small change.</p>
</div>
<div id="postFooter">
    <div id="recent">
Recent posts:
<ul>
    
        <li>
            <a href="../posts/2020-12-08-k8s-srv-limitation.html">Kubernetes DNS Service Discovery limitations</a>
        </li>
    
        <li>
            <a href="../posts/2020-12-05-pod-hostname-fqdn.html">Pod hostnames and FQDNs</a>
        </li>
    
        <li>
            <a href="../posts/2020-12-01-openshift-crio-userns.html">User namespaces in OpenShift via CRI-O annotations</a>
        </li>
    
        <li>
            <a href="../posts/2020-11-30-openshift-machine-config-operator.html">Using the OpenShift Machine Config Operator</a>
        </li>
    
        <li>
            <a href="../posts/2020-11-13-acme-service-discovery.html">ACME Service Discovery</a>
        </li>
    
</ul>

<div id="recentLinks">
    <a type="application/atom+xml" href="../atom.xml">Atom feed</a>
     <!-- em space -->
    <a href="../archive.html">All posts…</a>
</div>

</div>

    <div id="license">
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
        <img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by/4.0/88x31.png">
    </a>
    <br />
    Except where otherwise noted, this work is licensed under a
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
        Creative Commons Attribution 4.0 International License
    </a>.
</div>

</div>

        </div>
        <div class="clear"></div>
        <div id="footer">
            Generated by
            <a href="https://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
