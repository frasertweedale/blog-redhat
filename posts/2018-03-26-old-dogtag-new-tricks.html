<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Fraser's IdM Blog - Can we teach an old Dogtag new tricks?</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Fraser's IdM Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <div class="info">
    
    Tags: <a href="../tags/dogtag.html">dogtag</a>, <a href="../tags/java.html">java</a>, <a href="../tags/haskell.html">haskell</a>, <a href="../tags/programming.html">programming</a>
    
</div>

<div id="postContent">
    <h1 id="can-we-teach-an-old-dogtag-new-tricks">Can we teach an old Dogtag new tricks?</h1>
<p>Dogtag is a very old program. It started at <em>Netscape</em>. It is old enough to vote. Most of it was written in the early days of Java, long before generics or first-class functions. A lot of it has hardly been touched since it was first written.</p>
<p>Old code often follows old practices that are no longer reasonable. This is not an indictment on the original programmers! The capabilities of our tools usually improve over time (certainly true for Java). The way we solve problems often improves over time too, through better libraries and APIs. And back in the ’90s sites like Stack Overflow didn’t exist and there wasn’t as much free software to learn from. Also, observe that Dogtag is still here, 20 years on, used by customers and being actively developed. This is a <em>huge credit</em> to the original developers and everyone who worked on Dogtag in the meantime.</p>
<p>But we cannot deny that today we have a lot of very old Java code that follows outdated practices and is difficult to reason about and maintain. And maintain it we must. Bugs must be fixed, and new features will be developed. Can Dogtag’s code be modernised? <em>Should it</em> be modernised?</p>
<h2 id="costs-of-change-costs-of-avoiding-change">Costs of change, costs of avoiding change</h2>
<p>One option is to accept and embrace the status quo. Touch the old code as little as possible. Make essential fixes only. Do not refactor classes or interfaces. When writing new code, use the existing interfaces, even if they allow (or demand) unsafe use.</p>
<p>There is something to be said for this approach. Dogtag has bugs, but it is “battle hardened”. It is used by large organisations in security-critical infrastructure. Changing things introduces a risk of breaking things. The bigger the change, the bigger the risk. And Dogtag users are some of the biggest, most security-conscious and risk-conscious organisations out there.</p>
<p>On the other hand, persisting with the old code has some drawbacks too. First, there are certainly undiscovered bugs. Avoiding change except when there is a known defect means those bugs will stay hidden—until they manifest themselves in an unpleasant way! Second, old interfaces that require, for example, unsafe mutation of objects, can lead to new bugs when we do fix bugs or implement new features. Finally, existing code that is difficult to reason about, and interfaces that are difficult to use, slow down fixes and new development.</p>
<h2 id="case-study-acls">Case study: ACLs</h2>
<p>Dogtag uses <em>access control lists (ACLs)</em> to govern what users can do in the system. The text representation of an ACL (with wrapping and indication for presentation only) looks like:</p>
<pre><code>certServer.ca.authorities
  :create,modify
  :allow (list,read) user=&quot;anybody&quot;
    ;allow (create,modify,delete) group=&quot;Administrators&quot;
  :Administrators may create and modify lightweight authorities</code></pre>
<p>The fields are:</p>
<ol type="1">
<li>Name of the ACL</li>
<li>List of permissions covered by the ACLs</li>
<li>List of ACL entries. Each entry either grants or denies the listed permissions to users matching an expression</li>
<li>Comment</li>
</ol>
<p>The above ACL grants lightweight CA read permission to all users, while only members of the <code>Administrators</code> group can create, modify or delete them. A typical Dogtag CA subsystem might have around 60 such ACLs. The <em>authorisation subsystem</em> is responsible for loading and enforcing ACLs.</p>
<p>I have touched the ACL machinery a few times in the last couple of years. Most of the changes were bug fixes but I also implemented a small enhancement for merging ACLs with the same name. These were tiny changes; most ACL code is unchanged from prehistoric (pre-Git repo) times. The implementation has several significant issues. Let’s look at a few aspects.</p>
<h3 id="broken-parsing">Broken parsing</h3>
<p>The <code>ACL.parseACL</code> method (<a href="https://github.com/dogtagpki/pki/blob/223e6980c3f3f7a075890897bbb74140cb95279a/base/common/src/com/netscape/certsrv/acls/ACL.java#L191-L289">source</a>) converts the textual representation of an ACL into an internal representation. It’s about 100 lines of Java. Internally it calls <code>ACLEntry.parseACLEntry</code> which is another 40 lines.</p>
<p>The implementation is ad-hoc and inflexible. Fields are found by scanning for delimiters, and their contents are handled in a variety of ways. For fields that can have multiple values, <code>StringTokenizer</code> is used, as in the following (simplified) example:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb2-1" title="1"><span class="bu">StringTokenizer</span> st = <span class="kw">new</span> <span class="bu">StringTokenizer</span>(entriesString, <span class="st">&quot;;&quot;</span>);</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">while</span> (st.<span class="fu">hasMoreTokens</span>()) {</a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="bu">String</span> entryString = st.<span class="fu">nextToken</span>();</a>
<a class="sourceLine" id="cb2-4" title="4">    ACLEntry entry = ACLEntry.<span class="fu">parseACLEntry</span>(acl, entryString);</a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="kw">if</span> (entry == <span class="kw">null</span>)</a>
<a class="sourceLine" id="cb2-6" title="6">        <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">EACLsException</span>(<span class="st">&quot;failed to parse ACL entries&quot;</span>);</a>
<a class="sourceLine" id="cb2-7" title="7">    entry.<span class="fu">setACLEntryString</span>(entryString);</a>
<a class="sourceLine" id="cb2-8" title="8">    acl.<span class="fu">entries</span>.<span class="fu">add</span>(entry);</a>
<a class="sourceLine" id="cb2-9" title="9">}</a></code></pre></div>
<p>So what happens if you have an ACL like the following? Note the semicolon in the group name.</p>
<pre><code>certificate:issue:allow (read) group=&quot;sysadmin;pki&quot;
  :PKI sysadmins can read certificates</code></pre>
<p>The current parser will either fail, or succeed but yield an ACL that makes no sense (I’m not quite sure which). I found a similar issue in real world use where group names contained a colon. The parser was scanning forward for a colon to determine the end of the ACL entries field:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">int</span> finalDelimIdx = unparsedInput.<span class="fu">indexOf</span>(<span class="st">&quot;:&quot;</span>);</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="bu">String</span> entriesString = unparsedInput.<span class="fu">substring</span>(<span class="dv">0</span>, finalDelimIdx);</a></code></pre></div>
<p>This was fixed by scanning backwards from the end of the string for the final colon:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">int</span> finalDelimIdx = unparsedInput.<span class="fu">lastIndexOf</span>(<span class="st">&quot;:&quot;</span>);</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="bu">String</span> entriesString = unparsedInput.<span class="fu">substring</span>(<span class="dv">0</span>, finalDelimIdx);</a></code></pre></div>
<p>Now colons in group names work as expected. But it is broken in a different way: if the comment contains a colon, parsing will fail. These kinds of defects are symptomatic of the ad-hoc, brittle parser implementation.</p>
<h3 id="incomplete-parsing">Incomplete parsing</h3>
<p><code>ACLEntry.parseACLEntry</code> method does not actually parse the access expressions. An ACL expression can look like:</p>
<pre><code>user=&quot;caadmin&quot; || group=&quot;Administrators&quot;</code></pre>
<p>The expression is saved in the <code>ACLEntry</code> as-is, i.e. as a string. Parsing is deferred to ACL evaluation. Parsing work is repeated every time the entry is evaluated. The deferral also means that invalid expressions are silently allowed and can only be noticed when they are evaluated. The effect of an invalid expression depends on the kind of syntax error, and the behaviour of the access evaluator.</p>
<h3 id="access-evaluator-expressions">Access evaluator expressions</h3>
<p>The code that parses access evaluator expressions (e.g. <code>user="bob"</code>) will accept any of <code>=</code>, <code>!=</code>, <code>&gt;</code> or <code>&lt;</code>, even when the nominated access evaluator does not handle the given operator. For example, <code>user&gt;"bob"</code> will be accepted, but the <code>user</code> access evaluator only handles <code>=</code> and <code>!=</code>. It is up to each access evaluator to handle invalid operators appropriately. This is a burden on the programmer. It’s also confusing for users in that semantically invalid expressions like <code>user&gt;"bob"</code> do not result in an error.</p>
<p>Furthermore, the set of access evaluator operators is not extensible. Dogtag administrators can write their own access evaluators and configure Dogtag to use them. But these can only use the <code>=</code>, <code>!=</code>, <code>&gt;</code> or <code>&lt;</code> operators. If you need more than four operators, need non-binary operators, or would prefer different operator symbols, too bad.</p>
<h3 id="acl-evaluation">ACL evaluation</h3>
<p>The <code>AAclAuthz</code> class (<a href="https://github.com/dogtagpki/pki/blob/223e6980c3f3f7a075890897bbb74140cb95279a/base/server/cms/src/com/netscape/cms/authorization/AAclAuthz.java">source</a>) contains around 400 lines of code for evaluating an ACLs for a given user and permissions. (This includes the expression parsing discussed above). In addition, the typical access evaluator class (<code>UserAccessEvaluator</code>, <code>GroupAccessEvaluator</code>, etc.) has about 20 to 40 lines of code dealing with evaluation. The logic is not straightforward to follow.</p>
<p>There is at least one major bug in this code. There is a global configuration that controls whether an ACL’s <em>allow</em> rules or <em>deny</em> rules are processed first. The default is <em>deny,allow</em>, but if you change it to <em>allow,deny</em>, then a matching <em>allow</em> rule will cause denial! Observe (example simplified and commentary added by me):</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">if</span> (order.<span class="fu">equals</span>(<span class="st">&quot;deny&quot;</span>)) {</a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="co">// deny,allow, the default</span></a>
<a class="sourceLine" id="cb7-3" title="3">    entries = <span class="fu">getDenyEntries</span>(nodes, perm);</a>
<a class="sourceLine" id="cb7-4" title="4">} <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="co">// allow,deny</span></a>
<a class="sourceLine" id="cb7-6" title="6">    entries = <span class="fu">getAllowEntries</span>(nodes, perm);</a>
<a class="sourceLine" id="cb7-7" title="7">}</a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="kw">while</span> (entries.<span class="fu">hasMoreElements</span>()) {</a>
<a class="sourceLine" id="cb7-10" title="10">    ACLEntry entry = entries.<span class="fu">nextElement</span>();</a>
<a class="sourceLine" id="cb7-11" title="11">    <span class="kw">if</span> (<span class="fu">evaluateExpressions</span>(</a>
<a class="sourceLine" id="cb7-12" title="12">            authToken,</a>
<a class="sourceLine" id="cb7-13" title="13">            entry.<span class="fu">getAttributeExpressions</span>())) {</a>
<a class="sourceLine" id="cb7-14" title="14">        <span class="co">// if we are in allow,deny mode, we just hit</span></a>
<a class="sourceLine" id="cb7-15" title="15">        <span class="co">// a matching *allow* rule, and deny access</span></a>
<a class="sourceLine" id="cb7-16" title="16">        <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">EACLsException</span>(<span class="st">&quot;permission denied&quot;</span>);</a>
<a class="sourceLine" id="cb7-17" title="17">    }</a>
<a class="sourceLine" id="cb7-18" title="18">}</a></code></pre></div>
<p>The next step of this routine is to process the next set of rules. Like above, if we are in <em>allow,deny</em> mode and encounter a matching <em>deny</em> rule, access will be granted.</p>
<p>This is a serious bug! It completely reverses the meaning of ACLs. In most cases the environment will be completely broken. It also poses a security issue. Because of how broken this setting is, the Dogtag team thinks that it’s unlikely that anyone is running in <em>allow,deny</em> mode. But we can’t be sure, so the bug was assigned <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1556657">CVE-2018-1080</a>.</p>
<p>This defect is present in the initial commit in the Dogtag Git repository (2008). It might have been present in the original implementation. But whenever it was introduced, the problem was not noticed. Several developers who made small changes over the years to the ACL code (logging, formatting, etc) did not notice it. Including me, until very recently.</p>
<p>How has this bug existed for so long? There are several possible factors:</p>
<ul>
<li>Lack of tests, or at least lack of testing in <em>allow,deny</em> mode</li>
<li>Verbose, hard to read code makes it hard to notice a bug that might be more obvious in “pseudo-code”.</li>
<li><a href="https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/">Boolean blindness</a>. A boolean is just a bit, divorced from the context that constructed it. This can lead to misinterpretation. In this case, the boolean result of <code>evaluateExpressions</code> was misinterpreted as <em>allow|deny</em>; the correct interpretation is <em>match|no-match</em>.</li>
<li>Lack of code review. Perhaps peer code review was not practiced when the original implementation was written. Today all patches are reviewed by another Dogtag developer before being merged (we use <a href="https://www.gerritcodereview.com/">Gerrit</a> for that). There is a chance (but not a guarantee) we might have noticed that bug. Maybe a systematic review of old code is warranted.</li>
</ul>
<h2 id="a-better-way">A better way?</h2>
<p>So, looking at one small but important part of Dogtag, we see an old, broken implementation. Some of these problems can be fixed easily (the <em>allow,deny</em> bug). Others require more work (fixing the parsing, extensible access evaluator operators).</p>
<p>Is it worth fixing the non-critical issues? Taking Java as an assumption, it is debatable. The implementation could be cleaned up, type safety improved, bugs fixed. But Java being what it is, even if a lot of the parsing complexity was handled by libraries, the result would still be fairly verbose. Readability and maintainability would still be limited, because of the limitations of Java itself.</p>
<p>So let’s refine our assumption. Instead of <em>Java</em>, we will assume <em>JVM</em>. This opens up to us a bunch of languages that target the JVM, and libraries written using those languages. Dogtag will probably never leave the JVM, for various reasons. But there’s no technical reason we can’t replace old, worn out parts made of Java with new implementations written using languages that have more to offer in terms of correctness, readability and maintainability.</p>
<p>There are <a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">many languages</a> that target the JVM and interoperate with Java. One such language is <a href="https://www.haskell.org/">Haskell</a>, an advanced, pure functional programming (FP) language. JVM support for Haskell comes in the guise of <a href="https://eta-lang.org/">Eta</a>. Eta is a fork of GHC (the most popular Haskell compiler) version 7.10, so any pure Haskell code that worked with GHC 7.10 will work with Eta. I won’t belabour any more gory details of the toolchain right now. Instead, we can dive right into a prototype of ACLs written in Haskell/Eta.</p>
<h2 id="i-haskell-an-acl">I Haskell an ACL</h2>
<p>I assembled a Haskell prototype (<a href="https://github.com/frasertweedale/notes-redhat/tree/master/fp-examples/acl">source code</a>) of the ACL machinery in one day. Much of this time was spent reading the Java implementation so I could preserve its semantics.</p>
<p>The prototype is not complete. It does not support serialisation of ACLs or the heirarchical nature of ACL evaluation (i.e. checking an authorisation on resource <code>foo.bar.baz</code> would check ACLs named <code>foo.bar.baz</code>, <code>foo.bar</code> and <code>foo</code>). It does support parsing and evaluation. We shall see that it resolves the problems in the Java implementation discussed above.</p>
<p>The implementation is about 250 lines of code, roughly ⅓ the size of the Java implementation. It is much easier to read and reason about. Let’s look at a few highlights.</p>
<p>The definitions of the <code>ACL</code> data type, and its constituents, are straightforward:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">type</span> <span class="dt">Permission</span> <span class="ot">=</span> <span class="dt">Text</span>  <span class="co">-- type synonym, for convenience</span></a>
<a class="sourceLine" id="cb8-2" title="2"></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="kw">data</span> <span class="dt">ACLRuleType</span> <span class="ot">=</span> <span class="dt">Allow</span> <span class="op">|</span> <span class="dt">Deny</span></a>
<a class="sourceLine" id="cb8-4" title="4">  <span class="kw">deriving</span> (<span class="dt">Eq</span>) <span class="co">-- auto-derive an equality</span></a>
<a class="sourceLine" id="cb8-5" title="5">                <span class="co">-- test (==) for this type</span></a>
<a class="sourceLine" id="cb8-6" title="6"></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="co">-- a record type with 3 fields</span></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="kw">data</span> <span class="dt">ACLRule</span> <span class="ot">=</span> <span class="dt">ACLRule</span></a>
<a class="sourceLine" id="cb8-9" title="9">  {<span class="ot"> aclRuleType ::</span> <span class="dt">ACLRuleType</span></a>
<a class="sourceLine" id="cb8-10" title="10">  ,<span class="ot"> aclRulePermissions ::</span> [<span class="dt">Permission</span>]</a>
<a class="sourceLine" id="cb8-11" title="11">  ,<span class="ot"> aclRuleExpression ::</span> <span class="dt">ACLExpression</span></a>
<a class="sourceLine" id="cb8-12" title="12">  }</a>
<a class="sourceLine" id="cb8-13" title="13"></a>
<a class="sourceLine" id="cb8-14" title="14"><span class="kw">data</span> <span class="dt">ACL</span> <span class="ot">=</span> <span class="dt">ACL</span></a>
<a class="sourceLine" id="cb8-15" title="15">  {<span class="ot"> aclName ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb8-16" title="16">  ,<span class="ot"> aclPermissions ::</span> [<span class="dt">Permission</span>]</a>
<a class="sourceLine" id="cb8-17" title="17">  ,<span class="ot"> aclRules ::</span> [<span class="dt">ACLRule</span>]</a>
<a class="sourceLine" id="cb8-18" title="18">  ,<span class="ot"> aclDescription ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb8-19" title="19">  }</a></code></pre></div>
<p>The definition of the ACL parser follows the structure of the data type. This aids readability and assists reasoning about correctness:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">acl ::</span> [<span class="dt">Parser</span> <span class="dt">AccessEvaluator</span>] <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">ACL</span></a>
<a class="sourceLine" id="cb9-2" title="2">acl ps <span class="ot">=</span> <span class="dt">ACL</span></a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="op">&lt;$&gt;</span> takeWhile1 (<span class="op">/=</span> <span class="ch">':'</span>) <span class="op">&lt;*</span> char <span class="ch">':'</span></a>
<a class="sourceLine" id="cb9-4" title="4">  <span class="op">&lt;*&gt;</span> (permission <span class="ot">`sepBy1`</span> char <span class="ch">','</span>) <span class="op">&lt;*</span> char <span class="ch">':'</span></a>
<a class="sourceLine" id="cb9-5" title="5">  <span class="op">&lt;*&gt;</span> (rule ps <span class="ot">`sepBy1`</span> spaced (char <span class="ch">';'</span>)) <span class="op">&lt;*</span> char <span class="ch">':'</span></a>
<a class="sourceLine" id="cb9-6" title="6">  <span class="op">&lt;*&gt;</span> takeText</a></code></pre></div>
<p>Each line is a parser for one of the fields of the <code>ACL</code> data type. The <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> <em>infix</em> functions combine these smaller parsers into a parser for the whole <code>ACL</code> type. <code>permission</code> and <code>rule</code> are parsers for the <code>Permission</code> and <code>ACLRule</code> data types, respectively. The <code>sepBy1</code> combinator turns a parser for a single thing into a parser for a list of things.</p>
<p>Note that several of these <em>combinators</em> are not specific to parsers but are derived from, or part of, a common abstraction that parsers happen to inhabit. The actual parser library used is incidental. A simple parser type and all the combinators used in this ACL implementation, written from scratch, would take all of 50 lines.</p>
<p>The <code>[Parser AccessEvaluator]</code> argument (named <code>ps</code>) is a list of parsers for <code>AccessEvaluator</code>. This provides the access evaluator extensibility we desire while ensuring that invalid expressions are rejected. The details are down inside the implementation of <code>rule</code> and are not discussed here.</p>
<p>Next we’ll look at how ACLs are evaluated:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">data</span> <span class="dt">ACLRuleOrder</span> <span class="ot">=</span> <span class="dt">AllowDeny</span> <span class="op">|</span> <span class="dt">DenyAllow</span></a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="kw">data</span> <span class="dt">ACLResult</span> <span class="ot">=</span> <span class="dt">Allowed</span> <span class="op">|</span> <span class="dt">Denied</span></a>
<a class="sourceLine" id="cb10-4" title="4"></a>
<a class="sourceLine" id="cb10-5" title="5">evaluateACL</a>
<a class="sourceLine" id="cb10-6" title="6"><span class="ot">  ::</span> <span class="dt">ACLRuleOrder</span></a>
<a class="sourceLine" id="cb10-7" title="7">  <span class="ot">-&gt;</span> <span class="dt">AuthenticationToken</span></a>
<a class="sourceLine" id="cb10-8" title="8">  <span class="ot">-&gt;</span> <span class="dt">Permission</span></a>
<a class="sourceLine" id="cb10-9" title="9">  <span class="ot">-&gt;</span> <span class="dt">ACL</span></a>
<a class="sourceLine" id="cb10-10" title="10">  <span class="ot">-&gt;</span> <span class="dt">ACLResult</span></a>
<a class="sourceLine" id="cb10-11" title="11">evaluateACL order tok perm (<span class="dt">ACL</span> _ _ rules _ ) <span class="ot">=</span></a>
<a class="sourceLine" id="cb10-12" title="12">  fromMaybe <span class="dt">Denied</span> result  <span class="co">-- deny if no rules matched</span></a>
<a class="sourceLine" id="cb10-13" title="13">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-14" title="14">    permRules <span class="ot">=</span></a>
<a class="sourceLine" id="cb10-15" title="15">      <span class="fu">filter</span> (<span class="fu">elem</span> perm <span class="op">.</span> aclRulePermissions) rules</a>
<a class="sourceLine" id="cb10-16" title="16"></a>
<a class="sourceLine" id="cb10-17" title="17">    orderedRules <span class="ot">=</span> <span class="kw">case</span> order <span class="kw">of</span></a>
<a class="sourceLine" id="cb10-18" title="18">      <span class="dt">DenyAllow</span> <span class="ot">-&gt;</span> denyRules <span class="op">&lt;&gt;</span> allowRules</a>
<a class="sourceLine" id="cb10-19" title="19">      <span class="dt">AllowDeny</span> <span class="ot">-&gt;</span> allowRules <span class="op">&lt;&gt;</span> denyRules</a>
<a class="sourceLine" id="cb10-20" title="20">    denyRules <span class="ot">=</span></a>
<a class="sourceLine" id="cb10-21" title="21">      <span class="fu">filter</span> ((<span class="op">==</span> <span class="dt">Deny</span>) <span class="op">.</span> aclRuleType) permRules</a>
<a class="sourceLine" id="cb10-22" title="22">    allowRules <span class="ot">=</span></a>
<a class="sourceLine" id="cb10-23" title="23">      <span class="fu">filter</span> ((<span class="op">==</span> <span class="dt">Allow</span>) <span class="op">.</span> aclRuleType) permRules</a>
<a class="sourceLine" id="cb10-24" title="24"></a>
<a class="sourceLine" id="cb10-25" title="25">    <span class="co">-- the first matching rule wins</span></a>
<a class="sourceLine" id="cb10-26" title="26">    result <span class="ot">=</span> getFirst</a>
<a class="sourceLine" id="cb10-27" title="27">      (<span class="fu">foldMap</span> (<span class="dt">First</span> <span class="op">.</span> evaluateRule tok) orderedRules)</a></code></pre></div>
<p>Given an <code>ACLRuleOrder</code>, an <code>AuthenticationToken</code> bearing user data, a <code>Permission</code> on the resource being accessed and an <code>ACL</code> for that resource, <code>evaluateACL</code> returns an <code>ACLResult</code> (either <code>Allowed</code> or <code>Denied</code>. The implementation filters rules for the given permission, orders the rules according to the <code>ACLRuleOrder</code>, and returns the result of the first matching rule, or <code>Denied</code> if no rules were matched.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1">evaluateRule</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="ot">  ::</span> <span class="dt">AuthenticationToken</span></a>
<a class="sourceLine" id="cb11-3" title="3">  <span class="ot">-&gt;</span> <span class="dt">ACLRule</span></a>
<a class="sourceLine" id="cb11-4" title="4">  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">ACLResult</span></a>
<a class="sourceLine" id="cb11-5" title="5">evaluateRule tok (<span class="dt">ACLRule</span> ruleType _ expr) <span class="ot">=</span></a>
<a class="sourceLine" id="cb11-6" title="6">  <span class="kw">if</span> evaluateExpression tok expr</a>
<a class="sourceLine" id="cb11-7" title="7">    <span class="kw">then</span> <span class="dt">Just</span> (result ruleType)</a>
<a class="sourceLine" id="cb11-8" title="8">    <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb11-9" title="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-10" title="10">    result <span class="dt">Deny</span> <span class="ot">=</span> <span class="dt">Denied</span></a>
<a class="sourceLine" id="cb11-11" title="11">    result <span class="dt">Allow</span> <span class="ot">=</span> <span class="dt">Allowed</span></a></code></pre></div>
<p>Could the <em>allow,deny</em> bug from the Java implementation occur here? It cannot. Instead of the rule evaluator returning a <code>boolean</code> as in the Java implementation, <code>evaluateRule</code> returns a <code>Maybe ACLResult</code>. If a rule does not match, its result is <code>Nothing</code>. If it does match, the result is <code>Just Denied</code> for <code>Deny</code> rules, or <code>Just Allowed</code> for <code>Allow</code> rules. The first <code>Just</code> result encountered is used directly. It’s still possible to mess up the implementation, for example:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1">result <span class="dt">Deny</span> <span class="ot">=</span> <span class="dt">Allowed</span></a>
<a class="sourceLine" id="cb12-2" title="2">result <span class="dt">Allow</span> <span class="ot">=</span> <span class="dt">Deny</span></a></code></pre></div>
<p>But this kind of error is less likely to occur and more likely to be noticed. Boolean blindness is not a factor.</p>
<h2 id="benefits-of-fp-for-prototyping">Benefits of FP for prototyping</h2>
<p>There are benefits to using functional programming for prototyping or re-implementing parts of a system written in less expressive langauges.</p>
<p>First, a tool like Haskell lets you express the nature of a problem succinctly, and leverage the type system as a design tool as you work towards a solution. The solution can then be translated into Java (or Python, or whatever). Because of the less powerful (or nonexistent) type system, there will be a trade-off. You will either have to throw away some of the type safety, or incur additional complexity to keep it (how much complexity depends on the target language). It would be better if we didn’t have to make this trade-off (e.g. by using Eta). But the need to make the trade-off does not diminish the usefulness of FP as a design tool.</p>
<p>It’s also a great way of learning about an existing part of Dogtag, and checking assumptions. And for finding bugs, and opportunities for improving type safety, APIs or performance. I learned a lot about Dogtag’s ACL implementation by reading the code to understand the problem, then solving the problem using FP. Later, I was able to translate some aspects of the Haskell implementation (e.g. using sum types to represent ACL rule types and the evaluation order setting) back into the Java implementation (as <code>enum</code> types). This improved type safety and readability.</p>
<p>Going forward, for significant new code and for fixes or refactorings in isolated parts of Dogtag’s implementation, I will spend some time representing the problems and designing solutions in Haskell. The resulting programs will be useful artifacts in their own right; a kind of documentation.</p>
<h2 id="where-to-from-here">Where to from here?</h2>
<p>I’ve demonstrated some of the benefits of the Haskell implementation of ACLs. If the Dogtag development team were to agree that we should begin using FP in Dogtag itself, what would the next steps be?</p>
<p>Eta is not yet packaged for Fedora, let alone RHEL. So as a first step we would have to talk to product managers and release engineers about bringing Eta into RHEL. This is probably the biggest hurdle. One team asking for a large and rather green toolchain that’s not used anywhere else (yet) to be brought into RHEL, where it will have to be supported forever, is going to raise eyebrows.</p>
<p>If we clear that hurdle, then comes the work of packaging Eta. Someone (me) will have to become the package mantainer. And by the way, Eta is written in (GHC) Haskell, so we’ll also need to package GHC for RHEL (or RHEL-extras). Fortunately, GHC <em>is</em> packaged for Fedora, so there is less to do there.</p>
<p>The final stage would be integrating Eta into Dogtag. The build system will need to be updated, and we’ll need to work out how we want to use Eta-based functions and objects from Java (and vice-versa). For the ACLs system, we might want to make the old and new implementations available side by side, for a while. We could even run both implementations simultaneously in a <em>sanity check</em> mode, checking that results are consistent and emitting a warning when they diverge.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This post started with a discussion of the costs and risks of making (or avoiding) significant changes in a legacy system. We then looked in detail at the ACLs implementation in Dogtag, noting some of its problems.</p>
<p>We examined a prototype (re)implementation of ACLs in <em>Haskell</em>, noting several advantages over the legacy implementation. FP’s usefulness as a design tool was discussed. Then we discussed the possibility of using FP in Dogtag itself. What would it take to start using Haskell in Dogtag, via the <em>Eta</em> compiler which targets the JVM? There are several hurdles, technical and non-technical.</p>
<p>Is it worth all this effort, just to be in a position where we can (re)write even a small component of Dogtag in a language other than Java? A language that assists the programmer in writing correct, readable and maintainable software? In answering this question, the costs and risks of persisting with legacy languages and APIs must be considered. I believe the answer is “yes”.</p>
</div>
<div id="postFooter">
    <div id="recent">
Recent posts:
<ul>
    
        <li>
            <a href="../posts/2019-08-02-validity-exceeding-ca.html">Certificates need not be limited to the CA’s validity period</a>
        </li>
    
        <li>
            <a href="../posts/2019-07-26-dogtag-replica-ranges.html">Dogtag replica range management</a>
        </li>
    
        <li>
            <a href="../posts/2019-07-19-revocation-self-service.html">Designing revocation self-service for FreeIPA</a>
        </li>
    
        <li>
            <a href="../posts/2019-05-28-a-dn-is-not-a-string.html">A Distinguished Name is not a string</a>
        </li>
    
        <li>
            <a href="../posts/2019-05-24-ipa-cert-fix.html">Fixing expired system certificates in FreeIPA</a>
        </li>
    
</ul>

<div id="recentLinks">
    <a type="application/atom+xml" href="../atom.xml">Atom feed</a>
     <!-- em space -->
    <a href="../archive.html">All posts…</a>
</div>

</div>

    <div id="license">
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
        <img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by/4.0/88x31.png">
    </a>
    <br />
    Except where otherwise noted, this work is licensed under a
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
        Creative Commons Attribution 4.0 International License
    </a>.
</div>

</div>

        </div>
        <div class="clear"></div>
        <div id="footer">
            Generated by
            <a href="https://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
