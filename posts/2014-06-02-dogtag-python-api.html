<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Fraser's IdM Blog - Introduction to the Dogtag Python API</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Fraser's IdM Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <div class="info">
    
    Tags: <a title="All pages tagged 'dogtag'." href="../tags/dogtag.html">dogtag</a>, <a title="All pages tagged 'python'." href="../tags/python.html">python</a>
    
</div>

<div id="postContent">
    <h1 id="introduction-to-the-dogtag-python-api">Introduction to the Dogtag Python API</h1>
<p>There is a Python binding to the Dogtag REST API under active development by Abhishek Koneru. I will be using this API to add support for Dogtag profiles in FreeIPA. This post serves as an introduction to the API, with a particular focus on the profile-related parts.</p>
<p>Because it’s still in development, the API is subject to change. I think the overall structure of the API is fine so hopefully any changes will be minor. The API is well documented so if in doubt, check the docstrings (calling <code>help(&lt;module|class|object&gt;)</code> is a handy way to read the docs in the interactive Python interpreter).</p>
<h2 id="pkiconnection">PKIConnection <a href="#pkiconnection">§</a></h2>
<p>The <code>pki.client.PKIConnection</code> class connects to a Dogtag instance and executes REST verbs on behalf of clients. Internally, it uses the excellent <a href="http://docs.python-requests.org/en/latest/">Requests</a> library.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> pki.client</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a>scheme <span class="op">=</span> <span class="st">'https'</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>host <span class="op">=</span> <span class="st">'localhost'</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>port <span class="op">=</span> <span class="st">'8443'</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>subsystem <span class="op">=</span> <span class="st">'ca'</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>conn <span class="op">=</span> pki.client.PKIConnection(scheme, host, port, subsystem)</span></code></pre></div>
<p>For actions that require authentication, a client certificate is required, in PEM format. Client certificates are often distributed in the PKCS #12 format. In such case, the following command will convert a PKCS #12 client certificate to an unencrypted PEM certificate:</p>
<pre><code>$ openssl pkcs12 -nodes -in cl_cert.p12 -out cl_cert.pem</code></pre>
<p>After telling the <code>PKIConnection</code> where to find the client certificate, the connection object will be ready to use:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>conn.set_authentication_cert(<span class="st">&quot;/path/to/cl_cert.pem&quot;</span>)</span></code></pre></div>
<h2 id="profileclient">ProfileClient <a href="#profileclient">§</a></h2>
<p>The <code>pki.profile.ProfileClient</code> class proxies the profiles-related REST resources.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="im">import</span> pki.profile</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a>profile_client <span class="op">=</span> pki.profile.ProfileClient(conn)</span>
<span id="cb4-4"><a href="#cb4-4"></a>profiles <span class="op">=</span> profile_client.list_profiles()</span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="cf">for</span> profile <span class="kw">in</span> profiles:</span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="cf">pass</span>  <span class="co"># do stuff</span></span></code></pre></div>
<p><code>list_profiles()</code> also takes optional <code>start</code> and <code>size</code> keyword arguments for pagination. For inspecting an individual profile, there is the <code>get_profile</code> method. But first let’s see what happens when we ask for a profile that doesn’t exist:</p>
<pre><code>&gt;&gt;&gt; profile = profile_client.get_profile('nope')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;pki/__init__.py&quot;, line 234, in handler
    raise pki_exception
  pki.ProfileNotFoundException: Profile ID nope not found</code></pre>
<p>So there are nice, specific exception types. There’s a whole bunch of domain-specific exceptions, but I won’t list them here. Moving on, we can have a look at a profile that <em>does</em> exist:</p>
<pre><code>&gt;&gt;&gt; profile = profile_client.get_profile('caServerCert')
&gt;&gt;&gt;
&gt;&gt;&gt; profile
{'ProfileData': {'status': 'enabled', 'visible': True,
'profile_id': u'caServerCert', 'name': u'Manual Server Certificate
Enrollment', 'description': u'This certificate profile is for
enrolling server certificates.'}}
&gt;&gt;&gt;
&gt;&gt;&gt; dir(profile)
['Input', 'Output', 'PolicySets', '__class__', '__delattr__',
'__dict__', '__doc__', '__fo rmat__', '__getattribute__',
'__hash__', '__init__', '__module__', '__new__', '__reduce__' ,
'__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',
'__str__', '__subclasshook__', '__weakref__', 'authenticator_id',
'authorization_acl', 'class_id', 'description', 'enabl ed',
'enabled_by', 'from_json', 'inputs', 'link', 'name', 'outputs',
'policy _sets', 'profile_id', 'renewal', 'visible', 'xml_output']</code></pre>
<p>The relevant attributes can be gleaned from above. At the moment, there’s not a whole lot you can do with a profile object, besides look at it. It contains some metadata about the profile and lists of its inputs, outputs and policies (defaults and constraints).</p>
<p>There’s not much else to the profiles aspect of the API at this time. You can list profiles, inspect profiles, and enable/disable profiles, but you aren’t yet able to create new profiles or perform more advanced profile administration. Future work will (hopefully) add these capabilities.</p>
<h2 id="certclient">CertClient <a href="#certclient">§</a></h2>
<p>Although <code>pki.profile</code> on its own doesn’t currently offer a lot to the API end-user, some other modules do leverage the provided classes and methods in their own behaviours. <code>pki.cert</code> is one such module.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="im">import</span> pki.cert</span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a>cert_client <span class="op">=</span> pki.cert.CertClient(conn)</span>
<span id="cb7-4"><a href="#cb7-4"></a></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="co"># enrol a certificate</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>inputs <span class="op">=</span> {</span>
<span id="cb7-7"><a href="#cb7-7"></a>  <span class="st">&quot;cert_request_type&quot;</span>: <span class="st">&quot;pkcs10&quot;</span>,</span>
<span id="cb7-8"><a href="#cb7-8"></a>  <span class="st">&quot;cert_request&quot;</span>: <span class="st">&quot;MIIBmDCC... (a PEM certificate request)&quot;</span>,</span>
<span id="cb7-9"><a href="#cb7-9"></a>  <span class="st">&quot;requestor_name&quot;</span>: <span class="st">&quot;John A. Citizen&quot;</span>,</span>
<span id="cb7-10"><a href="#cb7-10"></a>  <span class="st">&quot;requestor_email&quot;</span>: <span class="st">&quot;jcitizen@example.tld&quot;</span>,</span>
<span id="cb7-11"><a href="#cb7-11"></a>}</span>
<span id="cb7-12"><a href="#cb7-12"></a>enroll_req <span class="op">=</span> cert_client.create_enrollment_request(<span class="st">&quot;caServerCert&quot;</span>, inputs)</span>
<span id="cb7-13"><a href="#cb7-13"></a>req_infos <span class="op">=</span> cert_client.submit_enrollment_request(enroll_req)</span></code></pre></div>
<p>The above instantiates a <code>CertClient</code> (reusing the connection object from before), creates a certificate enrollment request for the <code>caServerCert</code> profile (using the given inputs) and submits the certificate enrollment request. A certificate enrollment can actually involve multiple certificates, so the <code>req_infos</code> variable above contains a <code>CertRequestInfoCollection</code> object. Completing the enrollment involves iterating over this collection and approving each certificate request.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a>certificates <span class="op">=</span> []</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="cf">for</span> req_info <span class="kw">in</span> req_infos:</span>
<span id="cb8-3"><a href="#cb8-3"></a>  req_id <span class="op">=</span> req_info.request_id</span>
<span id="cb8-4"><a href="#cb8-4"></a>  cert_client.approve_request(req_id)</span>
<span id="cb8-5"><a href="#cb8-5"></a>  cert_id <span class="op">=</span> cert_client.get_request(req_id).cert_id</span>
<span id="cb8-6"><a href="#cb8-6"></a>  certificates.append(cert_client.get_cert(cert_id))</span></code></pre></div>
<p>Assuming nothing went wrong, <code>certificates</code> now contains a <code>list</code> of <code>pki.cert.CertData</code> objects, but took quite a few operations to get from the enrollment request inputs to our actual certificate(s). Fortunately, the API provides a convenience method to take care of all these details:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a>profile_id <span class="op">=</span> <span class="st">&quot;caServerCert&quot;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>certificates <span class="op">=</span> cert_client.enroll_cert(profile_id, inputs)</span></code></pre></div>
<p><code>enroll_cert</code> takes care of all the details and returns a list of <code>CertData</code> objects when it completes. If this particular process of certificate enrollment request generation, submission, approval and certificate retrieval turns out to be a common use case, this method will save a lot of typing, but it’s important to know how it works and what it does behind the scenes.</p>
<p>Let’s now have a look at one of these <code>CertData</code> objects:</p>
<pre><code>&gt;&gt;&gt; type(cert)
&lt;class 'pki.cert.CertData'&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; cert
{'CertData': {'status': u'VALID', 'serial_number': u'0x17',
'subject_dn': u'CN=TestServer,O=Red Hat Inc.,L=Raleigh,ST=NC,C=US'}}
&gt;&gt;&gt;
&gt;&gt;&gt; dir(cert)
['__class__', '__delattr__', '__dict__', '__doc__', '__format__',
'__getattribute__', '__hash__', '__init__', '__module__',
'__new__', '__reduce__', '__reduce_ex__', '__repr__',
'__setattr__', '__sizeof__', '__str__', '__subclasshook__',
'__weakref__', 'encoded', 'from_json', 'issuer_dn', 'link',
'nonce', 'not_after', 'not_before', 'pkcs7_cert_chain',
'pretty_repr', 'serial_number', 'status', 'subject_dn']
&gt;&gt;&gt;
&gt;&gt;&gt; cert.encoded
u'-----BEGIN CERTIFICATE-----\nMIIDFjCCA... (a PEM-encoded certificate)'</code></pre>
<p>It has all the things you’d expect a data type representing a digital certificate to have.</p>
<p>As you might expect, enrolling new certificates is not the only way to get at a <code>CertData</code> object. The <code>CertClient</code> API supports listing and searching certificates, revocation and more. It also supports the whole gamut of CA agent operations with respect to pending certificate requests. In addition to approving requests, requests can be reviewed, rejected, assigned to another agent, and so on.</p>
<h2 id="conclusion">Conclusion <a href="#conclusion">§</a></h2>
<p>There are many details and features of the Dogtag Python API that were not covered in this post, but the most important details have been covered, and I hope I have conveyed a comprehension of the high-level organisation of the API and the common idioms.</p>
<p>As mentioned at the beginning of this post, the API is not yet released and is subject to change, but feel free to <a href="https://git.fedorahosted.org/cgit/pki.git">have a look at the code</a> or begin experimenting with it. The Dogtag developers welcome feedback and <a href="http://www.redhat.com/mailman/listinfo/pki-devel">pki-devel mailing list</a> is the place to provide it.</p>
</div>
<div id="postFooter">
    <div id="recent">
Recent posts:
<ul>
    
        <li>
            <a href="../posts/2020-12-16-java-jna.html">Simple Java to C bindings via JNA</a>
        </li>
    
        <li>
            <a href="../posts/2020-12-08-k8s-srv-limitation.html">Kubernetes DNS Service Discovery limitations</a>
        </li>
    
        <li>
            <a href="../posts/2020-12-05-pod-hostname-fqdn.html">Pod hostnames and FQDNs</a>
        </li>
    
        <li>
            <a href="../posts/2020-12-01-openshift-crio-userns.html">User namespaces in OpenShift via CRI-O annotations</a>
        </li>
    
        <li>
            <a href="../posts/2020-11-30-openshift-machine-config-operator.html">Using the OpenShift Machine Config Operator</a>
        </li>
    
</ul>

<div id="recentLinks">
    <a type="application/atom+xml" href="../atom.xml">Atom feed</a>
     <!-- em space -->
    <a href="../archive.html">All posts…</a>
</div>

</div>

    <div id="license">
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
        <img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by/4.0/88x31.png">
    </a>
    <br />
    Except where otherwise noted, this work is licensed under a
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
        Creative Commons Attribution 4.0 International License
    </a>.
</div>

</div>

        </div>
        <div class="clear"></div>
        <div id="footer">
            Generated by
            <a href="https://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
