<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Fraser's IdM Blog - Dogtag replica range management</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Fraser's IdM Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <div class="info">
    
    Tags: <a title="All pages tagged 'dogtag'." href="../tags/dogtag.html">dogtag</a>, <a title="All pages tagged 'troubleshooting'." href="../tags/troubleshooting.html">troubleshooting</a>, <a title="All pages tagged 'internals'." href="../tags/internals.html">internals</a>
    
</div>

<div id="postContent">
    <h1 id="dogtag-replica-range-management">Dogtag replica range management</h1>
<p>Dogtag supports distributed deployment, with multiple <em>replicas</em> (also called <em>clones</em>) processing requests and issuing certificates. All replicas read and write a replicated LDAP database. A Dogtag server can create many kinds of objects: certificates, requests, archived keys or secrets. These objects need identifiers that are unique across the deployment.</p>
<p>How does a Dogtag clone choose an identifier for a new object? In this post I will explain Dogtag’s <em>range management</em>—how it works, how it can break, and what to do if it does.</p>
<h2 id="object-types-with-managed-ranges">Object types with managed ranges <a href="#object-types-with-managed-ranges">§</a></h2>
<p>There are several types of objects for which Dogtag manages identifier ranges. For example:</p>
<ul>
<li>Certificate serial numbers; it is essential that these be unique. Collisions are a violation of X.509 and can lead to erroneous <strong>denial of service</strong>, or <strong>false positive</strong> validity, when revocation comes into play.</li>
<li>Certificate requests (including revocation and renewal requests) are stored in the database and must have a unique ID. Clobbering of requests objects due to range conflicts can lead to renewal request failures resulting in <strong>denial of service</strong>, or worse, issuance of a valid certificate with incorrect details, allowing <strong>impersonation</strong> attacks.</li>
<li>KRA request identifiers are assigned from a managed range.</li>
<li>KRA archived key and data objects are assigned from a managed range.</li>
<li>Clones themselves are assigned identifiers when they are created; these come from managed ranges.</li>
</ul>
<p>The identifiers themselves are unbounded nonzero integers. All of the managed ranges are separate domains. That is, the same numbers exist in each range, and the ranges are managed independently.</p>
<h2 id="active-and-standby-ranges">Active and standby ranges <a href="#active-and-standby-ranges">§</a></h2>
<p>For each kind of range, each replica remembers up to two range assignments. The <em>active</em> range is the range from which identifiers are actively assigned. When the active range is exhausted, the <em>standby</em> range becomes the active range and the clone acquires a new range assignment, which will be the new standby range. A clone doesn’t necessarily have a standby range at all times. It only acquires a new allocation for the standby range when the unused amount of its active range falls below some configured <em>low water mark</em>.</p>
<h2 id="range-assignments">Range assignments <a href="#range-assignments">§</a></h2>
<p>Range assignments are recorded in LDAP. A clone’s active and standby ranges are also recorded in the clone’s <code>CS.cfg</code> configuration file. A range object looks like:</p>
<pre><code>dn: cn=10000001,ou=certificateRepository,ou=ranges,o=ipaca
objectClass: top
objectClass: pkiRange
beginRange: 10000001
endRange: 20000000
cn: 10000001
host: f30-1.ipa.local
SecurePort: 443</code></pre>
<p>This is a serial number range assignment. Host <code>f30-1.ipa.local</code> has been assigned the range <code>10000001..20000000</code>. It is not apparent from this object, but these are actually <strong>hexadecimal</strong> numbers! Whether the numbers are decimal or hexadecimal varies among managed ranges.</p>
<p>The directives in the <code>CS.cfg</code> on <code>f30-1.ipa.local</code> reflect this assignment:</p>
<pre><code>dbs.enableSerialManagement=true

dbs.beginSerialNumber=fff0001
dbs.endSerialNumber=10000000

dbs.nextBeginSerialNumber=10000001
dbs.nextEndSerialNumber=20000000

dbs.enableRandomSerialNumbers=false
dbs.randomSerialNumberCounter=-1

dbs.serialCloneTransferNumber=10000
dbs.serialIncrement=10000000
dbs.serialLowWaterMark=2000000</code></pre>
<p>The active range is <code>fff0001..10000000</code>, and the standby range is <code>10000001..20000000</code>, which corresponds to the LDAP entry shown above.</p>
<h3 id="range-delegation">Range delegation <a href="#range-delegation">§</a></h3>
<p>Why is <code>f30-1</code>’s active range so much smaller than its standby range? This is the result of how ranges are assigned during cloning. When creating a clone, the server being configured contacts an existing clone and asks it for some configuration values, including serial/request/replica ID ranges. The existing clone <em>delegates</em> to the new clone a small segment of either its active or standby range. It delegates <em>from the end</em> of its active range, but if there are not enough numbers left in the active range, it delegates from the end the standby range instead.</p>
<p>The size of the range delegation is configured in <code>CS.cfg</code>. For example, for serial numbers it is the <code>dbs.serialCloneTransferNumber</code> setting. I have never heard of anyone changing the default, and I can’t think of a reason to do so.</p>
<p>Because the delegation is a portion of an already-assigned range (with corresponding LDAP object), new LDAP range objects are not created for delegated ranges, and the existing range object is not modified in any way. Therefore, LDAP only ever shows the <em>original</em> range assignments.</p>
<p>This range delegation procedure has been a source of bugs. For example, <a href="https://pagure.io/dogtagpki/issue/3055">issue 3055</a> was a cloning failure when creating two clones (call them <em>C</em> and <em>D</em>) from a server that is itself a clone (call it <em>B</em>). Because the delegation size is fixed (the <code>dbs.serialCloneTransferNumber</code> setting), creating <em>C</em> delegates <em>B</em>’s whole active range to <em>C</em>. Unless <em>B</em> had a chance to switch to its standby range (when didn’t happen during cloning), creating the second clone <em>D</em> would fail because <em>B</em>’s active range was exhausted. This issue was fixed, but a more robust solution is to do away with range delegation entirely; the server can create full range assignments for the new clone instead of delegating part of its own range assignment. <a href="https://pagure.io/dogtagpki/issue/3060">Issue 3060</a> tracks this work.</p>
<h2 id="random-serial-numbers">Random serial numbers <a href="#random-serial-numbers">§</a></h2>
<p>Most repositories with range management yield numbers sequentially from the active ranges. For the certificate repository only, you can optionally enable <em>random</em> serial numbers. Numbers are chosen by a uniform random sample from the clone’s assigned range. Dogtag checks to make sure the number was not already used; if it was used, it tries again (and again, up to a limit).</p>
<p>Some additional configuration values come into play when using random serial numbers:</p>
<dl>
<dt><code>dbs.enableRandomSerialNumbers</code></dt>
<dd><p>Enable random serial numbers (default: off)</p>
</dd>
<dt><code>dbs.collisionRecoverySteps</code></dt>
<dd><p>How many retries when a collision is detected (default: 10)</p>
</dd>
<dt><code>dbs.minimumRandomBits</code></dt>
<dd><p>Minimum size of the range, in bits (default: 4 bits)</p>
</dd>
<dt><code>dbs.serialLowWaterMark</code></dt>
<dd><p>Switch to standby range when there are fewer than this many serials left in the range (default: 2000000)</p>
</dd>
</dl>
<p>Critically, The <code>dbs.minimumRandomBits</code> does <em>not</em> determine how much entry is in the serial number. If many serial numbers in the range have already been used, the actual number of serials left could be less than <code>dbs.minimumRandomBits</code> of entropy. When issuing random serial numbers, the server keeps a running count of how many serial numbers have been used in the active range. When the range size minus the current count falls below <code>dbs.serialLowWaterMark</code>, the server switches to the standby range. Therefore it is <code>dbs.serialLowWaterMark</code>, not <code>dbs.minimumRandomBits</code>, that actually controls the minimum amount of randomness in the serial number.</p>
<h2 id="switching-to-the-standby-range">Switching to the standby range <a href="#switching-to-the-standby-range">§</a></h2>
<p>The actions performed by the subroutine that switches to the next range are:</p>
<dl>
<dt>1. Set the active range start and end variables to the standby range</dt>
<dd><p>start and end</p>
</dd>
</dl>
<ol>
<li>Reset the standby range start and end variables to <code>null</code></li>
<li>Reset counters</li>
<li>Persist these changes to <code>CS.cfg</code>.</li>
</ol>
<p>The switchover procedure <strong>does not acquire a new standby range assignment</strong>. Immediately after switching to the standby range, there isn’t a standby range anymore.</p>
<h2 id="acquiring-a-new-range-assignment">Acquiring a new range assignment <a href="#acquiring-a-new-range-assignment">§</a></h2>
<p>As currently implemented, a new standby range is <strong>only acquired at system startup</strong>. Dogtag checks each repository to see if the amount of unused numbers in the active range has fallen below the <em>low water mark</em>. If it has, and if there is no standby range, it self-allocates a new range assignment in LDAP. The size of the allocation is determined by <code>CS.cfg</code> configurables, and its lower bound is the value of the <code>nextRange</code> attribute in the repository parent LDAP object. It adds a range object to the ranges subtree, and updates the <code>nextRange</code> attribute on the repository parent. See the appendix for a list of which subtree parents and range entries are involved for each repository.</p>
<p>This procedure is brittle under the possibliity of LDAP replication races or transient failures. Two clones could end up adding the same range, and a replication error will occur. This can lead to identifier collisions resulting in problems later (see earlier discussion).</p>
<h2 id="internals">Internals <a href="#internals">§</a></h2>
<p>Most of everything discussed so far lives in the <code>Repository</code> class, with <code>CertificateRepository</code> providing additional behaviour related to random serial numbers. Code for acquiring a new range assignment lives in <code>DBSubsystem</code>. Some methods of interest include:</p>
<dl>
<dt><code>Repository.getNextSerialNumber</code></dt>
<dd><p>Get the next number; calls <code>checkRange</code> before returning it</p>
</dd>
<dt><code>Repository.checkRange</code></dt>
<dd><p>Check if the range is exhausted; if so call <code>switchToNextRange</code></p>
</dd>
<dt><code>Repository.switchToNextRange</code></dt>
<dd><p>Switches to next range (see discussion in earlier section)</p>
</dd>
<dt><code>Repository.checkRanges</code></dt>
<dd><p>Sanity checks the active and standby ranges; acquires new range allocation if necessary (by calling <code>DBSubsystem.getNextRange</code>) and persists the changes to <code>CS.cfg</code>.</p>
</dd>
<dt><code>DBSubsystem.getNextRange</code></dt>
<dd><p>This method creates the LDAP range object and updates the <code>nextRange</code> attribute, returning the range bounds to the caller.</p>
</dd>
</dl>
<h2 id="fixing-range-conflicts">Fixing range conflicts <a href="#fixing-range-conflicts">§</a></h2>
<p>If you have range conflicts, the following high-level steps can be followed to fix them:</p>
<ol type="1">
<li>Stop all Dogtag servers.</li>
<li>Resolve any replication issues or conflict entries.</li>
<li>Examine active and standby ranges in <code>CS.cfg</code> on all replicas.</li>
<li>If there are any conflicts (including between active and standby ranges), choose new ranges such that there are no conflicts. Update <code>CS.cfg</code> of each replica with its new ranges.</li>
<li>Update the <code>nextRange</code> attribute for each repository object to a number <em>greater than</em> the highest number of any allocated range (<em>max + 1</em> is fine). See appendix for the objects involved.</li>
<li><em>(Optional)</em> Update and add new range entries. This is not essential because nothing will break if the ranges entries don’t actually correspond to what’s in each replica’s <code>CS.cfg</code>. But is is still desirable that the LDAP entries reflect the configuration of each server.</li>
<li>Start Dogtag servers. If some servers do not have a standby range, it is a good idea to stagger their startup. Otherwise there is a high risk of an immediate replication race causing range conflicts as servers acquire new range assignments.</li>
</ol>
<p>Note that this procedure will <em>not</em> save your skin if, e.g., multiple certificates with the same serial number were issued. Renewal problems may be unavoidable when collisions have occurred. This is the main reason we are switching to <a href="https://pagure.io/freeipa/issue/7991">profile-based renewal</a> for FreeIPA system certificates. Renewal requests refer to existing certificate and requests by serial / request ID. Thus if there have been range conflicts they are susceptible to failure or issuance of certificates with incorrect attributes. Performing a “fresh enrolment” when renewing system certificates avoids these problems because the profile enrolment request does not refer to any existing certificates or requests.</p>
<h2 id="discussion">Discussion <a href="#discussion">§</a></h2>
<p>Dogtag is over 20 years old, and I suppose that sequential numbers with range management made sense at the time. Maybe a multi-server deployment with a replicated database was not foreseen, and range management was bolted on later when the requirement emerged. Maybe using random identifiers was seen as difficult to get write; UUIDs were not widespread back then. Or maybe using random numbers was seen as not user-friendly (and that is true, but when you have more than one replica the ranged identifiers aren’t much better).</p>
<p>On the fact of some ranges using base 16 (hexademical) and others using base 10: I cannot even imagine why this is so. Extra user and operator pain, for what gain? I cannot tell. The reasons are probably, like so many things in old programs, lost in time.</p>
<p>The random serial number configuration and behaviour is… not state of the art. The program logic is difficult to follow and it is not clear which configuration directives govern the (minimum) amount of entropy in the chosen numbers.</p>
<p>If I were designing a system like Dogtag today, I would use random UUIDs for everything, except possibly serial numbers. There are <a href="https://en.wikipedia.org/wiki/UUID#Version_4_(random)">122 bits of entropy</a> in a Version 4 UUID. The current CA/Browser Forum <a href="https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.6.5.pdf">Baseline Requirements</a> (v1.6.5) require serial numbers with 64 bits of high-quality randomness, but if that is ever increased beyond 122 bits a UUID won’t cut it anymore. So I would just use very large random numbers for all serial numbers.</p>
<p>Can we move Dogtag from what we have now to something more robust? Of course it is possible, but it would be a big effort. So all that is likely to happen is smaller, well understood and bounded efforts with an obvious payoff, like avoiding range delegation (<a href="https://pagure.io/dogtagpki/issue/3060">Issue 3060</a>).</p>
<p>The new FreeIPA <a href="https://www.freeipa.org/page/V4/Healthcheck">Health Check</a> system provides pluggable checks for system health. There is an open ticket to implement Dogtag range conflict and sanity checking in the Health Check tool, so that problems can be detected before they cause major failures.</p>
<h2 id="appendix-range-configuration-directives-and-objects">Appendix: range configuration directives and objects <a href="#appendix-range-configuration-directives-and-objects">§</a></h2>
<p>In all LDAP DNs below, substitute <code>o=ipaca</code> with the relevant base DN.</p>
<h3 id="certificate-serial-numbers">Certificate serial numbers <a href="#certificate-serial-numbers">§</a></h3>
<p>Base: <strong>hexademical</strong></p>
<p><code>CS.cfg</code> attributes:</p>
<pre><code>dbs.beginSerialNumber
dbs.endSerialNumber
dbs.nextBeginSerialNumber
dbs.nextEndSerialNumber
dbs.serialIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=certificateRepository,ou=ca,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=certificateRepository,ou=ranges,o=ipaca</code></pre>
<h3 id="ca-requests">CA requests <a href="#ca-requests">§</a></h3>
<p>Base: <strong>demical</strong></p>
<p><code>CS.cfg</code> attributes:</p>
<pre><code>dbs.beginRequestNumber
dbs.endRequestNumber
dbs.nextBeginRequestNumber
dbs.nextEndRequestNumber
dbs.requestIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=ca,ou=requests,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=requests,ou=ranges,o=ipaca</code></pre>
<h3 id="replica-numbers">Replica numbers <a href="#replica-numbers">§</a></h3>
<p>Base: <strong>demical</strong></p>
<p><code>CS.cfg</code> attributes:</p>
<pre><code>dbs.beginReplicaNumber
dbs.endReplicaNumber
dbs.nextBeginReplicaNumber
dbs.nextEndReplicaNumber
dbs.replicaIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=replica,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=replica,ou=ranges,o=ipaca</code></pre>
<h3 id="kra-keys">KRA keys <a href="#kra-keys">§</a></h3>
<p>Base: <strong>hexademical</strong></p>
<p><code>kra/CS.cfg</code> attributes:</p>
<pre><code>dbs.beginSerialNumber
dbs.endSerialNumber
dbs.nextBeginSerialNumber
dbs.nextEndSerialNumber
dbs.serialIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=keyRepository,ou=kra,o=kra,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=keyRepository,ou=ranges,o=kra,o=ipaca</code></pre>
<h3 id="kra-requests">KRA requests <a href="#kra-requests">§</a></h3>
<p>Base: <strong>demical</strong></p>
<p><code>kra/CS.cfg</code> attributes:</p>
<pre><code>dbs.beginRequestNumber
dbs.endRequestNumber
dbs.nextBeginRequestNumber
dbs.nextEndRequestNumber
dbs.requestIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=kra,ou=requests,o=kra,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=requests,ou=ranges,o=kra,o=ipaca</code></pre>
<h3 id="kra-replicas-numbers">KRA replicas numbers <a href="#kra-replicas-numbers">§</a></h3>
<p>Base: <strong>demical</strong></p>
<p><code>CS.cfg</code> attributes:</p>
<pre><code>dbs.beginReplicaNumber
dbs.endReplicaNumber
dbs.nextBeginReplicaNumber
dbs.nextEndReplicaNumber
dbs.replicaIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=replica,o=kra,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=replica,ou=ranges,o=kra,o=ipaca</code></pre>
</div>
<div id="postFooter">
    <div id="recent">
Recent posts:
<ul>
    
        <li>
            <a href="../posts/2020-12-16-java-jna.html">Simple Java to C bindings via JNA</a>
        </li>
    
        <li>
            <a href="../posts/2020-12-08-k8s-srv-limitation.html">Kubernetes DNS Service Discovery limitations</a>
        </li>
    
        <li>
            <a href="../posts/2020-12-05-pod-hostname-fqdn.html">Pod hostnames and FQDNs</a>
        </li>
    
        <li>
            <a href="../posts/2020-12-01-openshift-crio-userns.html">User namespaces in OpenShift via CRI-O annotations</a>
        </li>
    
        <li>
            <a href="../posts/2020-11-30-openshift-machine-config-operator.html">Using the OpenShift Machine Config Operator</a>
        </li>
    
</ul>

<div id="recentLinks">
    <a type="application/atom+xml" href="../atom.xml">Atom feed</a>
     <!-- em space -->
    <a href="../archive.html">All posts…</a>
</div>

</div>

    <div id="license">
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
        <img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by/4.0/88x31.png">
    </a>
    <br />
    Except where otherwise noted, this work is licensed under a
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
        Creative Commons Attribution 4.0 International License
    </a>.
</div>

</div>

        </div>
        <div class="clear"></div>
        <div id="footer">
            Generated by
            <a href="https://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
