<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Fraser's IdM Blog - OTP authentication in FreeIPA</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Fraser's IdM Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <div class="info">
    
    Tags: <a title="All pages tagged 'freeipa'." href="../tags/freeipa.html">freeipa</a>, <a title="All pages tagged '2fa'." href="../tags/2fa.html">2fa</a>, <a title="All pages tagged 'internals'." href="../tags/internals.html">internals</a>
    
</div>

<div id="postContent">
    <h1 id="otp-authentication-in-freeipa">OTP authentication in FreeIPA</h1>
<p>As of <a href="https://www.freeipa.org/page/Releases/4.0.0#Highlights_in_4.0.0">release 4.0.0</a>, FreeIPA supports <a href="https://en.wikipedia.org/wiki/One-time_password">OTP</a> authentication. <a href="https://en.wikipedia.org/wiki/HMAC-based_One-time_Password_Algorithm">HOTP</a> and <a href="https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm">TOTP</a> tokens are supported natively, and there is also support for proxying requests to a separately administered <a href="https://en.wikipedia.org/wiki/RADIUS">RADIUS</a> server.</p>
<p>To become more familiar with FreeIPA and its capabilities, I have been spending a little time each week setting up scenarios and testing different features. Last week, I began playing with a <a href="http://www.yubico.com/products/yubikey-hardware/yubikey/">YubiKey</a> for HOTP authentication. A separate blog about using YubiKey with FreeIPA will follow, but first I wanted to post about how FreeIPA’s native OTP support is implemented. This deep dive was unfortunately the result of some issues I encountered, but I learned a lot in a short time and I can now share this information, so maybe it wasn’t unfortunate after all.</p>
<h2 id="user-view-of-otp">User view of OTP</h2>
<p>A user has received or enrolled an OTP token. This may be a hardware token, such as YubiKey, or a software token like <a href="https://fedorahosted.org/freeotp/">FreeOTP</a> for mobile devices, which can capture the token simply by pointing the camera at the QR code FreeIPA generates.</p>
<p>When logging in to an IPA-backed service, the FreeIPA web UI, or when running <code>kinit</code>, the user uses their token to generate a single-use value, which is appended to their usual password. To authenticate the user, this single-use value is validated in addition to the usual password validation, providing an additional factor of security.</p>
<h2 id="hotp-algorithm">HOTP algorithm</h2>
<p>The HMAC-based One-Time Password (HOTP) algorithm uses a secret key that is known to the validation server and the token device or software. The key is used to generate an HMAC of a monotonically increasing counter that is incremented each time a new token is generated. The output of the HMAC function is then truncated to a short numeric code - often 6 or 8 digits. This is the single-use OTP value that is transmitted to the server. Because the server knows the secret key and the current value of the counter, it can validate the value sent by the client.</p>
<p>HOTP is specified in <a href="http://tools.ietf.org/html/rfc4226">RFC 4226</a>. TOTP (Time-based One-Time Password), specified in <a href="http://tools.ietf.org/html/rfc6238">RFC 6238</a>, is a variation of HOTP that MACs the number of <em>time steps</em> since the UNIX epoch, instead of a counter.</p>
<h2 id="authentication-flow">Authentication flow</h2>
<p>The problem I encountered was that HOTP authentication (to the FreeIPA web UI) was failing about half the time (there was no discernable pattern of failure). The FreeIPA web UI seemed like a logical place to start investigating the problem, but for a password (and OTP value) it is just the first port of call in a journey through a remarkable number of services and libraries.</p>
<h3 id="web-ui-and-kinit">Web UI and <code>kinit</code></h3>
<p>The <code>ipaserver.rpcserver.login_password</code> class is responsible for handling the password login process. It’s implementation reads request parameters and calls <code>kinit(1)</code> with the user credentials. Its (heavily abridged) implementation follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">class</span> login_password(Backend, KerberosSession, HTTP_Status):</span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, environ, start_response):</span>
<span id="cb1-3"><a href="#cb1-3"></a>        <span class="co"># Get the user and password parameters from the request</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>        query_dict <span class="op">=</span> urlparse.parse_qs(query_string)</span>
<span id="cb1-5"><a href="#cb1-5"></a>        user <span class="op">=</span> query_dict.get(<span class="st">'user'</span>, <span class="va">None</span>)</span>
<span id="cb1-6"><a href="#cb1-6"></a>        password <span class="op">=</span> query_dict.get(<span class="st">'password'</span>, <span class="va">None</span>)</span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a>        <span class="co"># Get the ccache we'll use and attempt to get</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>        <span class="co"># credentials in it with user,password</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>        ipa_ccache_name <span class="op">=</span> get_ipa_ccache_name()</span>
<span id="cb1-11"><a href="#cb1-11"></a>        <span class="va">self</span>.kinit(user, <span class="va">self</span>.api.env.realm, password, ipa_ccache_name)</span>
<span id="cb1-12"><a href="#cb1-12"></a>        <span class="cf">return</span> <span class="va">self</span>.finalize_kerberos_acquisition(</span>
<span id="cb1-13"><a href="#cb1-13"></a>            <span class="st">'login_password'</span>, ipa_ccache_name, environ, start_response)</span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a>    <span class="kw">def</span> kinit(<span class="va">self</span>, user, realm, password, ccache_name):</span>
<span id="cb1-16"><a href="#cb1-16"></a>        <span class="co"># get http service ccache as an armor for FAST to enable</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>        <span class="co"># OTP authentication</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>        armor_principal <span class="op">=</span> krb5_format_service_principal_name(</span>
<span id="cb1-19"><a href="#cb1-19"></a>            <span class="st">'HTTP'</span>, <span class="va">self</span>.api.env.host, realm)</span>
<span id="cb1-20"><a href="#cb1-20"></a>        keytab <span class="op">=</span> paths.IPA_KEYTAB</span>
<span id="cb1-21"><a href="#cb1-21"></a>        armor_name <span class="op">=</span> <span class="st">&quot;</span><span class="sc">%s</span><span class="st">A_</span><span class="sc">%s</span><span class="st">&quot;</span> <span class="op">%</span> (krbccache_prefix, user)</span>
<span id="cb1-22"><a href="#cb1-22"></a>        armor_path <span class="op">=</span> os.path.join(krbccache_dir, armor_name)</span>
<span id="cb1-23"><a href="#cb1-23"></a></span>
<span id="cb1-24"><a href="#cb1-24"></a>        (stdout, stderr, returncode) <span class="op">=</span> ipautil.run(</span>
<span id="cb1-25"><a href="#cb1-25"></a>            [paths.KINIT, <span class="st">'-kt'</span>, keytab, armor_principal],</span>
<span id="cb1-26"><a href="#cb1-26"></a>            env<span class="op">=</span>{<span class="st">'KRB5CCNAME'</span>: armor_path}, raiseonerr<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-27"><a href="#cb1-27"></a></span>
<span id="cb1-28"><a href="#cb1-28"></a>        <span class="co"># Format the user as a kerberos principal</span></span>
<span id="cb1-29"><a href="#cb1-29"></a>        principal <span class="op">=</span> krb5_format_principal_name(user, realm)</span>
<span id="cb1-30"><a href="#cb1-30"></a></span>
<span id="cb1-31"><a href="#cb1-31"></a>        (stdout, stderr, returncode) <span class="op">=</span> ipautil.run(</span>
<span id="cb1-32"><a href="#cb1-32"></a>            [paths.KINIT, principal, <span class="st">'-T'</span>, armor_path],</span>
<span id="cb1-33"><a href="#cb1-33"></a>            env<span class="op">=</span>{<span class="st">'KRB5CCNAME'</span>: ccache_name, <span class="st">'LC_ALL'</span>: <span class="st">'C'</span>},</span>
<span id="cb1-34"><a href="#cb1-34"></a>            stdin<span class="op">=</span>password, raiseonerr<span class="op">=</span><span class="va">False</span>)</span></code></pre></div>
<p>We see that the <code>login_password</code> object reads credentials out of the request and invokes <code>kinit</code> using those credentials, over an encrypted <a href="http://tools.ietf.org/html/rfc6113">FAST</a> (flexible authentication secure tunneling) channel. At this point, the authentication flow is the same as if a user had invoked <code>kinit</code> from the command line in a similar manner.</p>
<h3 id="kdc">KDC</h3>
<p>Recent versions of the MIT Kerberos key distrubution centre (KDC) have support for <a href="http://web.mit.edu/~kerberos/krb5-devel/doc/admin/otp.html">OTP preauthentication</a>. This preauthentication mechanism is specified in <a href="http://tools.ietf.org/html/rfc6560">RFC 6560</a>.</p>
<p>The <code>freeipa-server</code> package ships the <code>ipadb.so</code> KDC database plugin that talks to the database over LDAP to look up principals and their configuration. In this manner the KDC can find out that a principal is configured for OTP authentication, but this is not where OTP validation takes place. Instead, an OTP-enabled principal’s configuration tells the KDC to forward the credentials elsewhere for validation, over RADIUS.</p>
<h3 id="ipa-otpd"><code>ipa-otpd</code></h3>
<p>FreeIPA ships a daemon called <code>ipa-otpd</code>. The KDC communicates with it using the RADIUS protocol, over a UNIX domain socket. When <code>ipa-otpd</code> receives a RADIUS authentication packet, it queries the database over LDAP to see if the principal is configured for RADIUS or native OTP authentication. For RADIUS authentication, it forwards the request on to the configured RADIUS server, otherwise it attempts an LDAP BIND operation using the passed credentials.</p>
<p>As a side note, <code>ipa-otpd</code> is controlled by a <code>systemd</code> socket unit. This is an interesting feature of <code>systemd</code>, but I won’t delve into it here. See <code>man 5 systemd.socket</code> for details.</p>
<h3 id="directory-server">Directory server</h3>
<p>Finally, the principal’s credentials - her distinguished name and password with OTP value appended - reach the database in the form of a BIND request. But we’re still not at the bottom of this rabbit hole, because <a href="http://directory.fedoraproject.org/wiki/Main_Page">389 Directory Server</a> does not know how to validate an OTP value or indeed anything about OTP!</p>
<p>Yet another plugin to the rescue. <code>freeipa-server</code> ships the <code>libipa_pwd_extop.so</code> directory server plugin, which handles concepts such as password expiry and - finally - OTP validation. By way of this plugin, the directory server attempts to validate the OTP value and authenticate the user, and the whole process that led to this point unwinds back through <code>ipa-otpd</code> and the KDC to the Kerberos client (and through the web UI to the browser, if this was how the whole process started).</p>
<h3 id="diagram">Diagram</h3>
<p>My drawing skills leave a lot to be desired, but I’ve tried to summarise the preceding information in the following diagram. Arrows show the communication protocols involved; red arrows carry user credentials including the OTP value. The dotted line and box show the alternative configuration where <code>ipa-otpd</code> proxies the token on to an external RADIUS server.</p>
<p><img src="../images/freeipa_otp_auth_flow.png" alt="image" /></p>
<h2 id="debugging-the-authentication-problem">Debugging the authentication problem</h2>
<p>At time of writing, I still haven’t figured out the cause of my issue. Binding directly to LDAP using an OTP token works every time, so it definitely was not an issue with the HOTP implementation. Executing <code>kinit</code> directly fails about half the time, so the problem is likely to be with the KDC or with <code>ipa-otpd</code>.</p>
<p>When the failure occurs, the <code>dirsrv</code> access log shows two BIND operations for the principal (in the success case, there is only one BIND, as would be expected):</p>
<pre><code>[30/Jul/2014:02:58:54 -0400] conn=23 op=4 BIND dn=&quot;uid=ftweedal,cn=users,cn=accounts,dc=ipa,dc=local&quot; method=128 version=3
[30/Jul/2014:02:58:54 -0400] conn=23 op=4 RESULT err=0 tag=97 nentries=0 etime=0 dn=&quot;uid=ftweedal,cn=users,cn=accounts,dc=ipa,dc=local&quot;
[30/Jul/2014:02:58:55 -0400] conn=37 op=4 BIND dn=&quot;uid=ftweedal,cn=users,cn=accounts,dc=ipa,dc=local&quot; method=128 version=3
[30/Jul/2014:02:58:55 -0400] conn=37 op=4 RESULT err=49 tag=97 nentries=0 etime=0</code></pre>
<p>The first BIND operation succeeds, but for some reason, one second later, the KDC or <code>ipa-otpd</code> attempts to authenticate again. It would make sense that the same credentials are used, and in that case the second BIND operation would fail (error code 49 means <em>invalid credentials</em>) due to the HOTP counter having been incremented in the database.</p>
<p><code>ipa-otpd</code> does some logging via the systemd journal facility, so it was possible to observe its behaviour via <code>journalctl --follow /usr/libexec/ipa-otpd</code>. The log output for a failed login showed two requests being send by the KDC, thus exonerating <code>ipa-otpd</code>:</p>
<pre><code>Aug 04 02:44:35 ipa-2.ipa.local ipa-otpd[3910]: ftweedal@IPA.LOCAL: request received
Aug 04 02:44:35 ipa-2.ipa.local ipa-otpd[3910]: ftweedal@IPA.LOCAL: user query start
Aug 04 02:44:35 ipa-2.ipa.local ipa-otpd[3910]: ftweedal@IPA.LOCAL: user query end: uid=ftweedal,cn=users,cn=accounts,dc=ipa,dc=local
Aug 04 02:44:35 ipa-2.ipa.local ipa-otpd[3910]: ftweedal@IPA.LOCAL: bind start: uid=ftweedal,cn=users,cn=accounts,dc=ipa,dc=local
Aug 04 02:44:36 ipa-2.ipa.local ipa-otpd[3935]: ftweedal@IPA.LOCAL: request received
Aug 04 02:44:36 ipa-2.ipa.local ipa-otpd[3935]: ftweedal@IPA.LOCAL: user query start
Aug 04 02:44:37 ipa-2.ipa.local ipa-otpd[3935]: ftweedal@IPA.LOCAL: user query end: uid=ftweedal,cn=users,cn=accounts,dc=ipa,dc=local
Aug 04 02:44:37 ipa-2.ipa.local ipa-otpd[3935]: ftweedal@IPA.LOCAL: bind start: uid=ftweedal,cn=users,cn=accounts,dc=ipa,dc=local
Aug 04 02:44:37 ipa-2.ipa.local ipa-otpd[3910]: ftweedal@IPA.LOCAL: bind end: success
Aug 04 02:44:37 ipa-2.ipa.local ipa-otpd[3910]: ftweedal@IPA.LOCAL: response sent: Access-Accept
Aug 04 02:44:38 ipa-2.ipa.local ipa-otpd[3935]: ftweedal@IPA.LOCAL: bind end: Invalid credentials
Aug 04 02:44:38 ipa-2.ipa.local ipa-otpd[3935]: ftweedal@IPA.LOCAL: response sent: Access-Reject</code></pre>
<p>The KDC log output likewise showed two <code>KRB_AS_REQ</code> requests coming from the client (i.e. <code>kinit</code>) - one of these resulted in a ticket being issued, and the other resulted in a <code>KDC_ERR_PREAUTH_FAILED</code> response. Therefore, after all this investigation, the cause of the problem seems to be aggressive retry behaviour in <code>kinit</code>.</p>
<p>I had been testing with MIT Kerberos version 1.11.5 from the Fedora 20 repositories. A quick scan of the Kerberos commit log turned up some promising changes released in version 1.12. Since the Fedora package for 1.11 includes a number of backports from 1.12 already, I backported the most promising change: one that relaxes the timeout if <code>kinit</code> connects to the KDC over TCP. Unfortunately, this did not fix the issue.</p>
<p>I was curious whether version the 1.12 client exhibited the same behaviour. The Fedora 21 repositories have MIT Kerberos version 1.12, so I installed a preview release and enrolled the host. OTP authentication worked fine, so the change I backported to 1.11 was either the wrong change, or needed other changes to work properly.</p>
<p>Since HOTP authentication in FreeIPA is somewhat discouraged due to the cost and other implications of counter synchronisation in a replicated environment, and since the problem seems to be rectified in MIT Kerberos 1.12, I was happy to conclude my investigations at this point.</p>
<h2 id="concluding-thoughts">Concluding thoughts</h2>
<p>OTP authentication in FreeIPA involves a lot of different servers, plugins and libraries. To provide the OTP functionality and make all the services work together, <code>freeipa-server</code> ships a KDC plugin, a directory server plugin, <em>and</em> the <code>ipa-otpd</code> daemon! Was it necessary to have this many moving parts?</p>
<p>The original <a href="http://www.freeipa.org/page/V4/OTP">design proposal</a> explains many of the design decisions. In particular, <code>ipa-otpd</code> is necessary for a couple of reasons. The first is the fact that the MIT KDC supports only RADIUS servers for OTP validation, so for native OTP support we must have some component act as a RADIUS server. Second, the KDC radius configuration is static, so configuration is simplified by having the KDC talk only to <code>ipa-otpd</code> for OTP validation. It is also nice that <code>ipa-otpd</code> is the sole arbiter of whether to proxy a request to an external RADIUS server or to attempt an LDAP BIND.</p>
<p>What if the KDC could dynamically work out where to direct RADIUS packets for OTP validation? It is not hard to conceieve of this, since it already dynamically learns whether a principal is configured for OTP by way of the <code>ipadb.so</code> plugin. But even if this were possible, the current design is arguably preferable since, unlike the KDC, we have full control over the implementation of <code>ipa-otpd</code> and are therefore better placed to respond to performance or security concerns in this aspect of the OTP authentication flow.</p>
</div>
<div id="postFooter">
    <div id="recent">
Recent posts:
<ul>
    
        <li>
            <a href="../posts/2020-10-20-ipa-cert-long-hostname.html">Issuing certificates for long hostnames</a>
        </li>
    
        <li>
            <a href="../posts/2020-09-17-dogtag-vlv-corruption.html">Dogtag, number ranges and VLV indices</a>
        </li>
    
        <li>
            <a href="../posts/2020-08-13-openshift-storage-classes.html">Dynamic volume provisioning with OpenShift storage classes</a>
        </li>
    
        <li>
            <a href="../posts/2020-06-19-dogtag-lightweight-ca-crl.html">CRLs for Dogtag Lightweight CAs</a>
        </li>
    
        <li>
            <a href="../posts/2020-05-13-ipa-acme-dns.html">ACME DNS challenges and FreeIPA</a>
        </li>
    
</ul>

<div id="recentLinks">
    <a type="application/atom+xml" href="../atom.xml">Atom feed</a>
     <!-- em space -->
    <a href="../archive.html">All posts…</a>
</div>

</div>

    <div id="license">
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
        <img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by/4.0/88x31.png">
    </a>
    <br />
    Except where otherwise noted, this work is licensed under a
    <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
        Creative Commons Attribution 4.0 International License
    </a>.
</div>

</div>

        </div>
        <div class="clear"></div>
        <div id="footer">
            Generated by
            <a href="https://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
