<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Fraser's IdM Blog</title>
    <link href="https://frasertweedale.github.io/blog-redhat/atom.xml" rel="self" />
    <link href="https://frasertweedale.github.io/blog-redhat" />
    <id>https://frasertweedale.github.io/blog-redhat/atom.xml</id>
    <author>
        <name>Fraser Tweedale</name>
        <email>frase@frase.id.au</email>
    </author>
    <updated>2019-08-02T00:00:00Z</updated>
    <entry>
    <title>Certificates need not be limited to the CA’s validity period</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-08-02-validity-exceeding-ca.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-08-02-validity-exceeding-ca.html</id>
    <published>2019-08-02T00:00:00Z</published>
    <updated>2019-08-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="certificates-need-not-be-limited-to-the-cas-validity-period">Certificates need not be limited to the CA’s validity period</h1>
<p>All X.509 certificates have a <code>notBefore</code> and <code>notAfter</code> date. These define the <em>validity period</em> of the certificate. When we talk about certificate <em>expiry</em>, we are talking about the <code>notAfter</code> date. The question often arises: can a certificate’s <code>notAfter</code> date exceed the <code>notAfter</code> date of the issuer’s certificate?</p>
<p>The naïve intuition says, <em>surely a certificate’s validity period cannot exceed the CA’s</em>. But let’s think it through, and look at what these fields actually mean. According to <a href="https://tools.ietf.org/html/rfc5280#section-4.1.2.5">RFC 5280 §4.1.2.5</a>:</p>
<pre><code>The certificate validity period is the time interval
during which the CA warrants that it will maintain
information about the status of the certificate.</code></pre>
<p>The whole section makes no mention of the issuer’s <code>notAfter</code> date or validity period. It only says that the CA must maintain status (i.e. revocation) information about the issued certificate until (at least) the <code>notAfter</code> date.</p>
<p>But what if the CA certificate expires before an issued certificate? One of two things happens:</p>
<ol type="1">
<li>The CA certificate got renewed and the verifier has a copy of the new certificate. The certificate being verified is within its validity period and so is the CA certificate, so there is a certificate path and everything is fine.</li>
<li>The CA certificate was not renewed (or the verifier doesn’t have the renewed certificate). The certificate being verified is within its validity period, but the issuer certificate is <em>not</em>. So there is no certificate path; the certificate being verified cannot not be trusted.</li>
</ol>
<p>So it is fine for issued certificate to have expiry dates beyond that of the CA.</p>
<p>In fact, clamping the <code>notAfter</code> of issued certificates to the <code>notAfter</code> of the CA can cause operational challenges. At the same time as the CA needs renewal, so do potentially many issued certificates! You may end up with certificates with short validity periods if the CA certificate is renewed close to its <code>notAfter</code> time, and a flood of renewals to perform at the same time.</p>
<p>There is one situation where it is required to clamp the <code>notAfter</code> of issued certificates to the issuer <code>notAfter</code>. This is when it is known that the issuer, including its CRL and OCSP facilities, will be decommissioned shortly after the expiry of the issuer certificate. Otherwise, in light of the potential operational hazards, I recommend issuing certificates with whatever validity period is appropriate for the application, regardless of when the issuer certificate expires.</p>]]></summary>
</entry>
<entry>
    <title>Dogtag replica range management</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-07-26-dogtag-replica-ranges.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-07-26-dogtag-replica-ranges.html</id>
    <published>2019-07-26T00:00:00Z</published>
    <updated>2019-07-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="dogtag-replica-range-management">Dogtag replica range management</h1>
<p>Dogtag supports distributed deployment, with multiple <em>replicas</em> (also called <em>clones</em>) processing requests and issuing certificates. All replicas read and write a replicated LDAP database. A Dogtag server can create many kinds of objects: certificates, requests, archived keys or secrets. These objects need identifiers that are unique across the deployment.</p>
<p>How does a Dogtag clone choose an identifier for a new object? In this post I will explain Dogtag’s <em>range management</em>—how it works, how it can break, and what to do if it does.</p>
<h2 id="object-types-with-managed-ranges">Object types with managed ranges</h2>
<p>There are several types of objects for which Dogtag manages identifier ranges. For example:</p>
<ul>
<li>Certificate serial numbers; it is essential that these be unique. Collisions are a violation of X.509 and can lead to erroneous <strong>denial of service</strong>, or <strong>false positive</strong> validity, when revocation comes into play.</li>
<li>Certificate requests (including revocation and renewal requests) are stored in the database and must have a unique ID. Clobbering of requests objects due to range conflicts can lead to renewal request failures resulting in <strong>denial of service</strong>, or worse, issuance of a valid certificate with incorrect details, allowing <strong>impersonation</strong> attacks.</li>
<li>KRA request identifiers are assigned from a managed range.</li>
<li>KRA archived key and data objects are assigned from a managed range.</li>
<li>Clones themselves are assigned identifiers when they are created; these come from managed ranges.</li>
</ul>
<p>The identifiers themselves are unbounded nonzero integers. All of the managed ranges are separate domains. That is, the same numbers exist in each range, and the ranges are managed independently.</p>
<h2 id="active-and-standby-ranges">Active and standby ranges</h2>
<p>For each kind of range, each replica remembers up to two range assignments. The <em>active</em> range is the range from which identifiers are actively assigned. When the active range is exhausted, the <em>standby</em> range becomes the active range and the clone acquires a new range assignment, which will be the new standby range. A clone doesn’t necessarily have a standby range at all times. It only acquires a new allocation for the standby range when the unused amount of its active range falls below some configured <em>low water mark</em>.</p>
<h2 id="range-assignments">Range assignments</h2>
<p>Range assignments are recorded in LDAP. A clone’s active and standby ranges are also recorded in the clone’s <code>CS.cfg</code> configuration file. A range object looks like:</p>
<pre><code>dn: cn=10000001,ou=certificateRepository,ou=ranges,o=ipaca
objectClass: top
objectClass: pkiRange
beginRange: 10000001
endRange: 20000000
cn: 10000001
host: f30-1.ipa.local
SecurePort: 443</code></pre>
<p>This is a serial number range assignment. Host <code>f30-1.ipa.local</code> has been assigned the range <code>10000001..20000000</code>. It is not apparent from this object, but these are actually <strong>hexadecimal</strong> numbers! Whether the numbers are decimal or hexadecimal varies among managed ranges.</p>
<p>The directives in the <code>CS.cfg</code> on <code>f30-1.ipa.local</code> reflect this assignment:</p>
<pre><code>dbs.enableSerialManagement=true

dbs.beginSerialNumber=fff0001
dbs.endSerialNumber=10000000

dbs.nextBeginSerialNumber=10000001
dbs.nextEndSerialNumber=20000000

dbs.enableRandomSerialNumbers=false
dbs.randomSerialNumberCounter=-1

dbs.serialCloneTransferNumber=10000
dbs.serialIncrement=10000000
dbs.serialLowWaterMark=2000000</code></pre>
<p>The active range is <code>fff0001..10000000</code>, and the standby range is <code>10000001..20000000</code>, which corresponds to the LDAP entry shown above.</p>
<h3 id="range-delegation">Range delegation</h3>
<p>Why is <code>f30-1</code>’s active range so much smaller than its standby range? This is the result of how ranges are assigned during cloning. When creating a clone, the server being configured contacts an existing clone and asks it for some configuration values, including serial/request/replica ID ranges. The existing clone <em>delegates</em> to the new clone a small segment of either its active or standby range. It delegates <em>from the end</em> of its active range, but if there are not enough numbers left in the active range, it delegates from the end the standby range instead.</p>
<p>The size of the range delegation is configured in <code>CS.cfg</code>. For example, for serial numbers it is the <code>dbs.serialCloneTransferNumber</code> setting. I have never heard of anyone changing the default, and I can’t think of a reason to do so.</p>
<p>Because the delegation is a portion of an already-assigned range (with corresponding LDAP object), new LDAP range objects are not created for delegated ranges, and the existing range object is not modified in any way. Therefore, LDAP only ever shows the <em>original</em> range assignments.</p>
<p>This range delegation procedure has been a source of bugs. For example, <a href="https://pagure.io/dogtagpki/issue/3055">issue 3055</a> was a cloning failure when creating two clones (call them <em>C</em> and <em>D</em>) from a server that is itself a clone (call it <em>B</em>). Because the delegation size is fixed (the <code>dbs.serialCloneTransferNumber</code> setting), creating <em>C</em> delegates <em>B</em>’s whole active range to <em>C</em>. Unless <em>B</em> had a chance to switch to its standby range (when didn’t happen during cloning), creating the second clone <em>D</em> would fail because <em>B</em>’s active range was exhausted. This issue was fixed, but a more robust solution is to do away with range delegation entirely; the server can create full range assignments for the new clone instead of delegating part of its own range assignment. <a href="https://pagure.io/dogtagpki/issue/3060">Issue 3060</a> tracks this work.</p>
<h2 id="random-serial-numbers">Random serial numbers</h2>
<p>Most repositories with range management yield numbers sequentially from the active ranges. For the certificate repository only, you can optionally enable <em>random</em> serial numbers. Numbers are chosen by a uniform random sample from the clone’s assigned range. Dogtag checks to make sure the number was not already used; if it was used, it tries again (and again, up to a limit).</p>
<p>Some additional configuration values come into play when using random serial numbers:</p>
<dl>
<dt><code>dbs.enableRandomSerialNumbers</code></dt>
<dd><p>Enable random serial numbers (default: off)</p>
</dd>
<dt><code>dbs.collisionRecoverySteps</code></dt>
<dd><p>How many retries when a collision is detected (default: 10)</p>
</dd>
<dt><code>dbs.minimumRandomBits</code></dt>
<dd><p>Minimum size of the range, in bits (default: 4 bits)</p>
</dd>
<dt><code>dbs.serialLowWaterMark</code></dt>
<dd><p>Switch to standby range when there are fewer than this many serials left in the range (default: 2000000)</p>
</dd>
</dl>
<p>Critically, The <code>dbs.minimumRandomBits</code> does <em>not</em> determine how much entry is in the serial number. If many serial numbers in the range have already been used, the actual number of serials left could be less than <code>dbs.minimumRandomBits</code> of entropy. When issuing random serial numbers, the server keeps a running count of how many serial numbers have been used in the active range. When the range size minus the current count falls below <code>dbs.serialLowWaterMark</code>, the server switches to the standby range. Therefore it is <code>dbs.serialLowWaterMark</code>, not <code>dbs.minimumRandomBits</code>, that actually controls the minimum amount of randomness in the serial number.</p>
<h2 id="switching-to-the-standby-range">Switching to the standby range</h2>
<p>The actions performed by the subroutine that switches to the next range are:</p>
<dl>
<dt>1. Set the active range start and end variables to the standby range</dt>
<dd><p>start and end</p>
</dd>
</dl>
<ol>
<li>Reset the standby range start and end variables to <code>null</code></li>
<li>Reset counters</li>
<li>Persist these changes to <code>CS.cfg</code>.</li>
</ol>
<p>The switchover procedure <strong>does not acquire a new standby range assignment</strong>. Immediately after switching to the standby range, there isn’t a standby range anymore.</p>
<h2 id="acquiring-a-new-range-assignment">Acquiring a new range assignment</h2>
<p>As currently implemented, a new standby range is <strong>only acquired at system startup</strong>. Dogtag checks each repository to see if the amount of unused numbers in the active range has fallen below the <em>low water mark</em>. If it has, and if there is no standby range, it self-allocates a new range assignment in LDAP. The size of the allocation is determined by <code>CS.cfg</code> configurables, and its lower bound is the value of the <code>nextRange</code> attribute in the repository parent LDAP object. It adds a range object to the ranges subtree, and updates the <code>nextRange</code> attribute on the repository parent. See the appendix for a list of which subtree parents and range entries are involved for each repository.</p>
<p>This procedure is brittle under the possibliity of LDAP replication races or transient failures. Two clones could end up adding the same range, and a replication error will occur. This can lead to identifier collisions resulting in problems later (see earlier discussion).</p>
<h2 id="internals">Internals</h2>
<p>Most of everything discussed so far lives in the <code>Repository</code> class, with <code>CertificateRepository</code> providing additional behaviour related to random serial numbers. Code for acquiring a new range assignment lives in <code>DBSubsystem</code>. Some methods of interest include:</p>
<dl>
<dt><code>Repository.getNextSerialNumber</code></dt>
<dd><p>Get the next number; calls <code>checkRange</code> before returning it</p>
</dd>
<dt><code>Repository.checkRange</code></dt>
<dd><p>Check if the range is exhausted; if so call <code>switchToNextRange</code></p>
</dd>
<dt><code>Repository.switchToNextRange</code></dt>
<dd><p>Switches to next range (see discussion in earlier section)</p>
</dd>
<dt><code>Repository.checkRanges</code></dt>
<dd><p>Sanity checks the active and standby ranges; acquires new range allocation if necessary (by calling <code>DBSubsystem.getNextRange</code>) and persists the changes to <code>CS.cfg</code>.</p>
</dd>
<dt><code>DBSubsystem.getNextRange</code></dt>
<dd><p>This method creates the LDAP range object and updates the <code>nextRange</code> attribute, returning the range bounds to the caller.</p>
</dd>
</dl>
<h2 id="fixing-range-conflicts">Fixing range conflicts</h2>
<p>If you have range conflicts, the following high-level steps can be followed to fix them:</p>
<ol type="1">
<li>Stop all Dogtag servers.</li>
<li>Resolve any replication issues or conflict entries.</li>
<li>Examine active and standby ranges in <code>CS.cfg</code> on all replicas.</li>
<li>If there are any conflicts (including between active and standby ranges), choose new ranges such that there are no conflicts. Update <code>CS.cfg</code> of each replica with its new ranges.</li>
<li>Update the <code>nextRange</code> attribute for each repository object to a number <em>greater than</em> the highest number of any allocated range (<em>max + 1</em> is fine). See appendix for the objects involved.</li>
<li><em>(Optional)</em> Update and add new range entries. This is not essential because nothing will break if the ranges entries don’t actually correspond to what’s in each replica’s <code>CS.cfg</code>. But is is still desirable that the LDAP entries reflect the configuration of each server.</li>
<li>Start Dogtag servers. If some servers do not have a standby range, it is a good idea to stagger their startup. Otherwise there is a high risk of an immediate replication race causing range conflicts as servers acquire new range assignments.</li>
</ol>
<p>Note that this procedure will <em>not</em> save your skin if, e.g., multiple certificates with the same serial number were issued. Renewal problems may be unavoidable when collisions have occurred. This is the main reason we are switching to <a href="https://pagure.io/freeipa/issue/7991">profile-based renewal</a> for FreeIPA system certificates. Renewal requests refer to existing certificate and requests by serial / request ID. Thus if there have been range conflicts they are susceptible to failure or issuance of certificates with incorrect attributes. Performing a “fresh enrolment” when renewing system certificates avoids these problems because the profile enrolment request does not refer to any existing certificates or requests.</p>
<h2 id="discussion">Discussion</h2>
<p>Dogtag is over 20 years old, and I suppose that sequential numbers with range management made sense at the time. Maybe a multi-server deployment with a replicated database was not foreseen, and range management was bolted on later when the requirement emerged. Maybe using random identifiers was seen as difficult to get write; UUIDs were not widespread back then. Or maybe using random numbers was seen as not user-friendly (and that is true, but when you have more than one replica the ranged identifiers aren’t much better).</p>
<p>On the fact of some ranges using base 16 (hexademical) and others using base 10: I cannot even imagine why this is so. Extra user and operator pain, for what gain? I cannot tell. The reasons are probably, like so many things in old programs, lost in time.</p>
<p>The random serial number configuration and behaviour is… not state of the art. The program logic is difficult to follow and it is not clear which configuration directives govern the (minimum) amount of entropy in the chosen numbers.</p>
<p>If I were designing a system like Dogtag today, I would use random UUIDs for everything, except possibly serial numbers. There are <a href="https://en.wikipedia.org/wiki/UUID#Version_4_(random)">122 bits of entropy</a> in a Version 4 UUID. The current CA/Browser Forum <a href="https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.6.5.pdf">Baseline Requirements</a> (v1.6.5) require serial numbers with 64 bits of high-quality randomness, but if that is ever increased beyond 122 bits a UUID won’t cut it anymore. So I would just use very large random numbers for all serial numbers.</p>
<p>Can we move Dogtag from what we have now to something more robust? Of course it is possible, but it would be a big effort. So all that is likely to happen is smaller, well understood and bounded efforts with an obvious payoff, like avoiding range delegation (<a href="https://pagure.io/dogtagpki/issue/3060">Issue 3060</a>).</p>
<p>The new FreeIPA <a href="https://www.freeipa.org/page/V4/Healthcheck">Health Check</a> system provides pluggable checks for system health. There is an open ticket to implement Dogtag range conflict and sanity checking in the Health Check tool, so that problems can be detected before they cause major failures.</p>
<h2 id="appendix-range-configuration-directives-and-objects">Appendix: range configuration directives and objects</h2>
<p>In all LDAP DNs below, substitute <code>o=ipaca</code> with the relevant base DN.</p>
<h3 id="certificate-serial-numbers">Certificate serial numbers</h3>
<p>Base: <strong>hexademical</strong></p>
<p><code>CS.cfg</code> attributes:</p>
<pre><code>dbs.beginSerialNumber
dbs.endSerialNumber
dbs.nextBeginSerialNumber
dbs.nextEndSerialNumber
dbs.serialIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=certificateRepository,ou=ca,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=certificateRepository,ou=ranges,o=ipaca</code></pre>
<h3 id="ca-requests">CA requests</h3>
<p>Base: <strong>demical</strong></p>
<p><code>CS.cfg</code> attributes:</p>
<pre><code>dbs.beginRequestNumber
dbs.endRequestNumber
dbs.nextBeginRequestNumber
dbs.nextEndRequestNumber
dbs.requestIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=ca,ou=requests,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=requests,ou=ranges,o=ipaca</code></pre>
<h3 id="replica-numbers">Replica numbers</h3>
<p>Base: <strong>demical</strong></p>
<p><code>CS.cfg</code> attributes:</p>
<pre><code>dbs.beginReplicaNumber
dbs.endReplicaNumber
dbs.nextBeginReplicaNumber
dbs.nextEndReplicaNumber
dbs.replicaIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=replica,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=replica,ou=ranges,o=ipaca</code></pre>
<h3 id="kra-keys">KRA keys</h3>
<p>Base: <strong>hexademical</strong></p>
<p><code>kra/CS.cfg</code> attributes:</p>
<pre><code>dbs.beginSerialNumber
dbs.endSerialNumber
dbs.nextBeginSerialNumber
dbs.nextEndSerialNumber
dbs.serialIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=keyRepository,ou=kra,o=kra,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=keyRepository,ou=ranges,o=kra,o=ipaca</code></pre>
<h3 id="kra-requests">KRA requests</h3>
<p>Base: <strong>demical</strong></p>
<p><code>kra/CS.cfg</code> attributes:</p>
<pre><code>dbs.beginRequestNumber
dbs.endRequestNumber
dbs.nextBeginRequestNumber
dbs.nextEndRequestNumber
dbs.requestIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=kra,ou=requests,o=kra,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=requests,ou=ranges,o=kra,o=ipaca</code></pre>
<h3 id="kra-replicas-numbers">KRA replicas numbers</h3>
<p>Base: <strong>demical</strong></p>
<p><code>CS.cfg</code> attributes:</p>
<pre><code>dbs.beginReplicaNumber
dbs.endReplicaNumber
dbs.nextBeginReplicaNumber
dbs.nextEndReplicaNumber
dbs.replicaIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=replica,o=kra,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=replica,ou=ranges,o=kra,o=ipaca</code></pre>]]></summary>
</entry>
<entry>
    <title>Designing revocation self-service for FreeIPA</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-07-19-revocation-self-service.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-07-19-revocation-self-service.html</id>
    <published>2019-07-19T00:00:00Z</published>
    <updated>2019-07-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="designing-revocation-self-service-for-freeipa">Designing revocation self-service for FreeIPA</h1>
<p>The FreeIPA team recently received a <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1730363">feature request</a> for self-service certificate revocation. At the moment, revocation must be performed by a privileged user with the <code>Revoke Certificate</code> permission. The one exception to this is that a host principal can revoke certificates for the same hostname. There are no expections when it comes to user certificates.</p>
<p>In this post I’ll discuss revocation self-service and how it might work in FreeIPA.</p>
<h2 id="requirements-and-approaches-for-self-service">Requirements and approaches for self-service</h2>
<p>It is critical to avoid scenarios where a user could revoke a certificate they should not be able to revoke; this would constitute a Denial-of-Service (DoS) vulnerability. Therefore FreeIPA must establish that the principal issuing the revocation request has authority to revoke the nominated certificate. Conceptually, there are several ways we might establish that authority. Each scenario has trade-offs, either fundamental to the scenario or specific to FreeIPA.</p>
<h3 id="proof-of-possession">Proof of possession</h3>
<p>Proof of possession (PoP) establishes a cryptographic proof that the operator possess the private key for the certificate to be revoked. Either they are rightful subject of the certificate, in which case it is reasonable to service their revocation request. Or they have compromised the subject’s key, in which case it is reasonable to revoke it anyway.</p>
<p>A PoP-based revocation system must defeat replay attacks. Using a nonce would complicate the client-server interaction—the client would first have to request the nonce, and the server would have to remember it. Instead of a nonce, it would be sufficient for the client to sign a timestamped statement of intent to revoke.</p>
<p>The main issue with PoP-based revocation is that the user interface must consider how to access the key. The UI must learn options related to key or certificate database paths, passphrases, and so on. This is a significant burden for users.</p>
<p>Finally, there is an important use case this scenario does not handle: when the user no longer has control of their private key (they deleted it, forgot the passphrase, etc.)</p>
<h3 id="certificate-inspection">Certificate inspection</h3>
<p>The revocation command could inspect the certificate and decide if it “belongs to” the requestor. This must be done with extreme care, because a false-positive is equivalent to a DoS vulnerability. For example, merely checking that the UID or CN attribute in the certificate Subject DN corresponds to the requestor is inadequate.</p>
<p>It is hard to attain 100% certainty, especially considering administrators can create custom certificate profiles. But there are some options that seem safe enough to implement. It should be reasonable to authorise the revocation if:</p>
<ul>
<li><p>The Subject Alternative Name (SAN) extension contains a <code>KRB5PrincipalName</code> or <code>UPN</code> value equal to the authenticated principal. FreeIPA supports such certificates out of the box, contingent on the CSR including these data.</p></li>
<li><p>The SAN contains a <code>rfc822Name</code> (email address) equal to one of the user’s email addresses. Again, FreeIPA supports this with the same CSR caveat.</p></li>
<li><p>The SAN contains a <code>directoryName</code> (DN) equal to the user’s full DN in the FreeIPA LDAP directory. Supported, with CSR caveat.</p></li>
<li><p>The certificate Subject DN is equal to the user’s full DN in the FreeIPA LDAP directory. Supported with a custom profile having <code>subjectNameDefaultImpl</code> configuration like (wrapped for display):</p>
<pre><code>policyset.serverCertSet.1.default.params.name=
  UID=$request.req_subject_name.cn$,
  CN=users,CN=accounts,DC=example,DC=com</code></pre></li>
</ul>
<p>The CSR caveat presents a burden to users: they must lovingly handcraft their CSR to include the relevant data. To say the tools have poor usability in this area is an understatement. But the SAN options are supported out of the box by the default user certificate profile <code>IECUserRoles</code> (don’t ask about the name).</p>
<p>On the other hand, the Subject DN approach requires a custom profile but nothing special needs to go in the CSR. A Subject DN of <code>CN=username</code> will suffice.</p>
<h3 id="audit-based-approach">Audit-based approach</h3>
<p>When issuing a certificate via <code>ipa cert-request</code>, there are two principals at play: the <em>operator</em> who is performing the request, and the <em>subject</em> principal who the certificate is for. (These could be the same principal). Subject to organisational security policy, it may be reasonable to revoke a certificate if <em>either</em> of these principals requests it.</p>
<p>Unfortunately, in FreeIPA today we do not record these data in a way that is useful to make a revocation authorisation decision. In the future, when FreeIPA authenticates to Dogtag using GSS-API and a Kerberos proxy credential for the operator (instead of the IPA RA agent credential we use today), we will be able to store the needed data. Then it may be feasible to implement this approach. Until then, forget about it.</p>
<h2 id="the-way-forward">The way forward</h2>
<p>So, which way will we go? Nothing is decided yet (including <em>whether to implement this at all</em>). If we go ahead, I would like to implement the <em>certificate inspection</em> approach. Proof of possession is tractable, but a lot of extra complexity and probably a usability nightmare for users. The audit-based approach is infeasible at this time, though it is a solid option if/when the right pieces are in place. Certificate inspection carries a risk of DoS exposure through revocation of inappropriate certificates, but if we carefully choose which data to inspect and match, the risk is minimised while achieving satisfactory usability.</p>]]></summary>
</entry>
<entry>
    <title>A Distinguished Name is not a string</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-05-28-a-dn-is-not-a-string.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-05-28-a-dn-is-not-a-string.html</id>
    <published>2019-05-28T00:00:00Z</published>
    <updated>2019-05-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="a-distinguished-name-is-not-a-string">A Distinguished Name is not a string</h1>
<p><em>Distinguished Names (DNs)</em> are used to identify entities in LDAP databases and X.509 certificates. Although DNs are often presented as strings, they have a complex structure. Because of the numerous formal and ad-hoc serialisations have been devised, and the prevalence of ad-hoc or buggy parsers, treating DNs as string in the interals of a program inevitably leads to errors. In fact, dangerous security issues can arise!</p>
<p>In this post I will explain the structure of DNs, review the common serialisation regimes, and review some DN-related bugs in projects I worked on. I’ll conclude with my <em>best practices</em> recommendations for working with DNs.</p>
<h2 id="dn-structure">DN structure</h2>
<p>DNs are defined by the ITU-T <strong>X.501</strong> standard a ASN.1 objects:</p>
<pre><code>Name ::= CHOICE {
  -- only one possibility for now --
  rdnSequence RDNSequence }

RDNSequence ::= SEQUENCE OF RelativeDistinguishedName

DistinguishedName ::= RDNSequence

RelativeDistinguishedName ::=
  SET SIZE (1..MAX) OF AttributeTypeAndValue

AttributeTypeAndValue ::= SEQUENCE {
  type  ATTRIBUTE.&amp;id({SupportedAttributes}),
  value ATTRIBUTE.&amp;Type({SupportedAttributes}{@type}),
  ... }</code></pre>
<p>The <code>AttributeTypeAndValue</code> definition refers to some other definitions. It means that <code>type</code> is an <em>object identifier (OID)</em> of some supported attribute, and the syntax of <code>value</code> is determined by <code>type</code>. The term <em>attribute-value assertion (AVA)</em> is a common synonym for <code>AttributeTypeAndValue</code>.</p>
<p>Applications define a bounded set of supported attributes. For example the X.509 certificate standard suggests a minimal set of supported attributes, and an LDAP server’s schema defines all the attribute types understood by that server. Depending on the application, a program might fail to process a DN with an unrecognised attribute type, or it might process it just fine, treating the corresponding value as opaque data.</p>
<p>Whereas the order of AVAs within an RDN is insignificant (it is a <code>SET</code>), the order of RDNs within the DN is significant. If you view the list left-to-right, then the <em>root</em> is on the left. X.501 formalises it thus:</p>
<blockquote>
<p>Each initial sub-sequence of the name of an object is also the name of an object. The sequence of objects so identified, starting with the root and ending with the object being named, is such that each is the immediate superior of that which follows it in the sequence.</p>
</blockquote>
<p>This also means that the empty DN is a valid DN.</p>
<h2 id="comparing-dns">Comparing DNs</h2>
<p>Testing DNs for equality is an important operation. For example, when constructing an X.509 certification path, we have to find a trusted CA certificate based on the certificate chain presented by an entity (e.g. a TLS server), then verify that the chain is complete by ensuring that each <em>Issuer DN</em>, starting from the end entity certificate, matches the <em>Subject DN</em> of the certificate “above” it, all the way up to a trusted CA certificate. (Then the signatures must be verified, and several more checks performed).</p>
<p>Continuing with this example, if an implementation falsely determines that two equal DNs (under X.500) are inequal, then it will fail to construct the certification path and reject the certificate. This is not good. But even worse would be if it decides that two unequal DNs are in fact equal! Similarly, if you are issuing certificates or creating LDAP objects or anything else, a user could exploit bugs in your DN handling code to cause you to issue certificates, or create objects, that you did not intend.</p>
<p>Having motivated the importance of correct DN comparison, well, how <em>do</em> you compare DNs correctly?</p>
<p>First, the program must represent the DNs according to their true structure: a list of sets (<em>RDNs</em>) of attribute-value pairs (<em>AVAs</em>). If the DNs are not already represented this way in the program, they must be parsed or processed—correctly.</p>
<p>Now that the structure is correct, AVAs can be compared for equality. Each attribute type defines an <em>equality matching rule</em> that says how values should be compared. In some cases this is just binary matching. In other cases, normalisation or other rules must be applied to the values. For example, some string types may be case insensitive.</p>
<p>A notable case is the <code>DirectoryString</code> syntax used by several attribute types in X.509:</p>
<pre><code>DirectoryString ::= CHOICE {
    teletexString       TeletexString   (SIZE (1..MAX)),
    printableString     PrintableString (SIZE (1..MAX)),
    universalString     UniversalString (SIZE (1..MAX)),
    utf8String          UTF8String      (SIZE (1..MAX)),
    bmpString           BMPString       (SIZE (1..MAX)) }</code></pre>
<p><code>DirectoryString</code> supports a choice of string encodings. Values of use <code>PrintableString</code> orr <code>UTF8String</code> encoding must be preprocessed using the LDAP <em>Internationalized String Preparation</em> rules (<a href="https://tools.ietf.org/html/rfc4518">RFC 4518</a>), including case folding and insignificant whitespace compression.</p>
<p>Taking the DN as a whole, two DNs are equal if they have the same RDNs in the same order, and two RDNs are equal if they have the same AVAs in <em>any</em> order (i.e. sets of equal size, with each AVA in one set having a matching AVA in the other set).</p>
<p>Ultimately this means that, despite X.509 certificates using <em>Distinguised Encoding Rules (DER)</em> for serialisation, there can still be multiple ways to represent equivalent data (by using different string encodings). Therefore, binary matching of serialised DNs, or even binary matching of individual attribute values, is incorrect behaviour and may lead to failures.</p>
<h2 id="string-representations">String representations</h2>
<p>Several string representations of DNs, both formally-specified and ad-hoc, are in widespread use. In this section I’ll list some of the more important ones.</p>
<p>Because DNs are ordered, one of the most obvious characteristics of a string representation is whether it lists the RDNs in <em>forward</em> or <em>reverse</em> order, i.e. with the root at the left or right. Some popular libraries and programs differ in this regard.</p>
<p>As we look at some of these common implementations, we’ll use the following DN as an example:</p>
<pre><code>SEQUENCE (3 elem)
  SET (2 elem)
    SEQUENCE (2 elem)
      OBJECT IDENTIFIER 2.5.4.6 countryName
      PrintableString AU
    SEQUENCE (2 elem)
      OBJECT IDENTIFIER 2.5.4.8 stateOrProvinceName
      PrintableString Queensland
  SET (1 elem)
    SEQUENCE (2 elem)
      OBJECT IDENTIFIER 2.5.4.10 organizationName
      PrintableString Acme, Inc.
  SET (1 elem)
    SEQUENCE (2 elem)
      OBJECT IDENTIFIER 2.5.4.3 commonName
      PrintableString CA</code></pre>
<h3 id="rfc-4514">RFC 4514</h3>
<pre><code>CN=CA,O=Acme\, Inc.,C=AU+ST=Queensland
CN=CA,O=Acme\2C Inc.,C=AU+ST=Queensland</code></pre>
<p><a href="https://tools.ietf.org/html/rfc4514">RFC 4514</a> defines the string representation of distinguished names used in LDAP. As such, there is widespread library support for parsing and printing DNs in this format. The RDNs are in reverse order, separated by <code>,</code>. Special characters are escaped using backslash (<code>\</code>), and can be represented using the escaped character itself (e.g. <code>\,</code>) or two hex nibbles (<code>\2C</code>). The AVAs within a multi-valued RDN are separated by <code>+</code>, in any order.</p>
<p>Due to the multiple ways of escaping special characters, this is not a distinguished encoding.</p>
<p>This format is used by GnuTLS, OpenLDAP and FreeIPA, among other projects.</p>
<h3 id="rfc-1485">RFC 1485</h3>
<pre><code>CN=CA,O=&quot;Acme, Inc.&quot;,C=AU+ST=Queensland</code></pre>
<p><a href="https://tools.ietf.org/html/rfc1485">RFC 1485</a> is a predecessor of a predecessor (RFC 1779) of a predecessor (RFC 2253) of RFC 4514. There are some differences from RFC 4514. For example, special character escapes are not supported; quotes must be used. This format is still relevant today because NSS uses it for pretty-printing and parsing DNs.</p>
<h3 id="openssl">OpenSSL</h3>
<p>OpenSSL prints DNs in its own special way. Unlike most other implementations, it works with DNs in <em>forward</em> order (root at left). The pretty-print looks like:</p>
<pre><code>C = AU + ST = Queensland, O = &quot;Acme, Inc.&quot;, CN = CA</code></pre>
<p>The format when parsing is different again. Some commands need a flag to enable support for multi-valued RDNs; e.g. <code>openssl req -multivalue-rdn ...</code>.</p>
<pre><code>/C=AU+ST=Queensland/O=Acme, Inc./CN=CA</code></pre>
<p>OpenSSL can also read DNs from a config file where AVAs are given line by line (see <code>config</code> and <code>x509v3_config(5)</code>). But this is not a DN string representation <em>per se</em> so I won’t cover it here.</p>
<h2 id="bugs-bugs-bugs">Bugs, bugs, bugs</h2>
<p>Here are three interesting bugs I discovered, related to DN string encoding.</p>
<h3 id="ds-49543-certmap-fails-when-issuer-dn-has-comma-in-name">389 DS <a href="https://pagure.io/389-ds-base/issue/49543">#49543</a>: certmap fails when Issuer DN has comma in name</h3>
<p>389 DS supports TLS certificate authentication for binding to LDAP. Different certificate mapping (<em>certmap</em>) policies can be defined for different CAs. The issuer DN in the client certificate is used to look up a certmap configuration. Unfortunately, a string comparison was used to perform this lookup. 389 uses NSS, which serialised the DN using RFC 1485 syntax. If this disagreed with how the DN in the certmap configuration appeared (after normalisation), the lookup—hence the LDAP bind—would fail. The normalisation function was also buggy.</p>
<p>The <a href="https://pagure.io/389-ds-base/pull-request/49611#request_diff">fix</a> was to parse the certmap DN string into an a NSS <code>CertNAME</code> using the <code>CERT_AsciiToName</code> routine, then compare the Issuer DN from the certificate against it using the NSS DN comparison routine (<code>CERT_CompareName</code>). The buggy normalisation routine was deleted.</p>
<h3 id="certmonger-90-incorrect-dn-in-csr">Certmonger <a href="https://pagure.io/certmonger/issue/90">#90</a>: incorrect DN in CSR</h3>
<p>Certmonger stores tracking request configuration in a flat text file. This configuration includes the string representation of the DN, ostensibly in RFC 4514 syntax. When constructing a CSR for the tracking request, it parsed the DN then used the result to construct an OpenSSL <code>X509_NAME</code>, which would be used in OpenSSL routines to create the CSR.</p>
<p>Unfortunately, the DN parsing implementation—a custom routine in Certmonger itself—was busted. A DN string like:</p>
<pre><code>CN=IPA RA,O=Acme\, Inc.,ST=Massachusetts,C=US</code></pre>
<p>Resulted in a CSR with the following DN:</p>
<pre><code>CN=IPA RA,CN=Inc.,O=Acme\\,ST=Massachusetts,C=US</code></pre>
<p>The <a href="https://pagure.io/certmonger/pull-request/108#request_diff">fix</a> was to remove the buggy parser and use the OpenLDAP <code>ldap_str2dn</code> routine instead. This was a joint effort between Rob Crittenden and myself.</p>
<h3 id="freeipa-7750-invalid-modlist-when-attribute-encoding-can-vary">FreeIPA <a href="https://pagure.io/freeipa/issue/7750">#7750</a>: invalid modlist when attribute encoding can vary</h3>
<p>FreeIPA’s LDAP library, <em>ipaldap</em>, uses <em>python-ldap</em> for handling low-level stuff and provides a lot of useful stuff on top. One useful thing it does is keeps track of the original attribute values for an object, so that we can perform changes locally and efficiently produce a list of modifications (<em>modlist</em>) for when we want to update the object at the server.</p>
<p><em>ipaldap</em> did not take into account the possibility of the attribute encoding returned by <em>python-ldap</em> differing from the attribute encoding produced by FreeIPA. A disagreement could arise when DN attribute values contained special characters requiring escaping. For example, <em>python-ldap</em> escaped characters using hex encoding:</p>
<pre><code>CN=CA,O=Red Hat\2C Inc.,L=Brisbane,C=AU</code></pre>
<p>The representation produced by <em>python-ldap</em> is recorded as the original value of the attribute. However, if you wrote the same attribute value back, it would pass through FreeIPA’s encoding routine, which might encode it differently and record it as a new value:</p>
<pre><code>CN=CA,O=Red Hat\, Inc.,L=Brisbane,C=AU</code></pre>
<p>When you go to update the object, the modlist would look like:</p>
<pre><code>[ (ldap.MOD_ADD, &#39;ipacaissuerdn&#39;,
    [b&#39;CN=CA,O=Red Hat\, Inc.,L=Brisbane,C=AU&#39;])
, (ldap.MOD_DELETE, &#39;ipacaissuerdn&#39;,
    [b&#39;CN=CA,O=Red Hat\2C Inc.,L=Brisbane,C=AU&#39;])
]</code></pre>
<p>Though encoded differently, <em>these are the same value</em> but that in itself is not a problem. The problem is that the server also has the same value, and processing the <code>MOD_ADD</code> first results in an <code>attributeOrValueExists</code> error. You can’t add a value that’s already there!</p>
<p>The ideal fix for this would be to update <em>ipaldap</em> to record all values as ASN.1 data or DER, rather than strings. But that would be a large and risky change. Instead, we <a href="https://github.com/freeipa/freeipa/pull/2511">work around</a> the issue by always putting deletes before adds in the modlist. LDAP servers process changes in the order they are presented (389 DS does so atomically). So deleting an attribute value then adding it straight back is a safe, albeit inefficient, workaround.</p>
<h2 id="discussion">Discussion</h2>
<p>So you have to compare or handle some DNs. What do you do? My recommendations are:</p>
<ul>
<li>If you need to print/parse DNs as strings, if possible use RFC 4514 because it has the most widespread library support.</li>
<li>Don’t write your own DN parsing code. This is where security vulnerabilities are most likely. Use existing library routines for parsing DNs. If you have no other choice, take extreme care and if possible use a parser combinator library or parser generator to make the definitions more declarative and reduce likelihood of error.</li>
<li>Always decode attribute values (if the DN parsing routine doesn’t do it for you). This avoids confusion where attribute values could be encoded in different ways (due to escaped characters or differing string encodings).</li>
<li>Use established library routines for comparing DNs <em>using the internal DN structures, not strings</em>.</li>
</ul>
<p>Above all, just remember: <em>a Distinguished Name is not a string</em>, so don’t treat it like a string. For sure it’s more work, but DNs need special treatment or bugs will certainly arise.</p>
<p>That’s not to say that “native” DN parsing and comparison routines are bug-free. They are not. A common error is equal DNs comparing inequal due to differing attribute string encodings (e.g. <code>PrintableString</code> versus <code>UTF8String</code>). I have written about this in a <a href="2018-03-15-x509-dn-attribute-encoding.html">previous post</a>. In Dogtag we’ve enountered this kind of bug <a href="https://pagure.io/dogtagpki/issue/2475">quite</a> <a href="https://pagure.io/dogtagpki/issue/2828">a</a> <a href="https://pagure.io/dogtagpki/issue/2865">few</a> times. In these situations the DN comparison should be fixed, but it may be a satisfactory workaround to serialise <em>both</em> DNs and perform a string comparison.</p>
<p>Another common issue is lack of support for multi-valued RDNs. A few years ago we wanted to switch FreeIPA’s certificate handling from <em>python-nss</em> to the <em>cryptography</em> library. I had to <a href="https://github.com/pyca/cryptography/issues/3199">add support</a> for multi-valued RDNs before we could make the switch.</p>
<p>A final takeaway for authors of standards. Providing multiple ways to serialise the same value leads to incompatibilities and bugs. For sure, there is a tradeoff between usability, implementation complexity and risk of interoperability issues and bugs. RFC 4514 would be less human-friendly if it only permitted hex-escapes. But implementations would be simpler and the interop/bug risk would be reduced. It’s important to think about these tradeoffs and the consequences, especially for standards and protocols relating to security.</p>]]></summary>
</entry>
<entry>
    <title>Fixing expired system certificates in FreeIPA</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-05-24-ipa-cert-fix.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-05-24-ipa-cert-fix.html</id>
    <published>2019-05-24T00:00:00Z</published>
    <updated>2019-05-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="fixing-expired-system-certificates-in-freeipa">Fixing expired system certificates in FreeIPA</h1>
<p>In previous posts I outlined and demonstrated the <code>pki-server cert-fix</code> tool. This tool is part of Dogtag PKI. I also discussed what additional functionality would be needed to successfully use this tool in a FreeIPA environment.</p>
<p>This post details the result of the effort to make <code>cert-fix</code> useful for FreeIPA administrators. We implemented a wrapper program, <code>ipa-cert-fix</code>, which performs FreeIPA-specific steps in addition to executing <code>pki-server cert-fix</code>.</p>
<h2 id="what-does-ipa-cert-fix-do">What does <code>ipa-cert-fix</code> do?</h2>
<p>In brief, the steps performed by <code>ipa-cert-fix</code> are:</p>
<ol type="1">
<li>Inspect deployment to work out which certificates need renewing. This includes both Dogtag system certificates, FreeIPA-specific certificates (HTTP, LDAP, KDC and IPA RA).</li>
<li>Print intentions and await operator confirmation.</li>
<li>Invoke <code>pki-server cert-fix</code> to renew expired certificates, including FreeIPA-specific certificates.</li>
<li>Install renewed FreeIPA-specific certificates to their respective locations.</li>
<li>If any shared certificates were renewed (Dogtag system certificates excluding HTTP, and IPA RA), import them to the LDAP <code>ca_renewal</code> subtree and set the <code>caRenewalMaster</code> configuration to be the current server. This allows CA replicas to pick up the renewed shared certificates.</li>
<li>Restart FreeIPA (<code>ipactl restart</code>).</li>
</ol>
<h2 id="demonstration">Demonstration</h2>
<p>For this demonstration I used a deployment with the following characteristics:</p>
<ul>
<li>Two servers, <code>f29-0</code> and <code>f29-1</code>, with CA on both.</li>
<li><code>f29-0</code> is the current <em>CA renewal master</em>.</li>
<li>A KRA instance is installed on <code>f29-1</code>.</li>
<li>The deployment was created on 2019-05-24, so most of the certificates expire on or before 2021-05-24 (the exception being the CA certificate).</li>
</ul>
<p>On <strong>both servers</strong> I disabled <code>chronyd</code> and put the clock forward 27 months, so that all the certificates (except the IPA CA itself) are expired:</p>
<pre><code>[f29-1] ftweedal% sudo systemctl stop chronyd
[f29-1] ftweedal% date
Fri May 24 12:01:16 AEST 2019
[f29-1] ftweedal% sudo date 082412012021
Tue Aug 24 12:01:00 AEST 2021</code></pre>
<p>We want to perform this step on all machines in the topology. After all, we are simulating the passage of time.</p>
<p>After <code>ipactl restart</code> the Dogtag CA did not start, and we cannot communicate with FreeIPA due to the expired HTTP certificate:</p>
<pre><code>[f29-1] ftweedal% sudo ipactl status
Directory Service: RUNNING
krb5kdc Service: RUNNING
kadmin Service: RUNNING
httpd Service: RUNNING
ipa-custodia Service: RUNNING
pki-tomcatd Service: STOPPED
ipa-otpd Service: RUNNING
ipa: INFO: The ipactl command was successful

[f29-1] ftweedal% ipa user-find
ipa: ERROR: cannot connect to &#39;https://f29-1.ipa.local/ipa/json&#39;:
  [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed:
  certificate has expired (_ssl.c:1056)</code></pre>
<h3 id="fixing-the-first-server">Fixing the first server</h3>
<p>I will repair <code>f29-1</code> first, so that we can see why resetting the CA renewal master is an important step performed by <code>ipa-cert-fix</code>.</p>
<p>I ran <code>ipa-cert-fix</code> as <code>root</code>. It analyses the server, then prints a warning and the list of certificates to be renewed, and asks for confirmation:</p>
<pre><code>[f29-1] ftweedal% sudo ipa-cert-fix

                          WARNING

ipa-cert-fix is intended for recovery when expired certificates
prevent the normal operation of FreeIPA.  It should ONLY be used
in such scenarios, and backup of the system, especially certificates
and keys, is STRONGLY RECOMMENDED.


The following certificates will be renewed:

Dogtag sslserver certificate:                                                                                                                                                                                [2/34]
  Subject: CN=f29-1.ipa.local,O=IPA.LOCAL 201905222205                                                                                                                                                             
  Serial:  13
  Expires: 2021-05-12 05:55:47

Dogtag subsystem certificate:
  Subject: CN=CA Subsystem,O=IPA.LOCAL 201905222205
  Serial:  4
  Expires: 2021-05-11 12:07:11

Dogtag ca_ocsp_signing certificate:
  Subject: CN=OCSP Subsystem,O=IPA.LOCAL 201905222205
  Serial:  2
  Expires: 2021-05-11 12:07:11

Dogtag ca_audit_signing certificate:
  Subject: CN=CA Audit,O=IPA.LOCAL 201905222205
  Serial:  5
  Expires: 2021-05-11 12:07:12

Dogtag kra_transport certificate:
  Subject: CN=KRA Transport Certificate,O=IPA.LOCAL 201905222205
  Serial:  268369921
  Expires: 2021-05-12 06:00:10

Dogtag kra_storage certificate:
  Subject: CN=KRA Storage Certificate,O=IPA.LOCAL 201905222205
  Serial:  268369922
  Expires: 2021-05-12 06:00:10

Dogtag kra_audit_signing certificate:
  Subject: CN=KRA Audit,O=IPA.LOCAL 201905222205
  Serial:  268369923
  Expires: 2021-05-12 06:00:11

IPA IPA RA certificate:
  Subject: CN=IPA RA,O=IPA.LOCAL 201905222205
  Serial:  7
  Expires: 2021-05-11 12:07:47

IPA Apache HTTPS certificate:
  Subject: CN=f29-1.ipa.local,O=IPA.LOCAL 201905222205
  Serial:  12
  Expires: 2021-05-23 05:54:11

IPA LDAP certificate:
  Subject: CN=f29-1.ipa.local,O=IPA.LOCAL 201905222205
  Serial:  11
  Expires: 2021-05-23 05:53:58

IPA KDC certificate:
  Subject: CN=f29-1.ipa.local,O=IPA.LOCAL 201905222205
  Serial:  14
  Expires: 2021-05-23 05:57:50

Enter &quot;yes&quot; to proceed:</code></pre>
<p>Observe that the KRA certificates are included (we are on <code>f29-1</code>). I type “yes” and continue. After a few minutes the process has completed:</p>
<pre><code>Proceeding.
Renewed Dogtag sslserver certificate:
  Subject: CN=f29-1.ipa.local,O=IPA.LOCAL 201905222205
  Serial:  268369925
  Expires: 2023-08-14 02:19:33

... (9 certificates elided)

Renewed IPA KDC certificate:
  Subject: CN=f29-1.ipa.local,O=IPA.LOCAL 201905222205
  Serial:  268369935
  Expires: 2023-08-25 02:19:42

Becoming renewal master.
The ipa-cert-fix command was successful</code></pre>
<p>As suggested by the expiry dates, it took about 11 seconds to renew all 11 certifiates. So why did it take so long? The <code>pki-server cert-fix</code> command, which is part of Dogtag and invoked by <code>ipa-cert-fix</code>, restarts the Dogtag instance as its final step. Although a new LDAP certificate was issued, it is not yet been installed in 389’s certificate database. Dogtag fails to start; it cannot talk to LDAP because of the expired certificate, and the restart operation hangs for a while. <code>ipa-cert-fix</code> knows to expect this and ignores the <code>pki-server cert-fix</code> failure when the LDAP certificate needs renewal.</p>
<p><code>ipa-cert-fix</code> also reported that it was setting the renewal master (because shared certificates were renewed). Let’s check the server status and verify the configuration.</p>
<pre><code>[f29-1] ftweedal% sudo ipactl status
Directory Service: RUNNING
krb5kdc Service: RUNNING
kadmin Service: RUNNING
httpd Service: RUNNING
ipa-custodia Service: RUNNING
pki-tomcatd Service: RUNNING
ipa-otpd Service: RUNNING
ipa: INFO: The ipactl command was successful</code></pre>
<p>The server is up and running.</p>
<pre><code>[f29-1] ftweedal% kinit admin
Password for admin@IPA.LOCAL:
Password expired.  You must change it now.
Enter new password:
Enter it again:</code></pre>
<p>Passwords have expired (due to time-travel).</p>
<pre><code>[f29-1] ftweedal% ipa config-show |grep renewal
  IPA CA renewal master: f29-1.ipa.local</code></pre>
<p><code>f29-1</code> has indeed become the renewal master. Oh, and the HTTP and LDAP certifiate have been fixed.</p>
<pre><code>[f29-1] ftweedal% ipa cert-show 1 | grep Subject
  Subject: CN=Certificate Authority,O=IPA.LOCAL 201905222205</code></pre>
<p>And the IPA framework can talk to Dogtag. This proves that the IPA RA and Dogtag HTTPS and subsystem certificates are valid.</p>
<h3 id="fixing-subsequent-servers">Fixing subsequent servers</h3>
<p>Jumping back onto <code>f29-0</code>, let’s look at the Certmonger request statuses:</p>
<pre><code>[f29-0] ftweedal% sudo getcert list \
                  | egrep &#39;^Request|status:|subject:&#39;
Request ID &#39;20190522120745&#39;:
        status: CA_UNREACHABLE
        subject: CN=IPA RA,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120831&#39;:
        status: CA_UNREACHABLE
        subject: CN=CA Audit,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120832&#39;:
        status: CA_UNREACHABLE
        subject: CN=OCSP Subsystem,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120833&#39;:
        status: CA_UNREACHABLE
        subject: CN=CA Subsystem,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120834&#39;:
        status: MONITORING
        subject: CN=Certificate Authority,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120835&#39;:
        status: CA_UNREACHABLE
        subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120903&#39;:
        status: CA_UNREACHABLE
        subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120932&#39;:
        status: CA_UNREACHABLE
        subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120940&#39;:
        status: CA_UNREACHABLE
        subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205</code></pre>
<p>The <code>MONITORING</code> request is the CA certificate. All the other requests are stuck in <code>CA_UNREACHABLE</code>.</p>
<p>The Certmonger tracking requests need to communicate with LDAP to retrieve shared certificates. So we have to <code>ipactl restart</code> with <code>--force</code> to ignore individual service startup failures (Dogtag will fail):</p>
<pre><code>[f29-0] ftweedal% sudo ipactl restart --force
Skipping version check
Starting Directory Service
Starting krb5kdc Service
Starting kadmin Service
Starting httpd Service
Starting ipa-custodia Service
Starting pki-tomcatd Service
Starting ipa-otpd Service
ipa: INFO: The ipactl command was successful

[f29-0] ftweedal% sudo ipactl status
Directory Service: RUNNING
krb5kdc Service: RUNNING
kadmin Service: RUNNING
httpd Service: RUNNING
ipa-custodia Service: RUNNING
pki-tomcatd Service: STOPPED
ipa-otpd Service: RUNNING
ipa: INFO: The ipactl command was successful</code></pre>
<p>Now Certmonger is able to renew the shared certificates by retrieving the new certificate from LDAP. The IPA-managed certificates are also able to be renewed by falling back to requesting them from another CA server (the already repaired <code>f29-1</code>). After a short wait, <code>getcert list</code> shows that all but one of the certificates have been renewed:</p>
<pre><code>[f29-0] ftweedal% sudo getcert list \
                  | egrep &#39;^Request|status:|subject:&#39;
Request ID &#39;20190522120745&#39;:
        status: MONITORING
        subject: CN=IPA RA,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120831&#39;:
        status: MONITORING
        subject: CN=CA Audit,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120832&#39;:
        status: MONITORING
        subject: CN=OCSP Subsystem,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120833&#39;:
        status: MONITORING
        subject: CN=CA Subsystem,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120834&#39;:
        status: MONITORING
        subject: CN=Certificate Authority,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120835&#39;:
        status: CA_UNREACHABLE
        subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120903&#39;:
        status: MONITORING
        subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120932&#39;:
        status: MONITORING
        subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120940&#39;:
        status: MONITORING
        subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205</code></pre>
<p>The final <code>CA_UNREACHABLE</code> request is the Dogtag HTTP certificate. We can now run <code>ipa-cert-fix</code> on <code>f29-0</code> to repair this certificate:</p>
<pre><code>[f29-0] ftweedal% sudo ipa-cert-fix

                          WARNING

ipa-cert-fix is intended for recovery when expired certificates
prevent the normal operation of FreeIPA.  It should ONLY be used
in such scenarios, and backup of the system, especially certificates
and keys, is STRONGLY RECOMMENDED.


The following certificates will be renewed:

Dogtag sslserver certificate:
  Subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205
  Serial:  3
  Expires: 2021-05-11 12:07:11

Enter &quot;yes&quot; to proceed: yes
Proceeding.
Renewed Dogtag sslserver certificate:
  Subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205
  Serial:  15
  Expires: 2023-08-14 04:25:05

The ipa-cert-fix command was successful</code></pre>
<h3 id="all-done">All done?</h3>
<p>Yep. A subsequent execution of <code>ipa-cert-fix</code> shows that there is nothing to do, and exits:</p>
<pre><code>[f29-0] ftweedal% sudo ipa-cert-fix
Nothing to do.
The ipa-cert-fix command was successful</code></pre>
<h2 id="feature-status">Feature status</h2>
<p>Against the usual procedure for FreeIPA (and Red Hat projects in general), <code>ipa-cert-fix</code> was developed “downstream-first”. It has been merged to the <code>ipa-4-6</code> branch, but there might not even be another upstream release from that branch. But there might be a future RHEL release based on that branch (the savvy reader might infer a high degree of certainty, given we actually bothered to do that…)</p>
<p>In the meantime, work to forward-port the feature to <code>master</code> and newer branches is ongoing. I hope that it will be merged in the next week or so.</p>]]></summary>
</entry>
<entry>
    <title><code>cert-fix</code> redux</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-03-18-cert-fix-redux.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-03-18-cert-fix-redux.html</id>
    <published>2019-03-18T00:00:00Z</published>
    <updated>2019-03-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="cert-fix-redux"><code>cert-fix</code> redux</h1>
<p><a href="2019-02-28-dogtag-cert-fix.html">A few weeks ago I analysed</a> the Dogtag <code>pki-server cert-fix</code> tool, which is intended to assist with recovery in scenarios where expired certificates inhibit Dogtag’s normal operation. Unfortunately, there were some flawed assumptions and feature gaps that limited the usefulness of the tool, especially in FreeIPA contexts.</p>
<p>In this post, I provide an update on changes that are being made to the tool to address those shortcomings.</p>
<h2 id="recap">Recap</h2>
<p>Recapping the shortcomings in brief:</p>
<ol type="1">
<li>When TLS client certificate authentication is used to authenticate to Dogtag (the default for FreeIPA), and expired <code>subsystem</code> certificate causes authentication failure and Dogtag cannot start.</li>
<li>When Dogtag is configured to use TLS or STARTTLS when connecting to the database, an expired LDAP service certificate causes connection failure.</li>
<li><code>cert-fix</code> uses an admin or agent certificate to perform authenticated operations against Dogtag. An expired certificate causes authentication failure, and certificate renewal fails.</li>
<li>Expired CA certificate is not handled. Due to longer validity periods, and externally-signed CA certificates expiring at different times from Dogtag system certificates, this scenario is less common, but it still occurs.</li>
<li>The need to renew non-system certificates. Apart from system certificates, in order for correct operation of Dogtag it may be necessary to renew some other certificates, such as an expired LDAP service certificate, or an expired agent certificate (e.g. <code>IPA RA</code>). <code>cert-fix</code> did not provide a way to do this.</li>
</ol>
<h2 id="resolving-the-ldap-related-issues-issues-1-and-2">Resolving the LDAP-related issues (issues #1 and #2)</h2>
<p><code>cert-fix</code> now switches the deployment to use password authentication to LDAP, over an insecure connection on port 389. The original database configuration is restored when <code>cert-fix</code> finishes.</p>
<p>The <code>subsystem</code> certificate is used by Dogtag to authenticate to LDAP. Switching to password authentication works around the expired <code>subsystem</code> certificate. Furthermore if the <code>subsystem</code> certificate gets renewed, the new certificate gets imported into the <code>pkidbuser</code> LDAP entry so that authentication will work (389 DS requires an exact certificate match in the <code>userCertificate</code> attribute of the user).</p>
<p>If the LDAP service certificate is expired, this procedure works around that but <em>does not renew it</em>. This is problem #3, and is addressed separately.</p>
<p>Switching Dogtag to password authentication to LDAP means resetting the <code>pkidbuser</code> account password. We use the <code>ldappasswd</code> program to do this. The LDAP <em>password modify</em> extended operation requires confientiality (i.e. TLS or STARTTLS); an expired LDAP service certificate inhibits this. Therefore we use LDAPI and autobind. The LDAPI socket is specified via the <code>--ldapi-socket</code> option.</p>
<p>FreeIPA always configures LDAP and <code>root</code> autobind to the <code>cn=Directory Manager</code> LDAP account. For standalone Dogtag installations these may need to be configured before runnning <code>cert-fix</code>.</p>
<h2 id="resolving-expired-agent-certificate-issue-3">Resolving expired agent certificate (issue #3)</h2>
<p>Instead of using the certificate to authenticate the agent, reset the password of the agent account and use that password to authenticate the agent. The password is randomly generated and forgotten after <code>cert-fix</code> terminates.</p>
<p>The agent account to use is now specified via the <code>--agent-uid</code> option. NSSDB-related options for specifying the agent certificate and NSSDB passphrase have been removed.</p>
<h2 id="renewing-other-certificates-issue-5">Renewing other certificates (issue #5)</h2>
<p><code>cert-fix</code> learned the <code>--extra-cert</code> option, which gives the serial number of an extra certificate to renew. The option can be given multiple times to specify multiple certificates. Each certificate gets renewed and output in <code>/etc/pki/&lt;instance-dir&gt;/certs/&lt;serial&gt;-renewed.crt</code>. If a non-existing serial number is specified, an error is printed but processing continues.</p>
<p>This facility allows operators (or wrapper tools) to renew other essential certificates alongside the Dogtag system certificates. Further actions are needed to put those new certificates in the right places. But it is fair, in order to keep to keep the <code>cert-fix</code> tool simple, to put this burden back on the operator. In any case, we intend to write a supplementary tool for FreeIPA that wraps <code>cert-fix</code> and takes care of working out which extra certificates to renew, and putting them in the right places.</p>
<h2 id="new-or-changed-assumptions">New or changed assumptions</h2>
<p>The changes dicsussed above abolish some assumptions that were previously made by <code>cert-fix</code>, and establish some new assumptions.</p>
<p>Absolished:</p>
<ul>
<li>A valid admin certificate is no longer needed</li>
<li>A valid LDAP service certificate is no longer needed</li>
<li>When Dogtag is configured to use certificate authentication to LDAP, a valid subsystem certificate is no longer needed</li>
</ul>
<p>New:</p>
<ul>
<li><code>cert-fix</code> must be run as <code>root</code>.</li>
<li>LDAPI must be configured, with <code>root</code> autobinding to <code>cn=Directory Manager</code> or other account with privileges on <code>o=ipaca</code> subtree, including password reset privileges.</li>
<li>The password of the specified agent account will be reset. If needed, it can be changed back afterwards (manually; successful execution of <code>cert-fix</code> proves that the operator has privileges to do this).</li>
<li>If Dogtag was configured to use TLS certificate authentication to bind to LDAP, the password on the <code>pkidbuser</code> account will be reset. (If password authentication was already used, the password does not get reset).</li>
<li>LDAPI (ldappasswd) and need to be root</li>
</ul>
<h2 id="demo">Demo</h2>
<p>Here I’ll put the full command and command output for an execution of the <code>cert-fix</code> tool, and break it up with commentary. I will renew the <code>subsystem</code> certificate, and additionally the certificate with serial number 29 (which happens to be the LDAP certificate):</p>
<pre><code>[root@f27-1 ~]# pki-server cert-fix \
    --agent-uid admin \
    --ldapi-socket /var/run/slapd-IPA-LOCAL.socket \
    --cert subsystem \
    --extra-cert 29</code></pre>
<p>There is no longer any need to set up an NSSDB with an agent certificate, a considerable UX improvement! An further improvement was to default the log verbosity to <code>INFO</code>, so we can see progress and observe (at a high level) what the <code>cert-fix</code> is doing, without specifying <code>-v</code> / <code>--verbose</code>.</p>
<pre><code>INFO: Loading password config: /etc/pki/pki-tomcat/password.conf
INFO: Fixing the following system certs: [&#39;subsystem&#39;]
INFO: Renewing the following additional certs: [&#39;29&#39;]
SASL/EXTERNAL authentication started
SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth
SASL SSF: 0</code></pre>
<p>Preliminaries. The tool loads information about the Dogtag instance, states its intentions and verifies that it can authenticate to LDAP.</p>
<pre><code>INFO: Stopping the instance to proceed with system cert renewal
INFO: Configuring LDAP password authentication
INFO: Setting pkidbuser password via ldappasswd
SASL/EXTERNAL authentication started
SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth
SASL SSF: 0
INFO: Selftests disabled for subsystems: ca
INFO: Resetting password for uid=admin,ou=people,o=ipaca
SASL/EXTERNAL authentication started
SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth
SASL SSF: 0</code></pre>
<p><code>cert-fix</code> stopped Dogtag, changed the database connection configuration, reset the agent password and suppressed the Dogtag self-tests.</p>
<pre><code>INFO: Starting the instance
INFO: Sleeping for 10 seconds to allow server time to start...</code></pre>
<p><code>cert-fix</code> starts Dogtag then sleeps for a bit. The sleep was added to avoid races against Dogtag startup that sometimes caused the tool to fail. It’s a bit of a hack, but 10 seconds should <em>hopefully</em> be enough.</p>
<pre><code>INFO: Requesting new cert for subsystem
INFO: Getting subsystem cert info for ca
INFO: Trying to setup a secure connection to CA subsystem.
INFO: Secure connection with CA is established.
INFO: Placing cert creation request for serial: 34
INFO: Request ID: 38
INFO: Request Status: complete
INFO: Serial Number: 0x26
INFO: Issuer: CN=Certificate Authority,O=IPA.LOCAL 201903151111
INFO: Subject: CN=CA Subsystem,O=IPA.LOCAL 201903151111
INFO: New cert is available at: /etc/pki/pki-tomcat/certs/subsystem.crt
INFO: Requesting new cert for 29; writing to /etc/pki/pki-tomcat/certs/29-renewed.crt
INFO: Trying to setup a secure connection to CA subsystem.
INFO: Secure connection with CA is established.
INFO: Placing cert creation request for serial: 29
INFO: Request ID: 39
INFO: Request Status: complete
INFO: Serial Number: 0x27
INFO: Issuer: CN=Certificate Authority,O=IPA.LOCAL 201903151111
INFO: Subject: CN=f27-1.ipa.local,O=IPA.LOCAL 201903151111
INFO: New cert is available at: /etc/pki/pki-tomcat/certs/29-renewed.crt</code></pre>
<p>Certificate requests were issued and completed successfully.</p>
<pre><code>INFO: Stopping the instance
INFO: Getting subsystem cert info for ca
INFO: Getting subsystem cert info for ca
INFO: Updating CS.cfg with the new certificate
INFO: Importing new subsystem cert into uid=pkidbuser,ou=people,o=ipaca
SASL/EXTERNAL authentication started
SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth
SASL SSF: 0
modifying entry &quot;uid=pkidbuser,ou=people,o=ipaca&quot;</code></pre>
<p>Dogtag was stopped, and the new subsystem cert was updated in <code>CS.cfg</code>. It was also imported into the <code>pkidbuser</code> entry to ensure LDAP TLS client authentication continues to work. No further action is taken in relation to the extra cert(s).</p>
<pre><code>INFO: Selftests enabled for subsystems: ca
INFO: Restoring previous LDAP configuration
INFO: Starting the instance with renewed certs</code></pre>
<p>Self-tests are re-enabled and the previous LDAP configuration restored. Python <em>context managers</em> are used to ensure that these steps are performed even when a fatal error occurs.</p>
<p>The end.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The problem of an expired CA certificate (issue <strong>#4</strong>) has not yet been addressed. It is not the highest priority but it would be nice to have. It is still believed to be a low-effort change so it is likely to be implemented at some stage.</p>
<p>More extensive testing of the tool is needed for renewing system certificates for other Dogtag subsystems—in particular the KRA subsystem.</p>
<p>The enhancements discussed in this post make the <code>cert-fix</code> tool a viable MVP for expired certificate recovery without time-travel. The enhancements are still in review, yet to be merged. That will hopefully happen soon (within a day or so of this post). We are also making a significant effort to backport <code>cert-fix</code> to some earlier branches and make it available on older releases.</p>
<p>As mentioned earlier in the post, we intend to implement a FreeIPA-specific wrapper for <code>cert-fix</code> that can take care of the additional steps required to renew and deploy expired certificates that are part of the FreeIPA system, but are not Dogtag system certificates handled directly by <code>cert-fix</code>. These include LDAP and Apache HTTPD certificates, the IPA RA agent certificate and the Kerberos PKINIT certificate.</p>]]></summary>
</entry>
<entry>
    <title>Customising Dogtag system certificate lifetimes</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-03-04-dogtag-system-cert-lifetime.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-03-04-dogtag-system-cert-lifetime.html</id>
    <published>2019-03-04T00:00:00Z</published>
    <updated>2019-03-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="customising-dogtag-system-certificate-lifetimes">Customising Dogtag system certificate lifetimes</h1>
<p>Default certificate lifetimes in Dogtag are 20 years for the CA certificate (when self-signed) and about 2 years for other system certificates. These defaults also apply to FreeIPA. It can be desirable to have shorter certificate lifetimes. And although I wouldn’t recommend to use <em>longer</em> lifetimes, people sometimes want that.</p>
<p>There is no <em>supported</em> mechanism for customising system certificate validity duration during Dogtag or FreeIPA installation. But it can be done. In this post I’ll explain how.</p>
<h2 id="profile-configuration-files">Profile configuration files</h2>
<p>During installation, profile configurations are copied from the RPM install locations under <code>/usr/share</code> to the new Dogtag instance’s configuration directory. If the LDAP profile subsystem is used (FreeIPA uses it) they are further copied from the instance configuration directory into the LDAP database.</p>
<p>There is no facility or opportunity to modify the profiles during installation. So if you want to customise the certificate lifetimes, you have to modify the files under <code>/usr/share</code>.</p>
<p>There are two directories that contain profile configurations:</p>
<dl>
<dt><code>/usr/share/pki/ca/profiles/ca/*.cfg</code></dt>
<dd><p>These profile configurations are available during general operation.</p>
</dd>
<dt><code>/usr/share/pki/ca/conf/*.profile</code></dt>
<dd><p>These <em>overlay</em> configurations used during installation when issuing system certificates. Each configuration references an underlying profile and can override or extend the configuration.</p>
</dd>
<dt><code>/usr/share/ipa/profiles/*.cfg</code></dt>
<dd><p>Profiles that are shipped by FreeIPA and imported into Dogtag are defined here. The configurations for the LDAP, Apache HTTPS and KDC certificates are found here.</p>
</dd>
</dl>
<p>I’ll explain which configuration file is used for which certificate later on in this post.</p>
<h2 id="specifying-the-validity-period">Specifying the validity period</h2>
<p>The configuration field for setting the validity period are:</p>
<pre><code>&lt;component&gt;.default.params.range=720
&lt;component&gt;.constraint.params.range=720</code></pre>
<p>where <code>&lt;component&gt;</code> is some key, usually a numeric index, that may be different for different profiles. The actual profile component classes are <code>ValidityDefault</code> and <code>ValidityConstraint</code>, or <code>{CA,User}Validity{Default,Constraint}</code> for some profiles.</p>
<p>The <code>default</code> component sets the default validity period for this profile, whereas the constraint sets the <em>maximum</em> duration in case the user overrides it. Note that if an override configuration overrides the <code>default</code> value such that it exceeds the <code>constraint</code> specified in the underlying configuration, issuance will fail due to constraint violation. It is usually best to specify both the <code>default</code> and <code>constraint</code> together, with the same value.</p>
<p>The default range unit is <code>day</code>, so the configuration above means <em>720 days</em>. Use the <code>rangeUnit</code> parameter to specify a different unit. The supported units are <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code> and <code>minute</code>. For example:</p>
<pre><code>&lt;component&gt;.default.params.range=3
&lt;component&gt;.default.params.rangeUnit=month
&lt;component&gt;.constraint.params.range=3
&lt;component&gt;.constraint.params.rangeUnit=month</code></pre>
<h2 id="which-configuration-for-which-certificate">Which configuration for which certificate?</h2>
<dl>
<dt>CA certificate (when self-signed)</dt>
<dd><p><code>/usr/share/pki/ca/conf/caCert.profile</code></p>
</dd>
<dt>OCSP signing certificate</dt>
<dd><p><code>/usr/share/pki/ca/conf/caOCSPCert.profile</code></p>
</dd>
<dt>Subsystem certificate</dt>
<dd><p><code>/usr/share/pki/ca/conf/rsaSubsystemCert.profile</code> when using RSA keys (the default)</p>
</dd>
<dt>Dogtag HTTPS certificate</dt>
<dd><p><code>/usr/share/pki/ca/conf/rsaServerCert.profile</code> when using RSA keys (the default)</p>
</dd>
<dt>Audit signing</dt>
<dd><p><code>/usr/share/pki/ca/conf/caAuditSigningCert.profile</code></p>
</dd>
<dt>IPA RA agent (FreeIPA-specific)</dt>
<dd><p><code>/usr/share/pki/ca/profiles/ca/caServerCert.cfg</code></p>
</dd>
<dt>Apache and LDAP certificates (FreeIPA-specific)</dt>
<dd><p><code>/usr/share/ipa/profiles/caIPAserviceCert.cfg</code></p>
</dd>
<dt>KDC certificate (FreeIPA-specific)</dt>
<dd><p><code>/usr/share/ipa/profiles/KDCs_PKINIT_Certs.cfg</code></p>
</dd>
</dl>
<h2 id="testing">Testing</h2>
<p>I made changes to the files mentioned above, so that certificates would be issued with the following validity periods:</p>
<table>
<tbody>
<tr class="odd">
<td>CA</td>
<td>5 years</td>
</tr>
<tr class="even">
<td>OCSP</td>
<td>1 year</td>
</tr>
<tr class="odd">
<td>Subsystem</td>
<td>6 months</td>
</tr>
<tr class="even">
<td>HTTPS</td>
<td>3 months</td>
</tr>
<tr class="odd">
<td>Audit</td>
<td>1 year</td>
</tr>
<tr class="even">
<td>IPA RA</td>
<td>15 months</td>
</tr>
<tr class="odd">
<td>Apache</td>
<td>4 months</td>
</tr>
<tr class="even">
<td>LDAP</td>
<td>4 months</td>
</tr>
<tr class="odd">
<td>KDC</td>
<td>18 months</td>
</tr>
</tbody>
</table>
<p>I installed FreeIPA (with a self-signed CA). After installation completed, I had a look at the certificates that were being tracked by Certmonger. For reference, the installation took place on March 4, 2019 (<strong>2019-03-04</strong>).</p>
<pre><code># getcert list |egrep &#39;^Request|certificate:|expires:&#39;
Request ID &#39;20190304044028&#39;:
  certificate: type=FILE,location=&#39;/var/lib/ipa/ra-agent.pem&#39;
  expires: 2020-06-04 15:40:30 AEST
Request ID &#39;20190304044116&#39;:
  certificate: type=NSSDB,location=&#39;/etc/pki/pki-tomcat/alias&#39;,nickname=&#39;auditSigningCert cert-pki-ca&#39;,token=&#39;NSS Certificate DB&#39;
  expires: 2020-03-04 15:39:53 AEDT
Request ID &#39;20190304044117&#39;:
  certificate: type=NSSDB,location=&#39;/etc/pki/pki-tomcat/alias&#39;,nickname=&#39;ocspSigningCert cert-pki-ca&#39;,token=&#39;NSS Certificate DB&#39;
  expires: 2020-03-04 15:39:53 AEDT
Request ID &#39;20190304044118&#39;:
  certificate: type=NSSDB,location=&#39;/etc/pki/pki-tomcat/alias&#39;,nickname=&#39;subsystemCert cert-pki-ca&#39;,token=&#39;NSS Certificate DB&#39;
  expires: 2019-09-04 15:39:53 AEST
Request ID &#39;20190304044119&#39;:
  certificate: type=NSSDB,location=&#39;/etc/pki/pki-tomcat/alias&#39;,nickname=&#39;caSigningCert cert-pki-ca&#39;,token=&#39;NSS Certificate DB&#39;
  expires: 2024-03-04 15:39:51 AEDT
Request ID &#39;20190304044120&#39;:
  certificate: type=NSSDB,location=&#39;/etc/pki/pki-tomcat/alias&#39;,nickname=&#39;Server-Cert cert-pki-ca&#39;,token=&#39;NSS Certificate DB&#39;
  expires: 2019-06-04 15:39:53 AEST
Request ID &#39;20190304044151&#39;:
  certificate: type=NSSDB,location=&#39;/etc/dirsrv/slapd-IPA-LOCAL&#39;,nickname=&#39;Server-Cert&#39;,token=&#39;NSS Certificate DB&#39;
  expires: 2019-07-04 15:41:52 AEST
Request ID &#39;20190304044225&#39;:
  certificate: type=FILE,location=&#39;/var/lib/ipa/certs/httpd.crt&#39;
  expires: 2019-07-04 15:42:26 AEST
Request ID &#39;20190304044234&#39;:
  certificate: type=FILE,location=&#39;/var/kerberos/krb5kdc/kdc.crt&#39;
  expires: 2020-09-04 15:42:34 AEST</code></pre>
<p>Observe that the certificate have the intended periods.</p>
<h2 id="discussion">Discussion</h2>
<p>The procedure outlined in this post is not officially supported, and not recommended. But the desire to choose different validity periods is sometimes justified, especially for the CA certificate. So should FreeIPA allow customisation of the system certificate validity periods? To what extent?</p>
<p>We need to reduce the default CA validity from 20 years, given the 2048-bit key size. (There is a separate issue to support generating a larger CA signing key, too). Whether the CA validity period should be configurable is another question. My personal opinion is that it makes sense to allow the customer to choose the CA lifetime.</p>
<p>For system certificates, I think that customers should just accept the defaults. PKI systems are trending to shorter lifetimes for end-entity certificates, which is a good thing. For FreeIPA, unfortunately we are still dealing with a lot of certificate renewal issues that arise from the complex architecture. Until we are confident in the robustness of the renewal system, and have observed a reduction in customer issues, it would be a mistake to substantially reduce the validity period for system certificates. Likewise, it is not yet a good idea to let customers choose the certificate validity periods.</p>
<p>On the other hand, the team is considering changing the default validity period of system certificates <em>a little bit</em>, so that different certificates are on different renewal candences. This would simplify recovery in some scenarios: it is easier to recover when only <em>some</em> of the certificates expired, instead of <em>all</em> of them at once.</p>]]></summary>
</entry>
<entry>
    <title>Specifying a CA Subject Key Identifier during Dogtag installation</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-03-01-dogtag-csr-ski.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-03-01-dogtag-csr-ski.html</id>
    <published>2019-03-01T00:00:00Z</published>
    <updated>2019-03-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="specifying-a-ca-subject-key-identifier-during-dogtag-installation">Specifying a CA Subject Key Identifier during Dogtag installation</h1>
<p>When installing Dogtag with an externally-signed CA certificate, it is sometimes necessary to include a specific <em>Subject Key Identifier</em> value in the CSR. In this post I will demonstrate how to do this.</p>
<h2 id="what-is-a-subject-key-identifier">What is a Subject Key Identifier?</h2>
<p>The X.509 <em>Subject Key Identifier (SKI)</em> extension declares a unique identifier for the public key in the certificate. It is required on all CA certificates. CAs propagate their own SKI to the <em>Issuer Key Identifier (AKI)</em> extension on issued certificates. Together, these facilitate efficient certification path construction; certificate databases can index certificates by SKI.</p>
<p>The SKI must be unique for a given key. Most often it is derived from the public key data using a cryptographic digest, usually SHA-1. But any method of generating a unique value is acceptable.</p>
<p>For example, let’s look at the CA certificate and one of the service certificates in a FreeIPA deployment. The CA is self-signed and therefore contains the same value in both the SKI and AKI extensions:</p>
<pre><code>% openssl x509 -text &lt; /etc/ipa/ca.crt
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 1 (0x1)
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: O = IPA.LOCAL 201902271325, CN = Certificate Authority
        Validity
            Not Before: Feb 27 03:30:22 2019 GMT
            Not After : Feb 27 03:30:22 2034 GMT
        Subject: O = IPA.LOCAL 201902271325, CN = Certificate Authority
        Subject Public Key Info:
            &lt; elided &gt;
        X509v3 extensions:
            X509v3 Authority Key Identifier:
                keyid:C9:29:69:D0:14:A4:AB:11:D4:11:B1:35:31:81:08:B6:A9:30:D3:0A

            X509v3 Basic Constraints: critical
                CA:TRUE
            X509v3 Key Usage: critical
                Digital Signature, Non Repudiation, Certificate Sign, CRL Sign
            X509v3 Subject Key Identifier:
                C9:29:69:D0:14:A4:AB:11:D4:11:B1:35:31:81:08:B6:A9:30:D3:0A
            Authority Information Access:
                OCSP - URI:http://ipa-ca.ipa.local/ca/ocsp
  ...</code></pre>
<p>Whereas the end entity certificate has the CA’s SKI in its AKI, and its SKI is different:</p>
<pre><code>% sudo cat /var/lib/ipa/certs/httpd.crt | openssl x509 -text
Certificate:
    Data:
      Version: 3 (0x2)                                                                                                                                                                                  [43/9508]
      Serial Number: 9 (0x9)
      Signature Algorithm: sha256WithRSAEncryption
      Issuer: O = IPA.LOCAL 201902271325, CN = Certificate Authority
      Validity
          Not Before: Feb 27 03:32:57 2019 GMT
          Not After : Feb 27 03:32:57 2021 GMT
      Subject: O = IPA.LOCAL 201902271325, CN = f29-0.ipa.local
      Subject Public Key Info:
          &lt; elided &gt;
      X509v3 extensions:
          X509v3 Authority Key Identifier:
              keyid:C9:29:69:D0:14:A4:AB:11:D4:11:B1:35:31:81:08:B6:A9:30:D3:0A

          Authority Information Access:
              OCSP - URI:http://ipa-ca.ipa.local/ca/ocsp

          X509v3 Key Usage: critical
              Digital Signature, Non Repudiation, Key Encipherment, Data Encipherment
          X509v3 Extended Key Usage:
              TLS Web Server Authentication, TLS Web Client Authentication
          X509v3 CRL Distribution Points:

              Full Name:
                URI:http://ipa-ca.ipa.local/ipa/crl/MasterCRL.bin
              CRL Issuer:
                DirName:O = ipaca, CN = Certificate Authority

          X509v3 Subject Key Identifier:
              FE:D2:8A:72:C8:D5:78:79:C9:04:04:A8:39:37:7F:FD:36:E6:E9:D2
          X509v3 Subject Alternative Name:
              DNS:f29-0.ipa.local, othername:&lt;unsupported&gt;, othername:&lt;unsupported&gt;</code></pre>
<p>Most CA programs, including Dogtag, automatically compute a SKI for every certificate being issued. Dogtag computes a SHA-1 hash over the <code>subjectPublicKey</code> value, which is the most common method. The value must be unique, but does not have to be derived from the public key.</p>
<p>It is not required for a self-signed CA certificate to contain an AKI extension. Neither is it necessary to include a SKI in an end entity certificate. But it does not hurt to include them. Indeed it is common (as we see above).</p>
<h2 id="use-case-for-specifying-a-ski">Use case for specifying a SKI</h2>
<p>If CAs can automatically compute a SKI, why would you need to specify one?</p>
<p>The use case arises when you’re changing external CAs or switching from self-signed to externally-signed, or vice versa. The new CA might compute SKIs differently from the current CA. But it is important to keep using the same SKI. So it is desirable to include the SKI in the CSR to indicate to the CA the value that should be used.</p>
<p>Not every CA program will follow the suggestion. Or the behaviour may be configurable, system-wide or per-profile. If you’re using Dogtag / RHCS to sign CA certificates, it is straightforward to define a profile that uses an SKI supplied in the CSR (but that is beyond the scope of this article).</p>
<h2 id="including-an-ski-in-a-dogtag-csr">Including an SKI in a Dogtag CSR</h2>
<p>At time of writing, this procedure is supported in Dogtag 10.6.9 and later, which is available in Fedora 28 and Fedora 29. It will be supported in a future version of RHEL. The behaviour depends on a recent enhancement to the <code>certutil</code> program, which is part of NSS. That enhancement is not in RHEL 7 yet, hence this Dogtag feature is not yet available on RHEL 7.</p>
<p>When installing Dogtag using the two-step external signing procedure, by default no SKI is included the CSR. You can change this via the <code>pki_req_ski</code> option. The option is described in the <code>pki_default.cfg(5)</code> man page. There are two ways to use the option, and we will look at each in turn.</p>
<h3 id="default-method">Default method</h3>
<pre><code>[CA]
pki_req_ski=DEFAULT</code></pre>
<p>This special value will cause the CSR to contain a SKI value computed using the same method Dogtag itself uses (SHA-1 digest). Adding this value resulted in the following CSR data:</p>
<pre><code>Certificate Request:
    Data:
        Version: 1 (0x0)
        Subject: O = IPA.LOCAL 201903011502, CN = Certificate Authority
        Subject Public Key Info:
            &lt; elided &gt;
        Attributes:
        Requested Extensions:
            X509v3 Subject Key Identifier: 
                76:49:AA:B2:08:60:18:C1:6D:AF:2C:28:A0:54:34:77:7E:8F:80:71
            X509v3 Basic Constraints: critical
                CA:TRUE
            X509v3 Key Usage: critical
                Digital Signature, Non Repudiation, Certificate Sign, CRL Sign</code></pre>
<p>The SKI value is the SHA-1 digest of the public key. Of course, it will be different every time, because a different key will be generated.</p>
<h3 id="explicit-ski">Explicit SKI</h3>
<pre><code>[CA]
pki_req_ski=&lt;hex data&gt;</code></pre>
<p>An exact SKI value can be specified as a hex-encode byte string. The datum <strong>must not</strong> have a leading <code>0x</code>. I used the following configuration:</p>
<pre><code>[CA]
pki_req_ski=00D06F00D4D06746</code></pre>
<p>With this configuration, the expected SKI value appears in the CSR:</p>
<pre><code>Certificate Request:
    Data:
        Version: 1 (0x0)
        Subject: O = IPA.LOCAL 201903011518, CN = Certificate Authority
        Subject Public Key Info:
            &lt; elided &gt;
        Attributes:
        Requested Extensions:
            X509v3 Subject Key Identifier:
                00:D0:6F:00:D4:D0:67:46
            X509v3 Basic Constraints: critical
                CA:TRUE
            X509v3 Key Usage: critical
                Digital Signature, Non Repudiation, Certificate Sign, CRL Sign</code></pre>
<h2 id="renewal">Renewal</h2>
<p>We don’t have direct support for including the SKI in the CSR generated for renewing an externally signed CA. But you can use <code>certutil</code> to create a CSR that includes the desired SKI.</p>
<p>It could be worthwhile to enhance Certmonger to automatically include the SKI of the current certificate when it creates a CSR for renewing a tracked certificate.</p>
<h2 id="freeipa-support">FreeIPA support</h2>
<p>We don’t expose this feature in FreeIPA directly. It can be hacked in pretty easily by modifying the Python code that builds the <code>pkispawn</code> configuration during installation. Alternatively, set the option in the <code>pkispawn</code> default configuration file: <code>/usr/share/pki/server/etc/default.cfg</code> (this is what I did to test the feature).</p>
<p>Changes to be made as part of the <a href="https://github.com/freeipa/freeipa/pull/2307">upcoming HSM support</a> will, as a pleasant side effect, make it easy to specify or override <code>pkispawn</code> configuration values including <code>pki_req_ski</code>.</p>]]></summary>
</entry>
<entry>
    <title>Offline expired certificate renewal for Dogtag</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-02-28-dogtag-cert-fix.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-02-28-dogtag-cert-fix.html</id>
    <published>2019-02-28T00:00:00Z</published>
    <updated>2019-02-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="offline-expired-certificate-renewal-for-dogtag">Offline expired certificate renewal for Dogtag</h1>
<p>The worst has happened. Somehow, certificate renewal didn’t happen when it should have, and now you have expired certificates. Worst, these are Dogtag system certificates; you can’t even start Dogtag to issue new ones! Unfortunately, this situation arises fairly often. Sometimes due to administrator error or extended downtime; sometimes due to bugs. These cases are notoriously difficult (and expensive) to analyse and resolve. It often involves <em>time travel</em>:</p>
<ol type="1">
<li>Set the system clock to a time setting just before certificates started expiring.</li>
<li>Fix whatever caused renewal not to work in the first place.</li>
<li>Renew expiring certificates.</li>
<li>Reset system clock.</li>
</ol>
<p>That is the <em>simple</em> case! I have seen much gnarlier scenarios. Ones where <em>multiple times</em> must be visited. Ones where there is <em>no time</em> at which all relevant certs are valid.</p>
<p>It would be nice to avoid these scenarios, and the FreeIPA team continues to work to improve the robustness of certificate renewal. We also have a monitoring / health check solution on the roadmap, so that failure of automated renewal sets off alarms before <em>everything else</em> falls over. But in the meantime, customers and support are still dealing with scenarios like this. Better recovery tools are needed.</p>
<p>And better tools are on the way! Dinesh, one of the Dogtag developers, has built a tool to simplify renewal when your Dogtag CA is offline due to expired system certificates. This post outlines what the tool is, what it does, and my first experiences using it in a FreeIPA deployment. Along the way and especially toward the end of the post, I will discuss the caveats and potential areas for improvement, and FreeIPA-specific considerations.</p>
<h2 id="pki-server-cert-fix"><code>pki-server cert-fix</code></h2>
<p>The tool is implemented as a subcommand of the <code>pki-server</code> utility–namely <code>cert-fix</code> (and I will use this short name throughout the post). So it is implemented in Python, but in some places it calls out to <code>certutil</code> or the Java parts of Dogtag via the HTTP API. The <a href="https://github.com/dogtagpki/pki/blob/master/docs/admin/Offline_System_Certificate_Renewal.md">user documentation</a> is maintained the source repository.</p>
<p>The insight at the core of <code>cert-fix</code> is that even if Dogtag is not running or <em>cannot</em> run, we still have access to the keys needed to issue certificates. We <em>do</em> need to use Dogtag to properly store issued certificates (for revocation purposes) and produce an audit trail. But if needed, we can use the CA signing key to <strong>temporarily</strong> fudge the important certificates to get Dogtag running again, then re-issue expired system certificates properly.</p>
<h3 id="assumptions">Assumptions</h3>
<p><code>cert-fix</code> makes the following assumptions about your environment. If these do not hold, then <code>cert-fix</code>, as currently implemented, cannot do its thing.</p>
<ul>
<li>The CA signing certificate is valid.</li>
<li>You have a valid admin or agent certificate. In a FreeIPA environment the <code>IPA RA</code> certificaite fulfils this role.</li>
<li>(indirect) The LDAP server (389 DS) is operational, its certificate is valid, and Dogtag can authenticate to it.</li>
</ul>
<p>These assumptions have been made for good reasons, but there are several certificate expiry scenarios that breach them. I will discuss in detail later in the post. For now, we must accept them.</p>
<h3 id="what-cert-fix-does">What <code>cert-fix</code> does</h3>
<p>The <code>cert-fix</code> performs the following actions to renew an expired system certificate:</p>
<ol>
<li>Inspect the system and identify which system certificates need renewing. Or the certificates can be specified on the command line.</li>
<li>If Dogtag’s HTTPS certificate is expired, use certutil commands to issue a new “temporary” certificate. The validity period is three months (from the current time). The serial number of the current (expired) HTTPS is reused (a big X.509 no-no, but operationally no big deal in this scenario). There is no audit trail and the certificate will not appear in the LDAP database.</li>
<li>Disable the startup self-test for affected subsystems, then start Dogtag.</li>
<li>For each target certificate, renew the certificate via API, using given credential. Validity periods and other characteristics are determined by relevant profiles. Serial numbers are chosen in the usual manner, the certificates appear in LDAP and there is an audit trail.</li>
<li>Stop Dogtag.</li>
<li>For each target certificate, import the new certificate into Dogtag’s NSSDB.</li>
<li>Re-enable self-test for affected subsystems and start Dogtag.</li>
</ol>
<h2 id="using-cert-fix">Using <code>cert-fix</code></h2>
<p>There are a couple of ways to try out the tool—without waiting for certificates to expire, that is. One way is to roll your system clock forward, beyond the expiry date of one or more certificates. Another possibility is to modify a certificate profile used for a system certificate so that it will be issued with a very short validity period.</p>
<p>I opted for the latter option. I manually edited the default profile configuration, so that Dogtag’s OCSP and HTTPS certificates would be issued with a validity period of 15 minutes. By the time I installed FreeIPA, grabbed a coffee and read a few emails, the certificates had expired. Certmonger didn’t even attempt to renew them. Dogtag was still running and working properly, but <code>ipactl restart</code> put Dogtag, and the whole FreeIPA deployment, out of action.</p>
<p>I used <code>pki-server cert-find</code> to have a peek at Dogtag’s system certificates:</p>
<pre><code>[root@f29-0 ca]# pki-server cert-find
  Cert ID: ca_signing
  Nickname: caSigningCert cert-pki-ca
  Serial Number: 0x1
  Subject DN: CN=Certificate Authority,O=IPA.LOCAL 201902271325
  Issuer DN: CN=Certificate Authority,O=IPA.LOCAL 201902271325
  Not Valid Before: Wed Feb 27 14:30:22 2019
  Not Valid After: Mon Feb 27 14:30:22 2034

  Cert ID: ca_ocsp_signing
  Nickname: ocspSigningCert cert-pki-ca
  Serial Number: 0x2
  Subject DN: CN=OCSP Subsystem,O=IPA.LOCAL 201902271325
  Issuer DN: CN=Certificate Authority,O=IPA.LOCAL 201902271325
  Not Valid Before: Wed Feb 27 14:30:24 2019
  Not Valid After: Wed Feb 27 14:45:24 2019

  Cert ID: sslserver
  Nickname: Server-Cert cert-pki-ca
  Serial Number: 0x3
  Subject DN: CN=f29-0.ipa.local,O=IPA.LOCAL 201902271325
  Issuer DN: CN=Certificate Authority,O=IPA.LOCAL 201902271325
  Not Valid Before: Wed Feb 27 14:30:24 2019
  Not Valid After: Wed Feb 27 14:45:24 2019

  Cert ID: subsystem
  Nickname: subsystemCert cert-pki-ca
  Serial Number: 0x4
  Subject DN: CN=CA Subsystem,O=IPA.LOCAL 201902271325
  Issuer DN: CN=Certificate Authority,O=IPA.LOCAL 201902271325
  Not Valid Before: Wed Feb 27 14:30:24 2019
  Not Valid After: Tue Feb 16 14:30:24 2021

  Cert ID: ca_audit_signing
  Nickname: auditSigningCert cert-pki-ca
  Serial Number: 0x5
  Subject DN: CN=CA Audit,O=IPA.LOCAL 201902271325
  Issuer DN: CN=Certificate Authority,O=IPA.LOCAL 201902271325
  Not Valid Before: Wed Feb 27 14:30:24 2019
  Not Valid After: Tue Feb 16 14:30:24 2021</code></pre>
<p>Note the <code>Not Valid After</code> times for the <code>ca_ocsp_signing</code> and <code>sslserver</code> certificates. These are certificates we must renew.</p>
<h3 id="preparing-the-agent-certificate">Preparing the agent certificate</h3>
<p>The <code>cert-fix</code> command requires an agent certificate. We will use the <em>IPA RA</em> certificate. The <code>pki-server</code> CLI tool needs an NSSDB with the agent key and certificate. So we have to set that up. First initialise the NSSDB:</p>
<pre><code>[root@f29-0 ~]# mkdir ra-nssdb
[root@f29-0 ~]# cd ra-nssdb
[root@f29-0 ra-nssdb]# certutil -d . -N
Enter a password which will be used to encrypt your keys.
The password should be at least 8 characters long,
and should contain at least one non-alphabetic character.

Enter new password: XXXXXXXX
Re-enter password: XXXXXXXX</code></pre>
<p>Then create a PKCS #12 file containing the required key and certificates:</p>
<pre><code>[root@f29-0 ra-nssdb]# openssl pkcs12 -export \
  -inkey /var/lib/ipa/ra-agent.key \
  -in /var/lib/ipa/ra-agent.pem \
  -name &quot;ra-agent&quot; \
  -certfile /etc/ipa/ca.crt &gt; ra-agent.p12
Enter Export Password:
Verifying - Enter Export Password:</code></pre>
<p>Import it into the NSSDB, and fix up trust flags on the IPA CA certificate:</p>
<pre><code>[root@f29-0 ra-nssdb]# pk12util -d . -i ra-agent.p12
Enter Password or Pin for &quot;NSS Certificate DB&quot;:
Enter password for PKCS12 file:
pk12util: PKCS12 IMPORT SUCCESSFUL

[root@f29-0 ra-nssdb]# certutil -d . -L

Certificate Nickname                                         Trust Attributes
                                                             SSL,S/MIME,JAR/XPI

ra-agent                                                     u,u,u
Certificate Authority - IPA.LOCAL 201902271325               ,,

[root@f29-0 ra-nssdb]# certutil -d . -M \
    -n &#39;Certificate Authority - IPA.LOCAL 201902271325&#39; \
    -t CT,C,C
Enter Password or Pin for &quot;NSS Certificate DB&quot;:

[root@f29-0 ra-nssdb]# certutil -d . -L

Certificate Nickname                                         Trust Attributes
                                                             SSL,S/MIME,JAR/XPI

ra-agent                                                     u,u,u
Certificate Authority - IPA.LOCAL 201902271325               CT,C,C</code></pre>
<h3 id="running-cert-fix">Running <code>cert-fix</code></h3>
<p>Let’s look at the <code>cert-fix</code> command options:</p>
<pre><code>[root@f29-0 ra-nssdb]# pki-server cert-fix --help
Usage: pki-server cert-fix [OPTIONS]

      --cert &lt;Cert ID&gt;            Fix specified system cert (default: all certs).
  -i, --instance &lt;instance ID&gt;    Instance ID (default: pki-tomcat).
  -d &lt;NSS database&gt;               NSS database location (default: ~/.dogtag/nssdb)
  -c &lt;NSS DB password&gt;            NSS database password
  -C &lt;path&gt;                       Input file containing the password for the NSS database.
  -n &lt;nickname&gt;                   Client certificate nickname
  -v, --verbose                   Run in verbose mode.
      --debug                     Run in debug mode.
      --help                      Show help message.</code></pre>
<p>It’s not a good idea to put passphrases on the command line in the clear, so let’s write the NSSDB passphrase to a file:</p>
<pre><code>[root@f29-0 ra-nssdb]# cat &gt; pwdfile.txt
XXXXXXXX
^D</code></pre>
<p>Finally, I was ready to execute <code>cert-fix</code>:</p>
<pre><code>[root@f29-0 ra-nssdb]# pki-server cert-fix \
    -d . -C pwdfile.txt -n ra-agent \
    --cert sslserver --cert ca_ocsp_signing \
    --verbose</code></pre>
<p>Running with <code>--verbose</code> causes <code>INFO</code> and higher-level log messages to be printed to the terminal. Running with <code>--debug</code> includes <code>DEBUG</code> messages. If neither of these is used, <em>nothing</em> is output (unless there’s an error). So I recommend running with <code>--verbose</code>.</p>
<p>So, what happened? Unfortunately I ran into several issues.</p>
<h4 id="ds-not-running">389 DS not running</h4>
<p>The first issue was trivial, but likely to occur if you have to <code>cert-fix</code> a FreeIPA deployment. The <code>ipactl [re]start</code> command will shut down <em>every</em> component if <em>any</em> component failed to start. Dogtag didn’t start, therefore <code>ipactl</code> shut down 389 DS too. As a consequence, Dogtag failed to initialise after <code>cert-fix</code> started it, and the command failed.</p>
<p>So, before running <code>cert-fix</code>, make sure LDAP is working properly. To start it, use <code>systemctl</code> instead of <code>ipactl</code>:</p>
<pre><code># systemctl start dirsrv@YOUR-REALM</code></pre>
<h4 id="connection-refused">Connection refused</h4>
<p>One issue I encountered was that a slow startup of Dogtag caused failure of the tool. <code>cert-fix</code> does not wait for Dogtag to start up properly. It just ploughs ahead—only to encounter <code>ConnectionRefusedError</code>.</p>
<p>I worked around this—temporarily—by adding a sleep after <code>cert-fix</code> starts Dogtag. A proper fix will require a change to the code. <code>cert-fix</code> should perform a server status check, retrying until it succeeds or times out.</p>
<h4 id="tls-handshake-failure">TLS handshake failure</h4>
<p>The next error I encountered was a TLS handshake failure:</p>
<pre><code>urllib3.exceptions.MaxRetryError:
  HTTPSConnectionPool(host=&#39;f29-0.ipa.local&#39;, port=8443): Max retries
  exceeded with url: /ca/rest/certrequests/profiles/caManualRenewal
  (Caused by SSLError(SSLError(185073780, &#39;[X 509: KEY_VALUES_MISMATCH]
  key values mismatch (_ssl.c:3841)&#39;)))</code></pre>
<p>I haven’t worked out yet what is causing this surprising error. But I wasn’t the first to encounter it. A <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1669257#c10">comment in the Bugzilla ticket</a> indicated that the workaround was to <em>remove</em> the IPA CA certificate from the client NSSDB. This I did:</p>
<pre><code>[root@f29-0 ra-nssdb]# certutil -d . -D \
    -n &quot;Certificate Authority - IPA.LOCAL 201902271325&quot;</code></pre>
<p>After this, my next attempt at running <code>cert-fix</code> succeeded.</p>
<h3 id="results">Results</h3>
<p>Looking at the previously expired target certificates, observe that the certificates have been updated. They have new serial numbers, and expire in 15 months:</p>
<pre><code>[root@f29-0 ra-nssdb]# certutil -d /etc/pki/pki-tomcat/alias \
    -L -n &#39;Server-Cert cert-pki-ca&#39; | egrep &quot;Serial|Not After&quot;
      Serial Number: 12 (0xc)
          Not After : Wed May 27 12:45:25 2020

[root@f29-0 ra-nssdb]# certutil -d /etc/pki/pki-tomcat/alias \
    -L -n &#39;ocspSigningCert cert-pki-ca&#39; | egrep &quot;Serial|Not After&quot;
      Serial Number: 13 (0xd)
          Not After : Wed May 27 12:45:28 2020</code></pre>
<p>Looking at the output of <code>getcert list</code> for the target certificates, we see that Certmonger has <em>not</em> picked these up (some lines removed):</p>
<pre><code>[root@f29-0 ra-nssdb]# getcert list -i 20190227033149
Number of certificates and requests being tracked: 9.
Request ID &#39;20190227033149&#39;:
   status: CA_UNREACHABLE
   ca-error: Internal error
   stuck: no
   CA: dogtag-ipa-ca-renew-agent
   issuer: CN=Certificate Authority,O=IPA.LOCAL 201902271325
   subject: CN=OCSP Subsystem,O=IPA.LOCAL 201902271325
   expires: 2019-02-27 14:45:24 AEDT
   eku: id-kp-OCSPSigning

[root@f29-0 ra-nssdb]# getcert list -i 20190227033152
Number of certificates and requests being tracked: 9.
Request ID &#39;20190227033152&#39;:
   status: CA_UNREACHABLE
   ca-error: Internal error
   stuck: no
   CA: dogtag-ipa-ca-renew-agent
   issuer: CN=Certificate Authority,O=IPA.LOCAL 201902271325
   subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201902271325
   expires: 2019-02-27 14:45:24 AEDT
   dns: f29-0.ipa.local
   key usage: digitalSignature,keyEncipherment,dataEncipherment
   eku: id-kp-serverAuth</code></pre>
<p>Restarting Certmonger (<code>systemctl restart certmonger</code>) resolved the discrepancy.</p>
<p>Finally, <code>ipactl restart</code> puts everything back online. <code>cert-fix</code> has saved the day!</p>
<pre><code>[root@f29-0 ra-nssdb]# ipactl restart
Restarting Directory Service
Starting krb5kdc Service
Starting kadmin Service
Starting httpd Service
Starting ipa-custodia Service
Starting pki-tomcatd Service
Starting ipa-otpd Service
ipa: INFO: The ipactl command was successful</code></pre>
<h2 id="issues-and-caveats">Issues and caveats</h2>
<p>Besides the issues already covered, there are several scenarios that <code>cert-fix</code> cannot handle.</p>
<h3 id="expired-ca-certificate">Expired CA certificate</h3>
<p>Due to the the long validity period of a typical CA certificate, the assumption that the CA certificate is valid is the safest assumption made by <code>cert-fix</code>. But it is not a safe assumption.</p>
<p>The most common way this assumption is violated is with externally-signed CA certificates. For example, the FreeIPA CA in your organisation is signed by Active Directory CA, with a validity period of two years. Things get overlooked and suddenly, your FreeIPA CA is expired. It may take some time for the upstream CA administrators to issue a new certificate. In the meantime, you want to get your FreeIPA/Dogtag CA back up.</p>
<p>Right now <code>cert-fix</code> doesn’t handle this scenario. I think it should. As far as I can tell, this should be straightforward to support. Unlike the next few issues…</p>
<h3 id="agent-certificate-expiry">Agent certificate expiry</h3>
<p>This concerns the assumption that you have a valid agent certificate. Dogtag requires authentication to perform privilieged operations like certificate issuance. Also, the authenticated user must be included in audit events. <code>cert-fix</code> <em>must</em> issue certificates properly (with limiited temporary fudging tolerated for operational efficacy), therefore there <em>must</em> be an agent credential. And if your agent credential is a certificate, it <em>must</em> be valid. So if your agent certificate is expired, it’s Catch-22. That is why the tool, as currently implemented, must assume you have a valid, non-expired agent certificate.</p>
<p>In some deployments the agent certificate is renewed on a different cadence from subsystem certificates. In that case, this scenario is less like to occur—but still entirely possible! The assumption is bad.</p>
<p>In my judgement it is fairly important to find a workaround for this. One idea could be to talk directly to LDAP and set a randomly-generated password on an agent account, and use that to authenticate. After the tool exits, the passphrase is forgotten. This approach means <code>cert-fix</code> needs a credential and privileges to perform those operations in LDAP.</p>
<p>Speaking of LDAP…</p>
<h3 id="ds-certificate-authentication">389 DS certificate authentication</h3>
<p>In FreeIPA deployments, Dogtag is configured to use the subsystem certificate to bind (authenticate) to the LDAP server. If the subsystem certificate is expired, 389 DS will reject the certificate; the connection fails and and Dogtag cannot start.</p>
<p>A workaround for this may be to temporarily reconfigure Dogtag to use a password to authenticate to LDAP. Then after the new subsystem certificate was issued, it must be added to the <code>pkidbuser</code> entry in LDAP, and certificate authentication reinstated.</p>
<p>This is not a FreeIPA-specific consideration. Using TLS client authentication to bind to LDAP is a supported configuration in Dogtag / RHCS. So we should probably support it in <code>cert-fix</code> too, somehow, since the point of the tool is to avoid complex manual procedures in recovering from expired system certificates.</p>
<h3 id="ds-service-certificate-expiry">389 DS service certificate expiry</h3>
<p>You know the tune by now… if this certificate is expired, Dogtag can’t talk to LDAP and can’t start, therefore a new LDAP certificate can’t be issued.</p>
<p>Issuing a temporary certificate with the same serial number may be the best way forward here, like what we do for the Dogtag HTTPS certificate.</p>
<h3 id="re-keying">Re-keying</h3>
<p>…is not supported. But it is a possible future enhancement</p>
<h3 id="serial-number-reuse">Serial number reuse</h3>
<p>Re-using a serial number is prohibited by the X.509 standard. Although the temporary re-issued HTTPS certificate is supposed to be temporary, what if it did leak out? For example, another client that contacted Dogtag while that certificate is in use could log it to a Certificate Transparency log (not a public one, unless your Dogtag CA is chained to a publicly trusted CA). If this occurred, there would be a record that the CA had misbehaved.</p>
<p>What are the ramifications? If this happened in the public PKI, the offending CA would <em>at best</em> get a harsh and very public admonishment, and be put on notice. But trust store vendors might just straight up wash their hands of you and yank trust.</p>
<p>In a private PKI is it such a big deal? Given our use case—the same subject names are used—probably not. But I leave it as an open topic to ponder how this might backfire.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post I introduced the <code>pki-server cert-fix</code> subcommand. The purpose of this tool is to simplify and speed up recovery when Dogtag system certificates have expired.</p>
<p>It does what it says on the tin, with a few rough edges and, right now, a lot of caveats. The fundamentals are very good, but I think we need to address number of these caveats for <code>cert-fix</code> to be generally useful, especially in a FreeIPA context. Based on my early experiences and investigation, my suggested priorities are:</p>
<ol>
<li>Workaround for when the agent certificate is expired. This can affect every kind of deployment and the reliance on a valid agent certificate is a significant limitation.</li>
<li>Workaround for expired subsystem certificate when TLS client authentication is used to bind to LDAP. This affects all FreeIPA deployments (standalone Dogtag deployments less commonly).</li>
<li>Support renewing the CA certificate in <code>cert-fix</code>. A degree of sanity checking or confirmation may be reasonable (e.g. it must be explicitly listed on the CLI as a <code>--cert</code> option).</li>
<li>Investigate ways to handle expired LDAP certificate, if issued by Dogtag. In some deployments, including some FreeIPA deployments, the LDAP certificate is not issued by Dogtag, so the risk is not universal.</li>
</ol>
<p>In writing this post I by no means wish to diminish Dinesh’s work. On the contrary, I’m impressed with what the tool already can do! And, mea culpa, I have taken far too long to test this tool and evaluate it in a FreeIPA setting. Now that I have a clearer picture, I see that I will be very busy making the tool more capable and ready for action in FreeIPA scenarios.</p>]]></summary>
</entry>
<entry>
    <title>IP address SAN support in FreeIPA</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-02-18-freeipa-san-ip.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-02-18-freeipa-san-ip.html</id>
    <published>2019-02-18T00:00:00Z</published>
    <updated>2019-02-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="ip-address-san-support-in-freeipa">IP address SAN support in FreeIPA</h1>
<p>The X.509 <em>Subject Alternative Name (SAN)</em> certificate extension carries subject names that cannot (or cannot easily) be expressed in the Subject Distinguished Name field. The extension supports various name types, including DNS names (the most common), IP addresses, email addresses (for users) and Kerberos principal names, among others.</p>
<p>When issuing a certificate, FreeIPA has to validate that requested SAN name values match the principal to whom the certificate is being issued. There has long been support for DNS names, Kerberos and Microsoft principal names, and email addresses. Over the years we have received many requests to support IP address SAN names. And now we are finally <a href="https://pagure.io/freeipa/issue/7451">adding support</a>!</p>
<p>In this post I will explain the context and history of this feature, and demonstrate how to use it. At time of writing the work is <a href="https://github.com/freeipa/freeipa/pull/1843">not yet merged</a>, but substantive changes are not expected.</p>
<h2 id="acknowledgement">Acknowledgement</h2>
<p>First and foremost, I must thank <strong>Ian Pilcher</strong> who drove this work. DNS name validation is tricky, but Ian proposed a regime that was acceptable to the FreeIPA team from a philosophical and security standpoint. Then he cut the initial patch for the feature. The work was of a high quality; my subsequent changes and enhancements were minor. Above all, Ian and others had great patience as the pull request sat in limbo for nearly a year! Thank you Ian.</p>
<h2 id="ip-address-validation">IP address validation</h2>
<p>There is a reason we kicked the SAN IP address support can down the road for so long. Unlike some name types, validating IP addresses is far from straightforward.</p>
<p>Let’s first consider the already-supported name types. FreeIPA is an <em>identity management system</em>. It <em>knows</em> the various identities (principal name, email address, hostname) of the subjects/principals it knows about. Validation of these name types reduces to the question <em>“does this name belong to the subject principal object?”</em></p>
<p>For IP addresses is not so simple. There are several complicating factors:</p>
<ul>
<li>FreeIPA <em>can</em> manage DNS entries, but it doesn’t have to. If FreeIPA is not a source of authoritative DNS information, should it trust information from external resolvers? Only with DNSSEC?</li>
<li>There may be multiple, conflicting sources of DNS records. The DNS <em>view</em> presented to FreeIPA clients may differ from that seen by other clients. The FreeIPA DNS may “shadow” public (or other) DNS records.</li>
<li>For validation, what should be the treatment of forward (<code>A</code> / <code>AAAA</code>) and reverse (<code>PTR</code>) records pertaining to the names involved?</li>
<li>Should <code>CNAME</code> records be followed? How many times?</li>
<li>The issued certificate may be used in or presented to clients in environments with a different DNS view from the environment in which validation was performed.</li>
<li>Does the request have to come from, or does the requesting entity have to prove control of, the IP address(es) requested for inclusion in the certificate?</li>
<li>IP addresses often change and a reassigned much more often than the typical lifetime of a certificate.</li>
<li>If you query external DNS systems, how do you handle failures or slowness?</li>
<li>The need to mitigate DNS or BGP poisoning attacks</li>
</ul>
<p>Taking these factors into account, it is plain to see why we put this feature off for so long. It is just hard to determine what the correct behaviour should be. Nevertheless use cases exist so the feature request is legitimate. The difference with <span class="title-ref">Ian's RFE</span> was that he proposed a strict validation regime that only uses data defined in FreeIPA. It is a fair assumption that the data managed by a FreeIPA instance is <em>trustworthy</em>. That assumption, combined with some sanity checks, gives the validation requirements:</p>
<ol type="1">
<li>Only FreeIPA-managed DNS records are considered. There is no communication with external DNS resolvers.</li>
<li>For each IP address in the SAN, there is a DNS name in the SAN that resolves to it. (As an implementation decision, we permit one level of CNAME indirection).</li>
<li>For each IP address in the SAN, there is a valid PTR (reverse DNS) record.</li>
<li>SAN IP addresses are only supported for host and service principals.</li>
</ol>
<p>Requirement <strong>1</strong> avoids dealing with any conflicts or communication issues with external resolvers. Requirements <strong>2</strong> and <strong>3</strong> together enforce a tight association between the subject principal (every DNS name is verified to belong to it) and the IP address (through forward and reverse resolution to the DNS name(s)).</p>
<h3 id="caveats-and-limitations">Caveats and limitations</h3>
<p>FreeIPA’s SAN IP address validation regime leads to the following caveats and limitations:</p>
<ul>
<li>The FreeIPA DNS component must be used. (It can be enabled during installation, or at any time after installation.)</li>
<li>Forward and reverse records of addresses to be included in certificates must be added and maintained.</li>
<li>SAN IP addresses must be accompanied by at least one DNS name. Requests with <em>only</em> IP addresses will be rejected.</li>
</ul>
<p>SAN IP address names in general have some limitations, too:</p>
<ul>
<li>The addresses in the certificate were correct at validation time, but might have changed. The only mitigations are to use short-lived certificates, or revoke certificates if DNS changes render them invalid. There is no detection or automation to assist with that.</li>
<li>The certificate could be misused by services in other networks with the same IP address. A well-behaved client would still have to trust the FreeIPA CA in order for this impersonation attack to work.</li>
</ul>
<h2 id="comparison-with-the-public-pki">Comparison with the public PKI</h2>
<p>SAN IP address names are supported by browsers. The CA/Browser Forum’s <a href="https://cabforum.org/baseline-requirements-documents/">Baseline Requirements</a> permit publicly-trusted CAs to issue end-entity certificates with SAN IP address values. CAs have to verify that the applicant controls (or has been granted the right to use) the IP address. There are several acceptable verification methods:</p>
<ol type="1">
<li>The applicant make some agreed-upon change to a network resource at the IP address in question;</li>
<li>Consulting IANA or regional NIC assignment information;</li>
<li>Performing reverse lookup then verifying control over the DNS name.</li>
</ol>
<p>The IETF <em>Automated Certificate Management Environment (ACME)</em> working group has an <a href="https://tools.ietf.org/html/draft-ietf-acme-ip">Internet-Draft for automated IP address validation</a> in the ACME protocol. It defines an automated approach to method <strong>1</strong> above. SAN IP addresses are <a href="https://community.letsencrypt.org/t/certificate-for-public-ip-without-domain-name/6082/91">not yet supported</a> by the most popular ACME CA, <em>Let’s Encrypt</em> (and might never be).</p>
<p>Depending on an organisation’s security goals, the verification methods mentioned above may or may not be appropriate for enterprise use (i.e. behind the firewall). Likewise, the decision about whether a particular kind of validation could or should be automated might have different answers for different organisations. It is not really a question of technical constraints; rather, one of philosophy and security doctrine. When it comes to certificate request validation, the public PKI and FreeIPA are asking different questions:</p>
<ul>
<li>FreeIPA asks: <em>does the indicated subject principal own the requested names?</em></li>
<li>The public PKI asks: <em>does the (potentially anonymous) applicant control the names they’re requestion?</em></li>
</ul>
<p>In a few words, it’s <em>ownership</em> versus <em>control</em>. In the future it might be possible for a FreeIPA CA to ask the latter question and issue certificates (or not) accordingly. But that isn’t the focus right now.</p>
<h2 id="demonstration">Demonstration</h2>
<h3 id="preliminaries">Preliminaries</h3>
<p>The scene is set. Let’s see this feature in action! The domain of my FreeIPA deployment is <code>ipa.local</code>. I will add a host called <code>iptest.example.com</code>, with the IP address <code>192.168.2.1</code>. The first step is to add the reverse zone for this IP address:</p>
<pre><code>% ipa dnszone-add --name-from-ip 192.168.2.1
Zone name [2.168.192.in-addr.arpa.]:
  Zone name: 2.168.192.in-addr.arpa.
  Active zone: TRUE
  Authoritative nameserver: f29-0.ipa.local.
  Administrator e-mail address: hostmaster
  SOA serial: 1550454790
  SOA refresh: 3600
  SOA retry: 900
  SOA expire: 1209600
  SOA minimum: 3600
  BIND update policy: grant IPA.LOCAL krb5-subdomain 2.168.192.in-addr.arpa. PTR;
  Dynamic update: FALSE
  Allow query: any;
  Allow transfer: none;</code></pre>
<p>If the reverse zone for the IP address already exists, there would be no need to do this first step.</p>
<p>Next I add the host entry. Supplying <code>--ip-address</code> causes forward and reverse records to be added for the supplied address (assuming the relevant zones are managed by FreeIPA):</p>
<pre><code>% ipa host-add iptest.ipa.local \
      --ip-address 192.168.2.1
-----------------------------
Added host &quot;iptest.ipa.local&quot;
-----------------------------
  Host name: iptest.ipa.local
  Principal name: host/iptest.ipa.local@IPA.LOCAL
  Principal alias: host/iptest.ipa.local@IPA.LOCAL
  Password: False
  Keytab: False
  Managed by: iptest.ipa.local</code></pre>
<h3 id="csr-generation">CSR generation</h3>
<p>There are several options for creating a certificate signing request (CSR) with IP addresses in the SAN extension.</p>
<ul>
<li>Lots of devices (routers, middleboxes, etc) generate CSRs containing their IP address. This is the significant driving use case for this feature, but there’s no point going into details because every device is different.</li>
<li>The <a href="https://pagure.io/certmonger">Certmonger</a> utility makes it easy to add DNS names and IP addresses to a CSR, via command line arguments. Several other name types are also supported. See <code>getcert-request(1)</code> for details.</li>
<li>OpenSSL requires a config file to specify SAN values for inclusing in CSRs and certificates. See <code>req(1)</code> and <code>x509v3_config(5)</code> for details.</li>
<li>The NSS <code>certutil(1)</code> command provides the <code>--extSAN</code> option for specifying SAN names, including DNS names and IP addresses.</li>
</ul>
<p>For this demonstration I use NSS and <code>certutil</code>. First I initialise a new certificate database:</p>
<pre><code>% mkdir nssdb ; cd nssdb ; certutil -d . -N
Enter a password which will be used to encrypt your keys.
The password should be at least 8 characters long,
and should contain at least one non-alphabetic character.

Enter new password:
Re-enter password:</code></pre>
<p>Next, I generate a key and create CSR with the desired names in the SAN extension. We do not specify a key type or size we get the default (2048-bit RSA).</p>
<pre><code>% certutil -d . -R -a -o ip.csr \
      -s CN=iptest.ipa.local \
      --extSAN dns:iptest.ipa.local,ip:192.168.2.1
Enter Password or Pin for &quot;NSS Certificate DB&quot;:

A random seed must be generated that will be used in the
creation of your key.  One of the easiest ways to create a
random seed is to use the timing of keystrokes on a keyboard.

To begin, type keys on the keyboard until this progress meter
is full.  DO NOT USE THE AUTOREPEAT FUNCTION ON YOUR KEYBOARD!


Continue typing until the progress meter is full:

|************************************************************|

Finished.  Press enter to continue:


Generating key.  This may take a few moments...</code></pre>
<p>The output file <code>ip.csr</code> contains the generated CSR. Let’s use OpenSSL to pretty-print it:</p>
<pre><code>% openssl req -text &lt; ip.csr
Certificate Request:
    Data:
        Version: 1 (0x0)
        Subject: CN = iptest.ipa.local
        Subject Public Key Info:
            &lt; elided &gt;
        Attributes:
        Requested Extensions:
            X509v3 Subject Alternative Name:
                DNS:iptest.ipa.local, IP Address:192.168.2.1
    Signature Algorithm: sha256WithRSAEncryption
         &lt; elided &gt;</code></pre>
<p>It all looks correct.</p>
<h3 id="issuing-the-certificate">Issuing the certificate</h3>
<p>I use the <code>ipa cert-request</code> command to request a certificate. The host <code>iptest.ipa.local</code> is the subject principal. The default profile is appropriate.</p>
<pre><code>% ipa cert-request ip.csr \
      --principal host/iptest.ipa.local \
      --certificate-out ip.pem
  Issuing CA: ipa
  Certificate: &lt; elided &gt;
  Subject: CN=iptest.ipa.local,O=IPA.LOCAL 201902181108
  Subject DNS name: iptest.ipa.local
  Issuer: CN=Certificate Authority,O=IPA.LOCAL 201902181108
  Not Before: Mon Feb 18 03:24:48 2019 UTC
  Not After: Thu Feb 18 03:24:48 2021 UTC
  Serial number: 10
  Serial number (hex): 0xA</code></pre>
<p>The command succeeded. As requested, the issued certificate has been written to <code>ip.pem</code>. Again we’ll use OpenSSL to inspect it:</p>
<pre><code>% openssl x509 -text &lt; ip.pem
Certificate:                                                                                                                                                                                               [42/694]
    Data:
        Version: 3 (0x2)
        Serial Number: 10 (0xa)
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: O = IPA.LOCAL 201902181108, CN = Certificate Authority
        Validity
            Not Before: Feb 18 03:24:48 2019 GMT
            Not After : Feb 18 03:24:48 2021 GMT
        Subject: O = IPA.LOCAL 201902181108, CN = iptest.ipa.local
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (2048 bit)
                Modulus:
                    &lt; elided &gt;
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Authority Key Identifier:
                keyid:70:C0:D3:02:EA:88:4A:4D:34:4C:84:CD:45:5F:64:8A:0B:59:54:71

            Authority Information Access:
                OCSP - URI:http://ipa-ca.ipa.local/ca/ocsp

            X509v3 Key Usage: critical
                Digital Signature, Non Repudiation, Key Encipherment, Data Encipherment
            X509v3 Extended Key Usage:
                TLS Web Server Authentication, TLS Web Client Authentication
            X509v3 CRL Distribution Points:

                Full Name:
                  URI:http://ipa-ca.ipa.local/ipa/crl/MasterCRL.bin
                CRL Issuer:
                  DirName:O = ipaca, CN = Certificate Authority

            X509v3 Subject Key Identifier:
                3D:A9:7E:E3:05:D6:03:6A:9E:85:BB:72:69:E1:E7:11:92:6F:29:08
            X509v3 Subject Alternative Name:
                DNS:iptest.ipa.local, IP Address:192.168.2.1
    Signature Algorithm: sha256WithRSAEncryption
         &lt; elided &gt;</code></pre>
<p>We can see that the Subject Alternative Name extension is present, and included the expected values.</p>
<h3 id="error-scenarios">Error scenarios</h3>
<p>It’s nice to see that we can get a certificate with IP address names. But it’s more important to know that we <em>cannot</em> get an IP address certificate when the validation requirements are not satisfied. I’ll run through a number of scenarios and show the results (without showing the whole procedure, which would repeat a lot of information).</p>
<p>If we omit the DNS name from the SAN extension, there is nothing linking the IP address to the subject principal and the request will be rejected. Note that the Subject DN Common Name (CN) attribute is ignored for the purposes of SAN IP address validation. The CSR was generated using <code>--extSAN ip:192.168.2.1</code>.</p>
<pre><code>% ipa cert-request ip-bad.csr --principal host/iptest.ipa.local
ipa: ERROR: invalid &#39;csr&#39;: IP address in
  subjectAltName (192.168.2.1) unreachable from DNS names</code></pre>
<p>If we reinstate the DNS name but add an extra IP address that does not relate to the hostname, the request gets rejected. The CSR was generated using <code>--extSAN dns:iptest.ipa.local,ip:192.168.2.1,ip:192.168.2.2</code>.</p>
<pre><code>% ipa cert-request ip-bad.csr --principal host/iptest.ipa.local
ipa: ERROR: invalid &#39;csr&#39;: IP address in
  subjectAltName (192.168.2.2) unreachable from DNS names</code></pre>
<p>Requesting a certificate for a user principal fails. The CSR has Subject DN <code>CN=alice</code> and the SAN extension contain an IP address. The user principal <code>alice</code> does exist.</p>
<pre><code>% ipa cert-request ip-bad.csr --principal alice
ipa: ERROR: invalid &#39;csr&#39;: subject alt name type
  IPAddress is forbidden for user principals</code></pre>
<p>Let’s return to our original, working CSR. If we alter the relevant PTR record so that it no longer points a DNS name in the SAN (or the canonical name thereof), the request will fail:</p>
<pre><code>% ipa dnsrecord-mod 2.168.192.in-addr.arpa. 1 \
      --ptr-rec f29-0.ipa.local.
  Record name: 1
  PTR record: f29-0.ipa.local.

% ipa cert-request ip.csr --principal host/iptest.ipa.local
ipa: ERROR: invalid &#39;csr&#39;: IP address in
  subjectAltName (192.168.2.1) does not match A/AAAA records</code></pre>
<p>Similarly if we delete the PTR record, the request fails (with a different message):</p>
<pre><code>% ipa dnsrecord-del 2.168.192.in-addr.arpa. 1 \
      --ptr-rec f29-0.ipa.local.
------------------
Deleted record &quot;1&quot;
------------------

% ipa cert-request ip.csr --principal host/iptest.ipa.local
ipa: ERROR: invalid &#39;csr&#39;: IP address in
  subjectAltName (192.168.2.1) does not have PTR record</code></pre>
<h3 id="ipv6">IPv6</h3>
<p>Assuming the relevant reverse zone is managed by FreeIPA and contains the correct records, FreeIPA can issue certificates with IPv6 names. First I have to add the relevant zones and records. I’m using the machine’s link-local address but the commands will be similar for other IPv6 addresses.</p>
<pre><code>% ipa dnsrecord-mod ipa.local. iptest \
      --a-rec=192.168.2.1 \
      --aaaa-rec=fe80::8f18:bdab:4299:95fa
  Record name: iptest
  A record: 192.168.2.1
  AAAA record: fe80::8f18:bdab:4299:95fa

% ipa dnszone-add \
      --name-from-ip fe80::8f18:bdab:4299:95fa
Zone name [0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f.ip6.arpa.]:
  Zone name: 0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f.ip6.arpa.
  Active zone: TRUE
  Authoritative nameserver: f29-0.ipa.local.
  Administrator e-mail address: hostmaster
  SOA serial: 1550468242
  SOA refresh: 3600
  SOA retry: 900
  SOA expire: 1209600
  SOA minimum: 3600
  BIND update policy: grant IPA.LOCAL krb5-subdomain 0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f.ip6.arpa. PTR;
  Dynamic update: FALSE
  Allow query: any;
  Allow transfer: none;

% ipa dnsrecord-add \
      0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f.ip6.arpa. \
      a.f.5.9.9.9.2.4.b.a.d.b.8.1.f.8 \
      --ptr-rec iptest.ipa.local.
  Record name: a.f.5.9.9.9.2.4.b.a.d.b.8.1.f.8
  PTR record: iptest.ipa.local.</code></pre>
<p>With these in place I’ll generate the CSR and issue the certificate. (This time I’ve used the <code>-f</code> and <code>-z</code> options to reduce user interaction.)</p>
<pre><code>% certutil -d . -f pwdfile.txt \
    -z &lt;(dd if=/dev/random bs=2048 count=1 status=none) \
    -R -a -o ip.csr -s CN=iptest.ipa.local \
    --extSAN dns:iptest.ipa.local,ip:fe80::8f18:bdab:4299:95fa


Generating key.  This may take a few moments...

% ipa cert-request ip.csr \
      --principal host/iptest.ipa.local \
      --certificate-out ip.pem
  Issuing CA: ipa
  Certificate: &lt; elided &gt;
  Subject: CN=iptest.ipa.local,O=IPA.LOCAL 201902181108
  Subject DNS name: iptest.ipa.local
  Issuer: CN=Certificate Authority,O=IPA.LOCAL 201902181108
  Not Before: Mon Feb 18 05:49:01 2019 UTC
  Not After: Thu Feb 18 05:49:01 2021 UTC
  Serial number: 12
  Serial number (hex): 0xC</code></pre>
<p>The issuance succeeded. Observe that the IPv6 address is present in the certificate:</p>
<pre><code>% openssl x509 -text &lt; ip.pem | grep -A 1 &quot;Subject Alt&quot;
    X509v3 Subject Alternative Name:
      DNS:iptest.ipa.local, IP Address:FE80:0:0:0:8F18:BDAB:4299:95FA</code></pre>
<p>Of course, it is possible to issue certificates with multiple IP addresses, including a mix of IPv4 and IPv6. Assuming all the necessary DNS records exist, with</p>
<pre><code>--extSAN ip:fe80::8f18:bdab:4299:95fa,ip:192.168.2.1,dns:iptest.ipa.local</code></pre>
<p>The resulting certificate will have the SAN:</p>
<pre><code>IP Address:FE80:0:0:0:8F18:BDAB:4299:95FA, IP Address:192.168.2.1, DNS:iptest.ipa.local</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>In this post I discussed the challenges of verifying IP addresses for inclusion in X.509 certificates. I discussed the approach we are taking in FreeIPA to finally support this, including its caveats and limitations. For comparison, I outlined how IP address verification is done by CAs on the open internet.</p>
<p>I then demonstrated how the feature will work in FreeIPA. Importantly, I showed (though not <em>exhaustively</em>), that FreeIPA refuses to issue the certificate if the verification requirements are not met. It is a bit hard to demonstrate, from a user perspective, that we only consult FreeIPA’s own DNS records and never consult another DNS server. But hey, <a href="https://github.com/freeipa/freeipa/pull/1843">the code is open source</a> so you can satisfy yourself that the behaviour fulfils the requirements (or leave a review / file an issue if you find that it does not!)</p>
<p>When will the feature land in <code>master</code>? Before the feature can be merged, I still need to write acceptance tests and have the feature reviewed by another FreeIPA developer. I am hoping to finish the work this week.</p>
<p>As a final remark, I must again acknowledge Ian Pilcher’s significant contribution. Were it not for him, it is likely that this longstanding RFE would still be in our <em>“too hard”</em> basket. Ian, thank you for your patience and I hope that your efforts are rewarded very soon with the feature finally being merged.</p>]]></summary>
</entry>

</feed>
