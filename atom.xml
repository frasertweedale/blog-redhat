<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Fraser's IdM Blog</title>
    <link href="https://frasertweedale.github.io/blog-redhat/atom.xml" rel="self" />
    <link href="https://frasertweedale.github.io/blog-redhat" />
    <id>https://frasertweedale.github.io/blog-redhat/atom.xml</id>
    <author>
        <name>Fraser Tweedale</name>
        <email>frase@frase.id.au</email>
    </author>
    <updated>2019-05-24T00:00:00Z</updated>
    <entry>
    <title>Fixing expired system certificates in FreeIPA</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-05-24-ipa-cert-fix.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-05-24-ipa-cert-fix.html</id>
    <published>2019-05-24T00:00:00Z</published>
    <updated>2019-05-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="fixing-expired-system-certificates-in-freeipa">Fixing expired system certificates in FreeIPA</h1>
<p>In previous posts I outlined and demonstrated the <code>pki-server cert-fix</code> tool. This tool is part of Dogtag PKI. I also discussed what additional functionality would be needed to successfully use this tool in a FreeIPA environment.</p>
<p>This post details the result of the effort to make <code>cert-fix</code> useful for FreeIPA administrators. We implemented a wrapper program, <code>ipa-cert-fix</code>, which performs FreeIPA-specific steps in addition to executing <code>pki-server cert-fix</code>.</p>
<h2 id="what-does-ipa-cert-fix-do">What does <code>ipa-cert-fix</code> do?</h2>
<p>In brief, the steps performed by <code>ipa-cert-fix</code> are:</p>
<ol type="1">
<li>Inspect deployment to work out which certificates need renewing. This includes both Dogtag system certificates, FreeIPA-specific certificates (HTTP, LDAP, KDC and IPA RA).</li>
<li>Print intentions and await operator confirmation.</li>
<li>Invoke <code>pki-server cert-fix</code> to renew expired certificates, including FreeIPA-specific certificates.</li>
<li>Install renewed FreeIPA-specific certificates to their respective locations.</li>
<li>If any shared certificates were renewed (Dogtag system certificates excluding HTTP, and IPA RA), import them to the LDAP <code>ca_renewal</code> subtree and set the <code>caRenewalMaster</code> configuration to be the current server. This allows CA replicas to pick up the renewed shared certificates.</li>
<li>Restart FreeIPA (<code>ipactl restart</code>).</li>
</ol>
<h2 id="demonstration">Demonstration</h2>
<p>For this demonstration I used a deployment with the following characteristics:</p>
<ul>
<li>Two servers, <code>f29-0</code> and <code>f29-1</code>, with CA on both.</li>
<li><code>f29-0</code> is the current <em>CA renewal master</em>.</li>
<li>A KRA instance is installed on <code>f29-1</code>.</li>
<li>The deployment was created on 2019-05-24, so most of the certificates expire on or before 2021-05-24 (the exception being the CA certificate).</li>
</ul>
<p>On both machines I disabled <code>chronyd</code> and put the clock forward 27 months, so that all the certificates (except the IPA CA itself) are expired:</p>
<pre><code>[f29-1] ftweedal% sudo systemctl stop chronyd
[f29-1] ftweedal% date
Fri May 24 12:01:16 AEST 2019
[f29-1] ftweedal% sudo date 082412012021
Tue Aug 24 12:01:00 AEST 2021</code></pre>
<p>After <code>ipactl restart</code> the Dogtag CA did not start, and we cannot communicate with FreeIPA due to the expired HTTP certificate:</p>
<pre><code>[f29-1] ftweedal% sudo ipactl status
Directory Service: RUNNING
krb5kdc Service: RUNNING
kadmin Service: RUNNING
httpd Service: RUNNING
ipa-custodia Service: RUNNING
pki-tomcatd Service: STOPPED
ipa-otpd Service: RUNNING
ipa: INFO: The ipactl command was successful

[f29-1] ftweedal% ipa user-find
ipa: ERROR: cannot connect to &#39;https://f29-1.ipa.local/ipa/json&#39;:
  [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed:
  certificate has expired (_ssl.c:1056)</code></pre>
<h3 id="fixing-the-first-server">Fixing the first server</h3>
<p>I will repair <code>f29-1</code> first, so that we can see why resetting the CA renewal master is an important step performed by <code>ipa-cert-fix</code>.</p>
<p>I ran <code>ipa-cert-fix</code> as <code>root</code>. It analyses the server, then prints a warning and the list of certificates to be renewed, and asks for confirmation:</p>
<pre><code>[f29-1] ftweedal% sudo ipa-cert-fix

                          WARNING

ipa-cert-fix is intended for recovery when expired certificates
prevent the normal operation of FreeIPA.  It should ONLY be used
in such scenarios, and backup of the system, especially certificates
and keys, is STRONGLY RECOMMENDED.


The following certificates will be renewed:

Dogtag sslserver certificate:                                                                                                                                                                                [2/34]
  Subject: CN=f29-1.ipa.local,O=IPA.LOCAL 201905222205                                                                                                                                                             
  Serial:  13
  Expires: 2021-05-12 05:55:47

Dogtag subsystem certificate:
  Subject: CN=CA Subsystem,O=IPA.LOCAL 201905222205
  Serial:  4
  Expires: 2021-05-11 12:07:11

Dogtag ca_ocsp_signing certificate:
  Subject: CN=OCSP Subsystem,O=IPA.LOCAL 201905222205
  Serial:  2
  Expires: 2021-05-11 12:07:11

Dogtag ca_audit_signing certificate:
  Subject: CN=CA Audit,O=IPA.LOCAL 201905222205
  Serial:  5
  Expires: 2021-05-11 12:07:12

Dogtag kra_transport certificate:
  Subject: CN=KRA Transport Certificate,O=IPA.LOCAL 201905222205
  Serial:  268369921
  Expires: 2021-05-12 06:00:10

Dogtag kra_storage certificate:
  Subject: CN=KRA Storage Certificate,O=IPA.LOCAL 201905222205
  Serial:  268369922
  Expires: 2021-05-12 06:00:10

Dogtag kra_audit_signing certificate:
  Subject: CN=KRA Audit,O=IPA.LOCAL 201905222205
  Serial:  268369923
  Expires: 2021-05-12 06:00:11

IPA IPA RA certificate:
  Subject: CN=IPA RA,O=IPA.LOCAL 201905222205
  Serial:  7
  Expires: 2021-05-11 12:07:47

IPA Apache HTTPS certificate:
  Subject: CN=f29-1.ipa.local,O=IPA.LOCAL 201905222205
  Serial:  12
  Expires: 2021-05-23 05:54:11

IPA LDAP certificate:
  Subject: CN=f29-1.ipa.local,O=IPA.LOCAL 201905222205
  Serial:  11
  Expires: 2021-05-23 05:53:58

IPA KDC certificate:
  Subject: CN=f29-1.ipa.local,O=IPA.LOCAL 201905222205
  Serial:  14
  Expires: 2021-05-23 05:57:50

Enter &quot;yes&quot; to proceed:</code></pre>
<p>Observe that the KRA certificates are included (we are on <code>f29-1</code>). I type “yes” and continue. After a few minutes the process has completed:</p>
<pre><code>Proceeding.
Renewed Dogtag sslserver certificate:
  Subject: CN=f29-1.ipa.local,O=IPA.LOCAL 201905222205
  Serial:  268369925
  Expires: 2023-08-14 02:19:33

... (9 certificates elided)

Renewed IPA KDC certificate:
  Subject: CN=f29-1.ipa.local,O=IPA.LOCAL 201905222205
  Serial:  268369935
  Expires: 2023-08-25 02:19:42

Becoming renewal master.
The ipa-cert-fix command was successful</code></pre>
<p>As suggested by the expiry dates, it took about 11 seconds to renew all 11 certifiates. So why did it take so long? The <code>pki-server cert-fix</code> command, which is part of Dogtag and invoked by <code>ipa-cert-fix</code>, restarts the Dogtag instance as its final step. Although a new LDAP certificate was issued, it is not yet been installed in 389’s certificate database. Dogtag fails to start; it cannot talk to LDAP because of the expired certificate, and the restart operation hangs for a while. <code>ipa-cert-fix</code> knows to expect this and ignores the <code>pki-server cert-fix</code> failure when the LDAP certificate needs renewal.</p>
<p><code>ipa-cert-fix</code> also reported that it was setting the renewal master (because shared certificates were renewed). Let’s check the server status and verify the configuration.</p>
<pre><code>[f29-1] ftweedal% sudo ipactl status
Directory Service: RUNNING
krb5kdc Service: RUNNING
kadmin Service: RUNNING
httpd Service: RUNNING
ipa-custodia Service: RUNNING
pki-tomcatd Service: RUNNING
ipa-otpd Service: RUNNING
ipa: INFO: The ipactl command was successful</code></pre>
<p>The server is up and running.</p>
<pre><code>[f29-1] ftweedal% kinit admin
Password for admin@IPA.LOCAL:
Password expired.  You must change it now.
Enter new password:
Enter it again:</code></pre>
<p>Passwords have expired (due to time-travel).</p>
<pre><code>[f29-1] ftweedal% ipa config-show |grep renewal
  IPA CA renewal master: f29-1.ipa.local</code></pre>
<p><code>f29-1</code> has indeed become the renewal master. Oh, and the HTTP and LDAP certifiate have been fixed.</p>
<pre><code>[f29-1] ftweedal% ipa cert-show 1 | grep Subject
  Subject: CN=Certificate Authority,O=IPA.LOCAL 201905222205</code></pre>
<p>And the IPA framework can talk to Dogtag. This proves that the IPA RA and Dogtag HTTPS and subsystem certificates are valid.</p>
<h3 id="fixing-subsequent-servers">Fixing subsequent servers</h3>
<p>Jumping back onto <code>f29-0</code>, let’s look at the Certmonger request statuses:</p>
<pre><code>[f29-0] ftweedal% sudo getcert list \
                  | egrep &#39;^Request|status:|subject:&#39;
Request ID &#39;20190522120745&#39;:
        status: CA_UNREACHABLE
        subject: CN=IPA RA,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120831&#39;:
        status: CA_UNREACHABLE
        subject: CN=CA Audit,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120832&#39;:
        status: CA_UNREACHABLE
        subject: CN=OCSP Subsystem,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120833&#39;:
        status: CA_UNREACHABLE
        subject: CN=CA Subsystem,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120834&#39;:
        status: MONITORING
        subject: CN=Certificate Authority,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120835&#39;:
        status: CA_UNREACHABLE
        subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120903&#39;:
        status: CA_UNREACHABLE
        subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120932&#39;:
        status: CA_UNREACHABLE
        subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120940&#39;:
        status: CA_UNREACHABLE
        subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205</code></pre>
<p>The <code>MONITORING</code> request is the CA certificate. All the other requests are stuck in <code>CA_UNREACHABLE</code>.</p>
<p>The Certmonger tracking requests need to communicate with LDAP to retrieve shared certificates. So we have to <code>ipactl restart</code> with <code>--force</code> to ignore individual service startup failures (Dogtag will fail):</p>
<pre><code>[f29-0] ftweedal% sudo ipactl restart --force
Skipping version check
Starting Directory Service
Starting krb5kdc Service
Starting kadmin Service
Starting httpd Service
Starting ipa-custodia Service
Starting pki-tomcatd Service
Starting ipa-otpd Service
ipa: INFO: The ipactl command was successful

[f29-0] ftweedal% sudo ipactl status
Directory Service: RUNNING
krb5kdc Service: RUNNING
kadmin Service: RUNNING
httpd Service: RUNNING
ipa-custodia Service: RUNNING
pki-tomcatd Service: STOPPED
ipa-otpd Service: RUNNING
ipa: INFO: The ipactl command was successful</code></pre>
<p>Now Certmonger is able to renew the shared certificates by retrieving the new certificate from LDAP. The IPA-managed certificates are also able to be renewed by falling back to requesting them from another CA server (the already repaired <code>f29-1</code>). After a short wait, <code>getcert list</code> shows that all but one of the certificates have been renewed:</p>
<pre><code>[f29-0] ftweedal% sudo getcert list \
                  | egrep &#39;^Request|status:|subject:&#39;
Request ID &#39;20190522120745&#39;:
        status: MONITORING
        subject: CN=IPA RA,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120831&#39;:
        status: MONITORING
        subject: CN=CA Audit,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120832&#39;:
        status: MONITORING
        subject: CN=OCSP Subsystem,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120833&#39;:
        status: MONITORING
        subject: CN=CA Subsystem,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120834&#39;:
        status: MONITORING
        subject: CN=Certificate Authority,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120835&#39;:
        status: CA_UNREACHABLE
        subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120903&#39;:
        status: MONITORING
        subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120932&#39;:
        status: MONITORING
        subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205
Request ID &#39;20190522120940&#39;:
        status: MONITORING
        subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205</code></pre>
<p>The final <code>CA_UNREACHABLE</code> request is the Dogtag HTTP certificate. We can now run <code>ipa-cert-fix</code> on <code>f29-0</code> to repair this certificate:</p>
<pre><code>[f29-0] ftweedal% sudo ipa-cert-fix

                          WARNING

ipa-cert-fix is intended for recovery when expired certificates
prevent the normal operation of FreeIPA.  It should ONLY be used
in such scenarios, and backup of the system, especially certificates
and keys, is STRONGLY RECOMMENDED.


The following certificates will be renewed:

Dogtag sslserver certificate:
  Subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205
  Serial:  3
  Expires: 2021-05-11 12:07:11

Enter &quot;yes&quot; to proceed: yes
Proceeding.
Renewed Dogtag sslserver certificate:
  Subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201905222205
  Serial:  15
  Expires: 2023-08-14 04:25:05

The ipa-cert-fix command was successful</code></pre>
<h3 id="all-done">All done?</h3>
<p>Yep. A subsequent execution of <code>ipa-cert-fix</code> shows that there is nothing to do, and exits:</p>
<pre><code>[f29-0] ftweedal% sudo ipa-cert-fix
Nothing to do.
The ipa-cert-fix command was successful</code></pre>
<h2 id="feature-status">Feature status</h2>
<p>Against the usual procedure for FreeIPA (and Red Hat projects in general), <code>ipa-cert-fix</code> was developed “downstream-first”. It has been merged to the <code>ipa-4-6</code> branch, but there might not even be another upstream release from that branch. But there might be a future RHEL release based on that branch (the savvy reader might infer a high degree of certainty, given we actually bothered to do that…)</p>
<p>In the meantime, work to forward-port the feature to <code>master</code> and newer branches is ongoing. I hope that it will be merged in the next week or so.</p>]]></summary>
</entry>
<entry>
    <title><code>cert-fix</code> redux</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-03-18-cert-fix-redux.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-03-18-cert-fix-redux.html</id>
    <published>2019-03-18T00:00:00Z</published>
    <updated>2019-03-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="cert-fix-redux"><code>cert-fix</code> redux</h1>
<p><a href="2019-02-28-dogtag-cert-fix.html">A few weeks ago I analysed</a> the Dogtag <code>pki-server cert-fix</code> tool, which is intended to assist with recovery in scenarios where expired certificates inhibit Dogtag’s normal operation. Unfortunately, there were some flawed assumptions and feature gaps that limited the usefulness of the tool, especially in FreeIPA contexts.</p>
<p>In this post, I provide an update on changes that are being made to the tool to address those shortcomings.</p>
<h2 id="recap">Recap</h2>
<p>Recapping the shortcomings in brief:</p>
<ol type="1">
<li>When TLS client certificate authentication is used to authenticate to Dogtag (the default for FreeIPA), and expired <code>subsystem</code> certificate causes authentication failure and Dogtag cannot start.</li>
<li>When Dogtag is configured to use TLS or STARTTLS when connecting to the database, an expired LDAP service certificate causes connection failure.</li>
<li><code>cert-fix</code> uses an admin or agent certificate to perform authenticated operations against Dogtag. An expired certificate causes authentication failure, and certificate renewal fails.</li>
<li>Expired CA certificate is not handled. Due to longer validity periods, and externally-signed CA certificates expiring at different times from Dogtag system certificates, this scenario is less common, but it still occurs.</li>
<li>The need to renew non-system certificates. Apart from system certificates, in order for correct operation of Dogtag it may be necessary to renew some other certificates, such as an expired LDAP service certificate, or an expired agent certificate (e.g. <code>IPA RA</code>). <code>cert-fix</code> did not provide a way to do this.</li>
</ol>
<h2 id="resolving-the-ldap-related-issues-issues-1-and-2">Resolving the LDAP-related issues (issues #1 and #2)</h2>
<p><code>cert-fix</code> now switches the deployment to use password authentication to LDAP, over an insecure connection on port 389. The original database configuration is restored when <code>cert-fix</code> finishes.</p>
<p>The <code>subsystem</code> certificate is used by Dogtag to authenticate to LDAP. Switching to password authentication works around the expired <code>subsystem</code> certificate. Furthermore if the <code>subsystem</code> certificate gets renewed, the new certificate gets imported into the <code>pkidbuser</code> LDAP entry so that authentication will work (389 DS requires an exact certificate match in the <code>userCertificate</code> attribute of the user).</p>
<p>If the LDAP service certificate is expired, this procedure works around that but <em>does not renew it</em>. This is problem #3, and is addressed separately.</p>
<p>Switching Dogtag to password authentication to LDAP means resetting the <code>pkidbuser</code> account password. We use the <code>ldappasswd</code> program to do this. The LDAP <em>password modify</em> extended operation requires confientiality (i.e. TLS or STARTTLS); an expired LDAP service certificate inhibits this. Therefore we use LDAPI and autobind. The LDAPI socket is specified via the <code>--ldapi-socket</code> option.</p>
<p>FreeIPA always configures LDAP and <code>root</code> autobind to the <code>cn=Directory Manager</code> LDAP account. For standalone Dogtag installations these may need to be configured before runnning <code>cert-fix</code>.</p>
<h2 id="resolving-expired-agent-certificate-issue-3">Resolving expired agent certificate (issue #3)</h2>
<p>Instead of using the certificate to authenticate the agent, reset the password of the agent account and use that password to authenticate the agent. The password is randomly generated and forgotten after <code>cert-fix</code> terminates.</p>
<p>The agent account to use is now specified via the <code>--agent-uid</code> option. NSSDB-related options for specifying the agent certificate and NSSDB passphrase have been removed.</p>
<h2 id="renewing-other-certificates-issue-5">Renewing other certificates (issue #5)</h2>
<p><code>cert-fix</code> learned the <code>--extra-cert</code> option, which gives the serial number of an extra certificate to renew. The option can be given multiple times to specify multiple certificates. Each certificate gets renewed and output in <code>/etc/pki/&lt;instance-dir&gt;/certs/&lt;serial&gt;-renewed.crt</code>. If a non-existing serial number is specified, an error is printed but processing continues.</p>
<p>This facility allows operators (or wrapper tools) to renew other essential certificates alongside the Dogtag system certificates. Further actions are needed to put those new certificates in the right places. But it is fair, in order to keep to keep the <code>cert-fix</code> tool simple, to put this burden back on the operator. In any case, we intend to write a supplementary tool for FreeIPA that wraps <code>cert-fix</code> and takes care of working out which extra certificates to renew, and putting them in the right places.</p>
<h2 id="new-or-changed-assumptions">New or changed assumptions</h2>
<p>The changes dicsussed above abolish some assumptions that were previously made by <code>cert-fix</code>, and establish some new assumptions.</p>
<p>Absolished:</p>
<ul>
<li>A valid admin certificate is no longer needed</li>
<li>A valid LDAP service certificate is no longer needed</li>
<li>When Dogtag is configured to use certificate authentication to LDAP, a valid subsystem certificate is no longer needed</li>
</ul>
<p>New:</p>
<ul>
<li><code>cert-fix</code> must be run as <code>root</code>.</li>
<li>LDAPI must be configured, with <code>root</code> autobinding to <code>cn=Directory Manager</code> or other account with privileges on <code>o=ipaca</code> subtree, including password reset privileges.</li>
<li>The password of the specified agent account will be reset. If needed, it can be changed back afterwards (manually; successful execution of <code>cert-fix</code> proves that the operator has privileges to do this).</li>
<li>If Dogtag was configured to use TLS certificate authentication to bind to LDAP, the password on the <code>pkidbuser</code> account will be reset. (If password authentication was already used, the password does not get reset).</li>
<li>LDAPI (ldappasswd) and need to be root</li>
</ul>
<h2 id="demo">Demo</h2>
<p>Here I’ll put the full command and command output for an execution of the <code>cert-fix</code> tool, and break it up with commentary. I will renew the <code>subsystem</code> certificate, and additionally the certificate with serial number 29 (which happens to be the LDAP certificate):</p>
<pre><code>[root@f27-1 ~]# pki-server cert-fix \
    --agent-uid admin \
    --ldapi-socket /var/run/slapd-IPA-LOCAL.socket \
    --cert subsystem \
    --extra-cert 29</code></pre>
<p>There is no longer any need to set up an NSSDB with an agent certificate, a considerable UX improvement! An further improvement was to default the log verbosity to <code>INFO</code>, so we can see progress and observe (at a high level) what the <code>cert-fix</code> is doing, without specifying <code>-v</code> / <code>--verbose</code>.</p>
<pre><code>INFO: Loading password config: /etc/pki/pki-tomcat/password.conf
INFO: Fixing the following system certs: [&#39;subsystem&#39;]
INFO: Renewing the following additional certs: [&#39;29&#39;]
SASL/EXTERNAL authentication started
SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth
SASL SSF: 0</code></pre>
<p>Preliminaries. The tool loads information about the Dogtag instance, states its intentions and verifies that it can authenticate to LDAP.</p>
<pre><code>INFO: Stopping the instance to proceed with system cert renewal
INFO: Configuring LDAP password authentication
INFO: Setting pkidbuser password via ldappasswd
SASL/EXTERNAL authentication started
SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth
SASL SSF: 0
INFO: Selftests disabled for subsystems: ca
INFO: Resetting password for uid=admin,ou=people,o=ipaca
SASL/EXTERNAL authentication started
SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth
SASL SSF: 0</code></pre>
<p><code>cert-fix</code> stopped Dogtag, changed the database connection configuration, reset the agent password and suppressed the Dogtag self-tests.</p>
<pre><code>INFO: Starting the instance
INFO: Sleeping for 10 seconds to allow server time to start...</code></pre>
<p><code>cert-fix</code> starts Dogtag then sleeps for a bit. The sleep was added to avoid races against Dogtag startup that sometimes caused the tool to fail. It’s a bit of a hack, but 10 seconds should <em>hopefully</em> be enough.</p>
<pre><code>INFO: Requesting new cert for subsystem
INFO: Getting subsystem cert info for ca
INFO: Trying to setup a secure connection to CA subsystem.
INFO: Secure connection with CA is established.
INFO: Placing cert creation request for serial: 34
INFO: Request ID: 38
INFO: Request Status: complete
INFO: Serial Number: 0x26
INFO: Issuer: CN=Certificate Authority,O=IPA.LOCAL 201903151111
INFO: Subject: CN=CA Subsystem,O=IPA.LOCAL 201903151111
INFO: New cert is available at: /etc/pki/pki-tomcat/certs/subsystem.crt
INFO: Requesting new cert for 29; writing to /etc/pki/pki-tomcat/certs/29-renewed.crt
INFO: Trying to setup a secure connection to CA subsystem.
INFO: Secure connection with CA is established.
INFO: Placing cert creation request for serial: 29
INFO: Request ID: 39
INFO: Request Status: complete
INFO: Serial Number: 0x27
INFO: Issuer: CN=Certificate Authority,O=IPA.LOCAL 201903151111
INFO: Subject: CN=f27-1.ipa.local,O=IPA.LOCAL 201903151111
INFO: New cert is available at: /etc/pki/pki-tomcat/certs/29-renewed.crt</code></pre>
<p>Certificate requests were issued and completed successfully.</p>
<pre><code>INFO: Stopping the instance
INFO: Getting subsystem cert info for ca
INFO: Getting subsystem cert info for ca
INFO: Updating CS.cfg with the new certificate
INFO: Importing new subsystem cert into uid=pkidbuser,ou=people,o=ipaca
SASL/EXTERNAL authentication started
SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth
SASL SSF: 0
modifying entry &quot;uid=pkidbuser,ou=people,o=ipaca&quot;</code></pre>
<p>Dogtag was stopped, and the new subsystem cert was updated in <code>CS.cfg</code>. It was also imported into the <code>pkidbuser</code> entry to ensure LDAP TLS client authentication continues to work. No further action is taken in relation to the extra cert(s).</p>
<pre><code>INFO: Selftests enabled for subsystems: ca
INFO: Restoring previous LDAP configuration
INFO: Starting the instance with renewed certs</code></pre>
<p>Self-tests are re-enabled and the previous LDAP configuration restored. Python <em>context managers</em> are used to ensure that these steps are performed even when a fatal error occurs.</p>
<p>The end.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The problem of an expired CA certificate (issue <strong>#4</strong>) has not yet been addressed. It is not the highest priority but it would be nice to have. It is still believed to be a low-effort change so it is likely to be implemented at some stage.</p>
<p>More extensive testing of the tool is needed for renewing system certificates for other Dogtag subsystems—in particular the KRA subsystem.</p>
<p>The enhancements discussed in this post make the <code>cert-fix</code> tool a viable MVP for expired certificate recovery without time-travel. The enhancements are still in review, yet to be merged. That will hopefully happen soon (within a day or so of this post). We are also making a significant effort to backport <code>cert-fix</code> to some earlier branches and make it available on older releases.</p>
<p>As mentioned earlier in the post, we intend to implement a FreeIPA-specific wrapper for <code>cert-fix</code> that can take care of the additional steps required to renew and deploy expired certificates that are part of the FreeIPA system, but are not Dogtag system certificates handled directly by <code>cert-fix</code>. These include LDAP and Apache HTTPD certificates, the IPA RA agent certificate and the Kerberos PKINIT certificate.</p>]]></summary>
</entry>
<entry>
    <title>Customising Dogtag system certificate lifetimes</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-03-04-dogtag-system-cert-lifetime.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-03-04-dogtag-system-cert-lifetime.html</id>
    <published>2019-03-04T00:00:00Z</published>
    <updated>2019-03-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="customising-dogtag-system-certificate-lifetimes">Customising Dogtag system certificate lifetimes</h1>
<p>Default certificate lifetimes in Dogtag are 20 years for the CA certificate (when self-signed) and about 2 years for other system certificates. These defaults also apply to FreeIPA. It can be desirable to have shorter certificate lifetimes. And although I wouldn’t recommend to use <em>longer</em> lifetimes, people sometimes want that.</p>
<p>There is no <em>supported</em> mechanism for customising system certificate validity duration during Dogtag or FreeIPA installation. But it can be done. In this post I’ll explain how.</p>
<h2 id="profile-configuration-files">Profile configuration files</h2>
<p>During installation, profile configurations are copied from the RPM install locations under <code>/usr/share</code> to the new Dogtag instance’s configuration directory. If the LDAP profile subsystem is used (FreeIPA uses it) they are further copied from the instance configuration directory into the LDAP database.</p>
<p>There is no facility or opportunity to modify the profiles during installation. So if you want to customise the certificate lifetimes, you have to modify the files under <code>/usr/share</code>.</p>
<p>There are two directories that contain profile configurations:</p>
<dl>
<dt><code>/usr/share/pki/ca/profiles/ca/*.cfg</code></dt>
<dd><p>These profile configurations are available during general operation.</p>
</dd>
<dt><code>/usr/share/pki/ca/conf/*.profile</code></dt>
<dd><p>These <em>overlay</em> configurations used during installation when issuing system certificates. Each configuration references an underlying profile and can override or extend the configuration.</p>
</dd>
<dt><code>/usr/share/ipa/profiles/*.cfg</code></dt>
<dd><p>Profiles that are shipped by FreeIPA and imported into Dogtag are defined here. The configurations for the LDAP, Apache HTTPS and KDC certificates are found here.</p>
</dd>
</dl>
<p>I’ll explain which configuration file is used for which certificate later on in this post.</p>
<h2 id="specifying-the-validity-period">Specifying the validity period</h2>
<p>The configuration field for setting the validity period are:</p>
<pre><code>&lt;component&gt;.default.params.range=720
&lt;component&gt;.constraint.params.range=720</code></pre>
<p>where <code>&lt;component&gt;</code> is some key, usually a numeric index, that may be different for different profiles. The actual profile component classes are <code>ValidityDefault</code> and <code>ValidityConstraint</code>, or <code>{CA,User}Validity{Default,Constraint}</code> for some profiles.</p>
<p>The <code>default</code> component sets the default validity period for this profile, whereas the constraint sets the <em>maximum</em> duration in case the user overrides it. Note that if an override configuration overrides the <code>default</code> value such that it exceeds the <code>constraint</code> specified in the underlying configuration, issuance will fail due to constraint violation. It is usually best to specify both the <code>default</code> and <code>constraint</code> together, with the same value.</p>
<p>The default range unit is <code>day</code>, so the configuration above means <em>720 days</em>. Use the <code>rangeUnit</code> parameter to specify a different unit. The supported units are <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code> and <code>minute</code>. For example:</p>
<pre><code>&lt;component&gt;.default.params.range=3
&lt;component&gt;.default.params.rangeUnit=month
&lt;component&gt;.constraint.params.range=3
&lt;component&gt;.constraint.params.rangeUnit=month</code></pre>
<h2 id="which-configuration-for-which-certificate">Which configuration for which certificate?</h2>
<dl>
<dt>CA certificate (when self-signed)</dt>
<dd><p><code>/usr/share/pki/ca/conf/caCert.profile</code></p>
</dd>
<dt>OCSP signing certificate</dt>
<dd><p><code>/usr/share/pki/ca/conf/caOCSPCert.profile</code></p>
</dd>
<dt>Subsystem certificate</dt>
<dd><p><code>/usr/share/pki/ca/conf/rsaSubsystemCert.profile</code> when using RSA keys (the default)</p>
</dd>
<dt>Dogtag HTTPS certificate</dt>
<dd><p><code>/usr/share/pki/ca/conf/rsaServerCert.profile</code> when using RSA keys (the default)</p>
</dd>
<dt>Audit signing</dt>
<dd><p><code>/usr/share/pki/ca/conf/caAuditSigningCert.profile</code></p>
</dd>
<dt>IPA RA agent (FreeIPA-specific)</dt>
<dd><p><code>/usr/share/pki/ca/profiles/ca/caServerCert.cfg</code></p>
</dd>
<dt>Apache and LDAP certificates (FreeIPA-specific)</dt>
<dd><p><code>/usr/share/ipa/profiles/caIPAserviceCert.cfg</code></p>
</dd>
<dt>KDC certificate (FreeIPA-specific)</dt>
<dd><p><code>/usr/share/ipa/profiles/KDCs_PKINIT_Certs.cfg</code></p>
</dd>
</dl>
<h2 id="testing">Testing</h2>
<p>I made changes to the files mentioned above, so that certificates would be issued with the following validity periods:</p>
<table>
<tbody>
<tr class="odd">
<td>CA</td>
<td>5 years</td>
</tr>
<tr class="even">
<td>OCSP</td>
<td>1 year</td>
</tr>
<tr class="odd">
<td>Subsystem</td>
<td>6 months</td>
</tr>
<tr class="even">
<td>HTTPS</td>
<td>3 months</td>
</tr>
<tr class="odd">
<td>Audit</td>
<td>1 year</td>
</tr>
<tr class="even">
<td>IPA RA</td>
<td>15 months</td>
</tr>
<tr class="odd">
<td>Apache</td>
<td>4 months</td>
</tr>
<tr class="even">
<td>LDAP</td>
<td>4 months</td>
</tr>
<tr class="odd">
<td>KDC</td>
<td>18 months</td>
</tr>
</tbody>
</table>
<p>I installed FreeIPA (with a self-signed CA). After installation completed, I had a look at the certificates that were being tracked by Certmonger. For reference, the installation took place on March 4, 2019 (<strong>2019-03-04</strong>).</p>
<pre><code># getcert list |egrep &#39;^Request|certificate:|expires:&#39;
Request ID &#39;20190304044028&#39;:
  certificate: type=FILE,location=&#39;/var/lib/ipa/ra-agent.pem&#39;
  expires: 2020-06-04 15:40:30 AEST
Request ID &#39;20190304044116&#39;:
  certificate: type=NSSDB,location=&#39;/etc/pki/pki-tomcat/alias&#39;,nickname=&#39;auditSigningCert cert-pki-ca&#39;,token=&#39;NSS Certificate DB&#39;
  expires: 2020-03-04 15:39:53 AEDT
Request ID &#39;20190304044117&#39;:
  certificate: type=NSSDB,location=&#39;/etc/pki/pki-tomcat/alias&#39;,nickname=&#39;ocspSigningCert cert-pki-ca&#39;,token=&#39;NSS Certificate DB&#39;
  expires: 2020-03-04 15:39:53 AEDT
Request ID &#39;20190304044118&#39;:
  certificate: type=NSSDB,location=&#39;/etc/pki/pki-tomcat/alias&#39;,nickname=&#39;subsystemCert cert-pki-ca&#39;,token=&#39;NSS Certificate DB&#39;
  expires: 2019-09-04 15:39:53 AEST
Request ID &#39;20190304044119&#39;:
  certificate: type=NSSDB,location=&#39;/etc/pki/pki-tomcat/alias&#39;,nickname=&#39;caSigningCert cert-pki-ca&#39;,token=&#39;NSS Certificate DB&#39;
  expires: 2024-03-04 15:39:51 AEDT
Request ID &#39;20190304044120&#39;:
  certificate: type=NSSDB,location=&#39;/etc/pki/pki-tomcat/alias&#39;,nickname=&#39;Server-Cert cert-pki-ca&#39;,token=&#39;NSS Certificate DB&#39;
  expires: 2019-06-04 15:39:53 AEST
Request ID &#39;20190304044151&#39;:
  certificate: type=NSSDB,location=&#39;/etc/dirsrv/slapd-IPA-LOCAL&#39;,nickname=&#39;Server-Cert&#39;,token=&#39;NSS Certificate DB&#39;
  expires: 2019-07-04 15:41:52 AEST
Request ID &#39;20190304044225&#39;:
  certificate: type=FILE,location=&#39;/var/lib/ipa/certs/httpd.crt&#39;
  expires: 2019-07-04 15:42:26 AEST
Request ID &#39;20190304044234&#39;:
  certificate: type=FILE,location=&#39;/var/kerberos/krb5kdc/kdc.crt&#39;
  expires: 2020-09-04 15:42:34 AEST</code></pre>
<p>Observe that the certificate have the intended periods.</p>
<h2 id="discussion">Discussion</h2>
<p>The procedure outlined in this post is not officially supported, and not recommended. But the desire to choose different validity periods is sometimes justified, especially for the CA certificate. So should FreeIPA allow customisation of the system certificate validity periods? To what extent?</p>
<p>We need to reduce the default CA validity from 20 years, given the 2048-bit key size. (There is a separate issue to support generating a larger CA signing key, too). Whether the CA validity period should be configurable is another question. My personal opinion is that it makes sense to allow the customer to choose the CA lifetime.</p>
<p>For system certificates, I think that customers should just accept the defaults. PKI systems are trending to shorter lifetimes for end-entity certificates, which is a good thing. For FreeIPA, unfortunately we are still dealing with a lot of certificate renewal issues that arise from the complex architecture. Until we are confident in the robustness of the renewal system, and have observed a reduction in customer issues, it would be a mistake to substantially reduce the validity period for system certificates. Likewise, it is not yet a good idea to let customers choose the certificate validity periods.</p>
<p>On the other hand, the team is considering changing the default validity period of system certificates <em>a little bit</em>, so that different certificates are on different renewal candences. This would simplify recovery in some scenarios: it is easier to recover when only <em>some</em> of the certificates expired, instead of <em>all</em> of them at once.</p>]]></summary>
</entry>
<entry>
    <title>Specifying a CA Subject Key Identifier during Dogtag installation</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-03-01-dogtag-csr-ski.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-03-01-dogtag-csr-ski.html</id>
    <published>2019-03-01T00:00:00Z</published>
    <updated>2019-03-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="specifying-a-ca-subject-key-identifier-during-dogtag-installation">Specifying a CA Subject Key Identifier during Dogtag installation</h1>
<p>When installing Dogtag with an externally-signed CA certificate, it is sometimes necessary to include a specific <em>Subject Key Identifier</em> value in the CSR. In this post I will demonstrate how to do this.</p>
<h2 id="what-is-a-subject-key-identifier">What is a Subject Key Identifier?</h2>
<p>The X.509 <em>Subject Key Identifier (SKI)</em> extension declares a unique identifier for the public key in the certificate. It is required on all CA certificates. CAs propagate their own SKI to the <em>Issuer Key Identifier (AKI)</em> extension on issued certificates. Together, these facilitate efficient certification path construction; certificate databases can index certificates by SKI.</p>
<p>The SKI must be unique for a given key. Most often it is derived from the public key data using a cryptographic digest, usually SHA-1. But any method of generating a unique value is acceptable.</p>
<p>For example, let’s look at the CA certificate and one of the service certificates in a FreeIPA deployment. The CA is self-signed and therefore contains the same value in both the SKI and AKI extensions:</p>
<pre><code>% openssl x509 -text &lt; /etc/ipa/ca.crt
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 1 (0x1)
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: O = IPA.LOCAL 201902271325, CN = Certificate Authority
        Validity
            Not Before: Feb 27 03:30:22 2019 GMT
            Not After : Feb 27 03:30:22 2034 GMT
        Subject: O = IPA.LOCAL 201902271325, CN = Certificate Authority
        Subject Public Key Info:
            &lt; elided &gt;
        X509v3 extensions:
            X509v3 Authority Key Identifier:
                keyid:C9:29:69:D0:14:A4:AB:11:D4:11:B1:35:31:81:08:B6:A9:30:D3:0A

            X509v3 Basic Constraints: critical
                CA:TRUE
            X509v3 Key Usage: critical
                Digital Signature, Non Repudiation, Certificate Sign, CRL Sign
            X509v3 Subject Key Identifier:
                C9:29:69:D0:14:A4:AB:11:D4:11:B1:35:31:81:08:B6:A9:30:D3:0A
            Authority Information Access:
                OCSP - URI:http://ipa-ca.ipa.local/ca/ocsp
  ...</code></pre>
<p>Whereas the end entity certificate has the CA’s SKI in its AKI, and its SKI is different:</p>
<pre><code>% sudo cat /var/lib/ipa/certs/httpd.crt | openssl x509 -text
Certificate:
    Data:
      Version: 3 (0x2)                                                                                                                                                                                  [43/9508]
      Serial Number: 9 (0x9)
      Signature Algorithm: sha256WithRSAEncryption
      Issuer: O = IPA.LOCAL 201902271325, CN = Certificate Authority
      Validity
          Not Before: Feb 27 03:32:57 2019 GMT
          Not After : Feb 27 03:32:57 2021 GMT
      Subject: O = IPA.LOCAL 201902271325, CN = f29-0.ipa.local
      Subject Public Key Info:
          &lt; elided &gt;
      X509v3 extensions:
          X509v3 Authority Key Identifier:
              keyid:C9:29:69:D0:14:A4:AB:11:D4:11:B1:35:31:81:08:B6:A9:30:D3:0A

          Authority Information Access:
              OCSP - URI:http://ipa-ca.ipa.local/ca/ocsp

          X509v3 Key Usage: critical
              Digital Signature, Non Repudiation, Key Encipherment, Data Encipherment
          X509v3 Extended Key Usage:
              TLS Web Server Authentication, TLS Web Client Authentication
          X509v3 CRL Distribution Points:

              Full Name:
                URI:http://ipa-ca.ipa.local/ipa/crl/MasterCRL.bin
              CRL Issuer:
                DirName:O = ipaca, CN = Certificate Authority

          X509v3 Subject Key Identifier:
              FE:D2:8A:72:C8:D5:78:79:C9:04:04:A8:39:37:7F:FD:36:E6:E9:D2
          X509v3 Subject Alternative Name:
              DNS:f29-0.ipa.local, othername:&lt;unsupported&gt;, othername:&lt;unsupported&gt;</code></pre>
<p>Most CA programs, including Dogtag, automatically compute a SKI for every certificate being issued. Dogtag computes a SHA-1 hash over the <code>subjectPublicKey</code> value, which is the most common method. The value must be unique, but does not have to be derived from the public key.</p>
<p>It is not required for a self-signed CA certificate to contain an AKI extension. Neither is it necessary to include a SKI in an end entity certificate. But it does not hurt to include them. Indeed it is common (as we see above).</p>
<h2 id="use-case-for-specifying-a-ski">Use case for specifying a SKI</h2>
<p>If CAs can automatically compute a SKI, why would you need to specify one?</p>
<p>The use case arises when you’re changing external CAs or switching from self-signed to externally-signed, or vice versa. The new CA might compute SKIs differently from the current CA. But it is important to keep using the same SKI. So it is desirable to include the SKI in the CSR to indicate to the CA the value that should be used.</p>
<p>Not every CA program will follow the suggestion. Or the behaviour may be configurable, system-wide or per-profile. If you’re using Dogtag / RHCS to sign CA certificates, it is straightforward to define a profile that uses an SKI supplied in the CSR (but that is beyond the scope of this article).</p>
<h2 id="including-an-ski-in-a-dogtag-csr">Including an SKI in a Dogtag CSR</h2>
<p>At time of writing, this procedure is supported in Dogtag 10.6.9 and later, which is available in Fedora 28 and Fedora 29. It will be supported in a future version of RHEL. The behaviour depends on a recent enhancement to the <code>certutil</code> program, which is part of NSS. That enhancement is not in RHEL 7 yet, hence this Dogtag feature is not yet available on RHEL 7.</p>
<p>When installing Dogtag using the two-step external signing procedure, by default no SKI is included the CSR. You can change this via the <code>pki_req_ski</code> option. The option is described in the <code>pki_default.cfg(5)</code> man page. There are two ways to use the option, and we will look at each in turn.</p>
<h3 id="default-method">Default method</h3>
<pre><code>[CA]
pki_req_ski=DEFAULT</code></pre>
<p>This special value will cause the CSR to contain a SKI value computed using the same method Dogtag itself uses (SHA-1 digest). Adding this value resulted in the following CSR data:</p>
<pre><code>Certificate Request:
    Data:
        Version: 1 (0x0)
        Subject: O = IPA.LOCAL 201903011502, CN = Certificate Authority
        Subject Public Key Info:
            &lt; elided &gt;
        Attributes:
        Requested Extensions:
            X509v3 Subject Key Identifier: 
                76:49:AA:B2:08:60:18:C1:6D:AF:2C:28:A0:54:34:77:7E:8F:80:71
            X509v3 Basic Constraints: critical
                CA:TRUE
            X509v3 Key Usage: critical
                Digital Signature, Non Repudiation, Certificate Sign, CRL Sign</code></pre>
<p>The SKI value is the SHA-1 digest of the public key. Of course, it will be different every time, because a different key will be generated.</p>
<h3 id="explicit-ski">Explicit SKI</h3>
<pre><code>[CA]
pki_req_ski=&lt;hex data&gt;</code></pre>
<p>An exact SKI value can be specified as a hex-encode byte string. The datum <strong>must not</strong> have a leading <code>0x</code>. I used the following configuration:</p>
<pre><code>[CA]
pki_req_ski=00D06F00D4D06746</code></pre>
<p>With this configuration, the expected SKI value appears in the CSR:</p>
<pre><code>Certificate Request:
    Data:
        Version: 1 (0x0)
        Subject: O = IPA.LOCAL 201903011518, CN = Certificate Authority
        Subject Public Key Info:
            &lt; elided &gt;
        Attributes:
        Requested Extensions:
            X509v3 Subject Key Identifier:
                00:D0:6F:00:D4:D0:67:46
            X509v3 Basic Constraints: critical
                CA:TRUE
            X509v3 Key Usage: critical
                Digital Signature, Non Repudiation, Certificate Sign, CRL Sign</code></pre>
<h2 id="renewal">Renewal</h2>
<p>We don’t have direct support for including the SKI in the CSR generated for renewing an externally signed CA. But you can use <code>certutil</code> to create a CSR that includes the desired SKI.</p>
<p>It could be worthwhile to enhance Certmonger to automatically include the SKI of the current certificate when it creates a CSR for renewing a tracked certificate.</p>
<h2 id="freeipa-support">FreeIPA support</h2>
<p>We don’t expose this feature in FreeIPA directly. It can be hacked in pretty easily by modifying the Python code that builds the <code>pkispawn</code> configuration during installation. Alternatively, set the option in the <code>pkispawn</code> default configuration file: <code>/usr/share/pki/server/etc/default.cfg</code> (this is what I did to test the feature).</p>
<p>Changes to be made as part of the <a href="https://github.com/freeipa/freeipa/pull/2307">upcoming HSM support</a> will, as a pleasant side effect, make it easy to specify or override <code>pkispawn</code> configuration values including <code>pki_req_ski</code>.</p>]]></summary>
</entry>
<entry>
    <title>Offline expired certificate renewal for Dogtag</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-02-28-dogtag-cert-fix.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-02-28-dogtag-cert-fix.html</id>
    <published>2019-02-28T00:00:00Z</published>
    <updated>2019-02-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="offline-expired-certificate-renewal-for-dogtag">Offline expired certificate renewal for Dogtag</h1>
<p>The worst has happened. Somehow, certificate renewal didn’t happen when it should have, and now you have expired certificates. Worst, these are Dogtag system certificates; you can’t even start Dogtag to issue new ones! Unfortunately, this situation arises fairly often. Sometimes due to administrator error or extended downtime; sometimes due to bugs. These cases are notoriously difficult (and expensive) to analyse and resolve. It often involves <em>time travel</em>:</p>
<ol type="1">
<li>Set the system clock to a time setting just before certificates started expiring.</li>
<li>Fix whatever caused renewal not to work in the first place.</li>
<li>Renew expiring certificates.</li>
<li>Reset system clock.</li>
</ol>
<p>That is the <em>simple</em> case! I have seen much gnarlier scenarios. Ones where <em>multiple times</em> must be visited. Ones where there is <em>no time</em> at which all relevant certs are valid.</p>
<p>It would be nice to avoid these scenarios, and the FreeIPA team continues to work to improve the robustness of certificate renewal. We also have a monitoring / health check solution on the roadmap, so that failure of automated renewal sets off alarms before <em>everything else</em> falls over. But in the meantime, customers and support are still dealing with scenarios like this. Better recovery tools are needed.</p>
<p>And better tools are on the way! Dinesh, one of the Dogtag developers, has built a tool to simplify renewal when your Dogtag CA is offline due to expired system certificates. This post outlines what the tool is, what it does, and my first experiences using it in a FreeIPA deployment. Along the way and especially toward the end of the post, I will discuss the caveats and potential areas for improvement, and FreeIPA-specific considerations.</p>
<h2 id="pki-server-cert-fix"><code>pki-server cert-fix</code></h2>
<p>The tool is implemented as a subcommand of the <code>pki-server</code> utility–namely <code>cert-fix</code> (and I will use this short name throughout the post). So it is implemented in Python, but in some places it calls out to <code>certutil</code> or the Java parts of Dogtag via the HTTP API. The <a href="https://github.com/dogtagpki/pki/blob/master/docs/admin/Offline_System_Certificate_Renewal.md">user documentation</a> is maintained the source repository.</p>
<p>The insight at the core of <code>cert-fix</code> is that even if Dogtag is not running or <em>cannot</em> run, we still have access to the keys needed to issue certificates. We <em>do</em> need to use Dogtag to properly store issued certificates (for revocation purposes) and produce an audit trail. But if needed, we can use the CA signing key to <strong>temporarily</strong> fudge the important certificates to get Dogtag running again, then re-issue expired system certificates properly.</p>
<h3 id="assumptions">Assumptions</h3>
<p><code>cert-fix</code> makes the following assumptions about your environment. If these do not hold, then <code>cert-fix</code>, as currently implemented, cannot do its thing.</p>
<ul>
<li>The CA signing certificate is valid.</li>
<li>You have a valid admin or agent certificate. In a FreeIPA environment the <code>IPA RA</code> certificaite fulfils this role.</li>
<li>(indirect) The LDAP server (389 DS) is operational, its certificate is valid, and Dogtag can authenticate to it.</li>
</ul>
<p>These assumptions have been made for good reasons, but there are several certificate expiry scenarios that breach them. I will discuss in detail later in the post. For now, we must accept them.</p>
<h3 id="what-cert-fix-does">What <code>cert-fix</code> does</h3>
<p>The <code>cert-fix</code> performs the following actions to renew an expired system certificate:</p>
<ol>
<li>Inspect the system and identify which system certificates need renewing. Or the certificates can be specified on the command line.</li>
<li>If Dogtag’s HTTPS certificate is expired, use certutil commands to issue a new “temporary” certificate. The validity period is three months (from the current time). The serial number of the current (expired) HTTPS is reused (a big X.509 no-no, but operationally no big deal in this scenario). There is no audit trail and the certificate will not appear in the LDAP database.</li>
<li>Disable the startup self-test for affected subsystems, then start Dogtag.</li>
<li>For each target certificate, renew the certificate via API, using given credential. Validity periods and other characteristics are determined by relevant profiles. Serial numbers are chosen in the usual manner, the certificates appear in LDAP and there is an audit trail.</li>
<li>Stop Dogtag.</li>
<li>For each target certificate, import the new certificate into Dogtag’s NSSDB.</li>
<li>Re-enable self-test for affected subsystems and start Dogtag.</li>
</ol>
<h2 id="using-cert-fix">Using <code>cert-fix</code></h2>
<p>There are a couple of ways to try out the tool—without waiting for certificates to expire, that is. One way is to roll your system clock forward, beyond the expiry date of one or more certificates. Another possibility is to modify a certificate profile used for a system certificate so that it will be issued with a very short validity period.</p>
<p>I opted for the latter option. I manually edited the default profile configuration, so that Dogtag’s OCSP and HTTPS certificates would be issued with a validity period of 15 minutes. By the time I installed FreeIPA, grabbed a coffee and read a few emails, the certificates had expired. Certmonger didn’t even attempt to renew them. Dogtag was still running and working properly, but <code>ipactl restart</code> put Dogtag, and the whole FreeIPA deployment, out of action.</p>
<p>I used <code>pki-server cert-find</code> to have a peek at Dogtag’s system certificates:</p>
<pre><code>[root@f29-0 ca]# pki-server cert-find
  Cert ID: ca_signing
  Nickname: caSigningCert cert-pki-ca
  Serial Number: 0x1
  Subject DN: CN=Certificate Authority,O=IPA.LOCAL 201902271325
  Issuer DN: CN=Certificate Authority,O=IPA.LOCAL 201902271325
  Not Valid Before: Wed Feb 27 14:30:22 2019
  Not Valid After: Mon Feb 27 14:30:22 2034

  Cert ID: ca_ocsp_signing
  Nickname: ocspSigningCert cert-pki-ca
  Serial Number: 0x2
  Subject DN: CN=OCSP Subsystem,O=IPA.LOCAL 201902271325
  Issuer DN: CN=Certificate Authority,O=IPA.LOCAL 201902271325
  Not Valid Before: Wed Feb 27 14:30:24 2019
  Not Valid After: Wed Feb 27 14:45:24 2019

  Cert ID: sslserver
  Nickname: Server-Cert cert-pki-ca
  Serial Number: 0x3
  Subject DN: CN=f29-0.ipa.local,O=IPA.LOCAL 201902271325
  Issuer DN: CN=Certificate Authority,O=IPA.LOCAL 201902271325
  Not Valid Before: Wed Feb 27 14:30:24 2019
  Not Valid After: Wed Feb 27 14:45:24 2019

  Cert ID: subsystem
  Nickname: subsystemCert cert-pki-ca
  Serial Number: 0x4
  Subject DN: CN=CA Subsystem,O=IPA.LOCAL 201902271325
  Issuer DN: CN=Certificate Authority,O=IPA.LOCAL 201902271325
  Not Valid Before: Wed Feb 27 14:30:24 2019
  Not Valid After: Tue Feb 16 14:30:24 2021

  Cert ID: ca_audit_signing
  Nickname: auditSigningCert cert-pki-ca
  Serial Number: 0x5
  Subject DN: CN=CA Audit,O=IPA.LOCAL 201902271325
  Issuer DN: CN=Certificate Authority,O=IPA.LOCAL 201902271325
  Not Valid Before: Wed Feb 27 14:30:24 2019
  Not Valid After: Tue Feb 16 14:30:24 2021</code></pre>
<p>Note the <code>Not Valid After</code> times for the <code>ca_ocsp_signing</code> and <code>sslserver</code> certificates. These are certificates we must renew.</p>
<h3 id="preparing-the-agent-certificate">Preparing the agent certificate</h3>
<p>The <code>cert-fix</code> command requires an agent certificate. We will use the <em>IPA RA</em> certificate. The <code>pki-server</code> CLI tool needs an NSSDB with the agent key and certificate. So we have to set that up. First initialise the NSSDB:</p>
<pre><code>[root@f29-0 ~]# mkdir ra-nssdb
[root@f29-0 ~]# cd ra-nssdb
[root@f29-0 ra-nssdb]# certutil -d . -N
Enter a password which will be used to encrypt your keys.
The password should be at least 8 characters long,
and should contain at least one non-alphabetic character.

Enter new password: XXXXXXXX
Re-enter password: XXXXXXXX</code></pre>
<p>Then create a PKCS #12 file containing the required key and certificates:</p>
<pre><code>[root@f29-0 ra-nssdb]# openssl pkcs12 -export \
  -inkey /var/lib/ipa/ra-agent.key \
  -in /var/lib/ipa/ra-agent.pem \
  -name &quot;ra-agent&quot; \
  -certfile /etc/ipa/ca.crt &gt; ra-agent.p12
Enter Export Password:
Verifying - Enter Export Password:</code></pre>
<p>Import it into the NSSDB, and fix up trust flags on the IPA CA certificate:</p>
<pre><code>[root@f29-0 ra-nssdb]# pk12util -d . -i ra-agent.p12
Enter Password or Pin for &quot;NSS Certificate DB&quot;:
Enter password for PKCS12 file:
pk12util: PKCS12 IMPORT SUCCESSFUL

[root@f29-0 ra-nssdb]# certutil -d . -L

Certificate Nickname                                         Trust Attributes
                                                             SSL,S/MIME,JAR/XPI

ra-agent                                                     u,u,u
Certificate Authority - IPA.LOCAL 201902271325               ,,

[root@f29-0 ra-nssdb]# certutil -d . -M \
    -n &#39;Certificate Authority - IPA.LOCAL 201902271325&#39; \
    -t CT,C,C
Enter Password or Pin for &quot;NSS Certificate DB&quot;:

[root@f29-0 ra-nssdb]# certutil -d . -L

Certificate Nickname                                         Trust Attributes
                                                             SSL,S/MIME,JAR/XPI

ra-agent                                                     u,u,u
Certificate Authority - IPA.LOCAL 201902271325               CT,C,C</code></pre>
<h3 id="running-cert-fix">Running <code>cert-fix</code></h3>
<p>Let’s look at the <code>cert-fix</code> command options:</p>
<pre><code>[root@f29-0 ra-nssdb]# pki-server cert-fix --help
Usage: pki-server cert-fix [OPTIONS]

      --cert &lt;Cert ID&gt;            Fix specified system cert (default: all certs).
  -i, --instance &lt;instance ID&gt;    Instance ID (default: pki-tomcat).
  -d &lt;NSS database&gt;               NSS database location (default: ~/.dogtag/nssdb)
  -c &lt;NSS DB password&gt;            NSS database password
  -C &lt;path&gt;                       Input file containing the password for the NSS database.
  -n &lt;nickname&gt;                   Client certificate nickname
  -v, --verbose                   Run in verbose mode.
      --debug                     Run in debug mode.
      --help                      Show help message.</code></pre>
<p>It’s not a good idea to put passphrases on the command line in the clear, so let’s write the NSSDB passphrase to a file:</p>
<pre><code>[root@f29-0 ra-nssdb]# cat &gt; pwdfile.txt
XXXXXXXX
^D</code></pre>
<p>Finally, I was ready to execute <code>cert-fix</code>:</p>
<pre><code>[root@f29-0 ra-nssdb]# pki-server cert-fix \
    -d . -C pwdfile.txt -n ra-agent \
    --cert sslserver --cert ca_ocsp_signing \
    --verbose</code></pre>
<p>Running with <code>--verbose</code> causes <code>INFO</code> and higher-level log messages to be printed to the terminal. Running with <code>--debug</code> includes <code>DEBUG</code> messages. If neither of these is used, <em>nothing</em> is output (unless there’s an error). So I recommend running with <code>--verbose</code>.</p>
<p>So, what happened? Unfortunately I ran into several issues.</p>
<h4 id="ds-not-running">389 DS not running</h4>
<p>The first issue was trivial, but likely to occur if you have to <code>cert-fix</code> a FreeIPA deployment. The <code>ipactl [re]start</code> command will shut down <em>every</em> component if <em>any</em> component failed to start. Dogtag didn’t start, therefore <code>ipactl</code> shut down 389 DS too. As a consequence, Dogtag failed to initialise after <code>cert-fix</code> started it, and the command failed.</p>
<p>So, before running <code>cert-fix</code>, make sure LDAP is working properly. To start it, use <code>systemctl</code> instead of <code>ipactl</code>:</p>
<pre><code># systemctl start dirsrv@YOUR-REALM</code></pre>
<h4 id="connection-refused">Connection refused</h4>
<p>One issue I encountered was that a slow startup of Dogtag caused failure of the tool. <code>cert-fix</code> does not wait for Dogtag to start up properly. It just ploughs ahead—only to encounter <code>ConnectionRefusedError</code>.</p>
<p>I worked around this—temporarily—by adding a sleep after <code>cert-fix</code> starts Dogtag. A proper fix will require a change to the code. <code>cert-fix</code> should perform a server status check, retrying until it succeeds or times out.</p>
<h4 id="tls-handshake-failure">TLS handshake failure</h4>
<p>The next error I encountered was a TLS handshake failure:</p>
<pre><code>urllib3.exceptions.MaxRetryError:
  HTTPSConnectionPool(host=&#39;f29-0.ipa.local&#39;, port=8443): Max retries
  exceeded with url: /ca/rest/certrequests/profiles/caManualRenewal
  (Caused by SSLError(SSLError(185073780, &#39;[X 509: KEY_VALUES_MISMATCH]
  key values mismatch (_ssl.c:3841)&#39;)))</code></pre>
<p>I haven’t worked out yet what is causing this surprising error. But I wasn’t the first to encounter it. A <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1669257#c10">comment in the Bugzilla ticket</a> indicated that the workaround was to <em>remove</em> the IPA CA certificate from the client NSSDB. This I did:</p>
<pre><code>[root@f29-0 ra-nssdb]# certutil -d . -D \
    -n &quot;Certificate Authority - IPA.LOCAL 201902271325&quot;</code></pre>
<p>After this, my next attempt at running <code>cert-fix</code> succeeded.</p>
<h3 id="results">Results</h3>
<p>Looking at the previously expired target certificates, observe that the certificates have been updated. They have new serial numbers, and expire in 15 months:</p>
<pre><code>[root@f29-0 ra-nssdb]# certutil -d /etc/pki/pki-tomcat/alias \
    -L -n &#39;Server-Cert cert-pki-ca&#39; | egrep &quot;Serial|Not After&quot;
      Serial Number: 12 (0xc)
          Not After : Wed May 27 12:45:25 2020

[root@f29-0 ra-nssdb]# certutil -d /etc/pki/pki-tomcat/alias \
    -L -n &#39;ocspSigningCert cert-pki-ca&#39; | egrep &quot;Serial|Not After&quot;
      Serial Number: 13 (0xd)
          Not After : Wed May 27 12:45:28 2020</code></pre>
<p>Looking at the output of <code>getcert list</code> for the target certificates, we see that Certmonger has <em>not</em> picked these up (some lines removed):</p>
<pre><code>[root@f29-0 ra-nssdb]# getcert list -i 20190227033149
Number of certificates and requests being tracked: 9.
Request ID &#39;20190227033149&#39;:
   status: CA_UNREACHABLE
   ca-error: Internal error
   stuck: no
   CA: dogtag-ipa-ca-renew-agent
   issuer: CN=Certificate Authority,O=IPA.LOCAL 201902271325
   subject: CN=OCSP Subsystem,O=IPA.LOCAL 201902271325
   expires: 2019-02-27 14:45:24 AEDT
   eku: id-kp-OCSPSigning

[root@f29-0 ra-nssdb]# getcert list -i 20190227033152
Number of certificates and requests being tracked: 9.
Request ID &#39;20190227033152&#39;:
   status: CA_UNREACHABLE
   ca-error: Internal error
   stuck: no
   CA: dogtag-ipa-ca-renew-agent
   issuer: CN=Certificate Authority,O=IPA.LOCAL 201902271325
   subject: CN=f29-0.ipa.local,O=IPA.LOCAL 201902271325
   expires: 2019-02-27 14:45:24 AEDT
   dns: f29-0.ipa.local
   key usage: digitalSignature,keyEncipherment,dataEncipherment
   eku: id-kp-serverAuth</code></pre>
<p>Restarting Certmonger (<code>systemctl restart certmonger</code>) resolved the discrepancy.</p>
<p>Finally, <code>ipactl restart</code> puts everything back online. <code>cert-fix</code> has saved the day!</p>
<pre><code>[root@f29-0 ra-nssdb]# ipactl restart
Restarting Directory Service
Starting krb5kdc Service
Starting kadmin Service
Starting httpd Service
Starting ipa-custodia Service
Starting pki-tomcatd Service
Starting ipa-otpd Service
ipa: INFO: The ipactl command was successful</code></pre>
<h2 id="issues-and-caveats">Issues and caveats</h2>
<p>Besides the issues already covered, there are several scenarios that <code>cert-fix</code> cannot handle.</p>
<h3 id="expired-ca-certificate">Expired CA certificate</h3>
<p>Due to the the long validity period of a typical CA certificate, the assumption that the CA certificate is valid is the safest assumption made by <code>cert-fix</code>. But it is not a safe assumption.</p>
<p>The most common way this assumption is violated is with externally-signed CA certificates. For example, the FreeIPA CA in your organisation is signed by Active Directory CA, with a validity period of two years. Things get overlooked and suddenly, your FreeIPA CA is expired. It may take some time for the upstream CA administrators to issue a new certificate. In the meantime, you want to get your FreeIPA/Dogtag CA back up.</p>
<p>Right now <code>cert-fix</code> doesn’t handle this scenario. I think it should. As far as I can tell, this should be straightforward to support. Unlike the next few issues…</p>
<h3 id="agent-certificate-expiry">Agent certificate expiry</h3>
<p>This concerns the assumption that you have a valid agent certificate. Dogtag requires authentication to perform privilieged operations like certificate issuance. Also, the authenticated user must be included in audit events. <code>cert-fix</code> <em>must</em> issue certificates properly (with limiited temporary fudging tolerated for operational efficacy), therefore there <em>must</em> be an agent credential. And if your agent credential is a certificate, it <em>must</em> be valid. So if your agent certificate is expired, it’s Catch-22. That is why the tool, as currently implemented, must assume you have a valid, non-expired agent certificate.</p>
<p>In some deployments the agent certificate is renewed on a different cadence from subsystem certificates. In that case, this scenario is less like to occur—but still entirely possible! The assumption is bad.</p>
<p>In my judgement it is fairly important to find a workaround for this. One idea could be to talk directly to LDAP and set a randomly-generated password on an agent account, and use that to authenticate. After the tool exits, the passphrase is forgotten. This approach means <code>cert-fix</code> needs a credential and privileges to perform those operations in LDAP.</p>
<p>Speaking of LDAP…</p>
<h3 id="ds-certificate-authentication">389 DS certificate authentication</h3>
<p>In FreeIPA deployments, Dogtag is configured to use the subsystem certificate to bind (authenticate) to the LDAP server. If the subsystem certificate is expired, 389 DS will reject the certificate; the connection fails and and Dogtag cannot start.</p>
<p>A workaround for this may be to temporarily reconfigure Dogtag to use a password to authenticate to LDAP. Then after the new subsystem certificate was issued, it must be added to the <code>pkidbuser</code> entry in LDAP, and certificate authentication reinstated.</p>
<p>This is not a FreeIPA-specific consideration. Using TLS client authentication to bind to LDAP is a supported configuration in Dogtag / RHCS. So we should probably support it in <code>cert-fix</code> too, somehow, since the point of the tool is to avoid complex manual procedures in recovering from expired system certificates.</p>
<h3 id="ds-service-certificate-expiry">389 DS service certificate expiry</h3>
<p>You know the tune by now… if this certificate is expired, Dogtag can’t talk to LDAP and can’t start, therefore a new LDAP certificate can’t be issued.</p>
<p>Issuing a temporary certificate with the same serial number may be the best way forward here, like what we do for the Dogtag HTTPS certificate.</p>
<h3 id="re-keying">Re-keying</h3>
<p>…is not supported. But it is a possible future enhancement</p>
<h3 id="serial-number-reuse">Serial number reuse</h3>
<p>Re-using a serial number is prohibited by the X.509 standard. Although the temporary re-issued HTTPS certificate is supposed to be temporary, what if it did leak out? For example, another client that contacted Dogtag while that certificate is in use could log it to a Certificate Transparency log (not a public one, unless your Dogtag CA is chained to a publicly trusted CA). If this occurred, there would be a record that the CA had misbehaved.</p>
<p>What are the ramifications? If this happened in the public PKI, the offending CA would <em>at best</em> get a harsh and very public admonishment, and be put on notice. But trust store vendors might just straight up wash their hands of you and yank trust.</p>
<p>In a private PKI is it such a big deal? Given our use case—the same subject names are used—probably not. But I leave it as an open topic to ponder how this might backfire.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post I introduced the <code>pki-server cert-fix</code> subcommand. The purpose of this tool is to simplify and speed up recovery when Dogtag system certificates have expired.</p>
<p>It does what it says on the tin, with a few rough edges and, right now, a lot of caveats. The fundamentals are very good, but I think we need to address number of these caveats for <code>cert-fix</code> to be generally useful, especially in a FreeIPA context. Based on my early experiences and investigation, my suggested priorities are:</p>
<ol>
<li>Workaround for when the agent certificate is expired. This can affect every kind of deployment and the reliance on a valid agent certificate is a significant limitation.</li>
<li>Workaround for expired subsystem certificate when TLS client authentication is used to bind to LDAP. This affects all FreeIPA deployments (standalone Dogtag deployments less commonly).</li>
<li>Support renewing the CA certificate in <code>cert-fix</code>. A degree of sanity checking or confirmation may be reasonable (e.g. it must be explicitly listed on the CLI as a <code>--cert</code> option).</li>
<li>Investigate ways to handle expired LDAP certificate, if issued by Dogtag. In some deployments, including some FreeIPA deployments, the LDAP certificate is not issued by Dogtag, so the risk is not universal.</li>
</ol>
<p>In writing this post I by no means wish to diminish Dinesh’s work. On the contrary, I’m impressed with what the tool already can do! And, mea culpa, I have taken far too long to test this tool and evaluate it in a FreeIPA setting. Now that I have a clearer picture, I see that I will be very busy making the tool more capable and ready for action in FreeIPA scenarios.</p>]]></summary>
</entry>
<entry>
    <title>IP address SAN support in FreeIPA</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-02-18-freeipa-san-ip.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-02-18-freeipa-san-ip.html</id>
    <published>2019-02-18T00:00:00Z</published>
    <updated>2019-02-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="ip-address-san-support-in-freeipa">IP address SAN support in FreeIPA</h1>
<p>The X.509 <em>Subject Alternative Name (SAN)</em> certificate extension carries subject names that cannot (or cannot easily) be expressed in the Subject Distinguished Name field. The extension supports various name types, including DNS names (the most common), IP addresses, email addresses (for users) and Kerberos principal names, among others.</p>
<p>When issuing a certificate, FreeIPA has to validate that requested SAN name values match the principal to whom the certificate is being issued. There has long been support for DNS names, Kerberos and Microsoft principal names, and email addresses. Over the years we have received many requests to support IP address SAN names. And now we are finally <a href="https://pagure.io/freeipa/issue/7451">adding support</a>!</p>
<p>In this post I will explain the context and history of this feature, and demonstrate how to use it. At time of writing the work is <a href="https://github.com/freeipa/freeipa/pull/1843">not yet merged</a>, but substantive changes are not expected.</p>
<h2 id="acknowledgement">Acknowledgement</h2>
<p>First and foremost, I must thank <strong>Ian Pilcher</strong> who drove this work. DNS name validation is tricky, but Ian proposed a regime that was acceptable to the FreeIPA team from a philosophical and security standpoint. Then he cut the initial patch for the feature. The work was of a high quality; my subsequent changes and enhancements were minor. Above all, Ian and others had great patience as the pull request sat in limbo for nearly a year! Thank you Ian.</p>
<h2 id="ip-address-validation">IP address validation</h2>
<p>There is a reason we kicked the SAN IP address support can down the road for so long. Unlike some name types, validating IP addresses is far from straightforward.</p>
<p>Let’s first consider the already-supported name types. FreeIPA is an <em>identity management system</em>. It <em>knows</em> the various identities (principal name, email address, hostname) of the subjects/principals it knows about. Validation of these name types reduces to the question <em>“does this name belong to the subject principal object?”</em></p>
<p>For IP addresses is not so simple. There are several complicating factors:</p>
<ul>
<li>FreeIPA <em>can</em> manage DNS entries, but it doesn’t have to. If FreeIPA is not a source of authoritative DNS information, should it trust information from external resolvers? Only with DNSSEC?</li>
<li>There may be multiple, conflicting sources of DNS records. The DNS <em>view</em> presented to FreeIPA clients may differ from that seen by other clients. The FreeIPA DNS may “shadow” public (or other) DNS records.</li>
<li>For validation, what should be the treatment of forward (<code>A</code> / <code>AAAA</code>) and reverse (<code>PTR</code>) records pertaining to the names involved?</li>
<li>Should <code>CNAME</code> records be followed? How many times?</li>
<li>The issued certificate may be used in or presented to clients in environments with a different DNS view from the environment in which validation was performed.</li>
<li>Does the request have to come from, or does the requesting entity have to prove control of, the IP address(es) requested for inclusion in the certificate?</li>
<li>IP addresses often change and a reassigned much more often than the typical lifetime of a certificate.</li>
<li>If you query external DNS systems, how do you handle failures or slowness?</li>
<li>The need to mitigate DNS or BGP poisoning attacks</li>
</ul>
<p>Taking these factors into account, it is plain to see why we put this feature off for so long. It is just hard to determine what the correct behaviour should be. Nevertheless use cases exist so the feature request is legitimate. The difference with <span class="title-ref">Ian's RFE</span> was that he proposed a strict validation regime that only uses data defined in FreeIPA. It is a fair assumption that the data managed by a FreeIPA instance is <em>trustworthy</em>. That assumption, combined with some sanity checks, gives the validation requirements:</p>
<ol type="1">
<li>Only FreeIPA-managed DNS records are considered. There is no communication with external DNS resolvers.</li>
<li>For each IP address in the SAN, there is a DNS name in the SAN that resolves to it. (As an implementation decision, we permit one level of CNAME indirection).</li>
<li>For each IP address in the SAN, there is a valid PTR (reverse DNS) record.</li>
<li>SAN IP addresses are only supported for host and service principals.</li>
</ol>
<p>Requirement <strong>1</strong> avoids dealing with any conflicts or communication issues with external resolvers. Requirements <strong>2</strong> and <strong>3</strong> together enforce a tight association between the subject principal (every DNS name is verified to belong to it) and the IP address (through forward and reverse resolution to the DNS name(s)).</p>
<h3 id="caveats-and-limitations">Caveats and limitations</h3>
<p>FreeIPA’s SAN IP address validation regime leads to the following caveats and limitations:</p>
<ul>
<li>The FreeIPA DNS component must be used. (It can be enabled during installation, or at any time after installation.)</li>
<li>Forward and reverse records of addresses to be included in certificates must be added and maintained.</li>
<li>SAN IP addresses must be accompanied by at least one DNS name. Requests with <em>only</em> IP addresses will be rejected.</li>
</ul>
<p>SAN IP address names in general have some limitations, too:</p>
<ul>
<li>The addresses in the certificate were correct at validation time, but might have changed. The only mitigations are to use short-lived certificates, or revoke certificates if DNS changes render them invalid. There is no detection or automation to assist with that.</li>
<li>The certificate could be misused by services in other networks with the same IP address. A well-behaved client would still have to trust the FreeIPA CA in order for this impersonation attack to work.</li>
</ul>
<h2 id="comparison-with-the-public-pki">Comparison with the public PKI</h2>
<p>SAN IP address names are supported by browsers. The CA/Browser Forum’s <a href="https://cabforum.org/baseline-requirements-documents/">Baseline Requirements</a> permit publicly-trusted CAs to issue end-entity certificates with SAN IP address values. CAs have to verify that the applicant controls (or has been granted the right to use) the IP address. There are several acceptable verification methods:</p>
<ol type="1">
<li>The applicant make some agreed-upon change to a network resource at the IP address in question;</li>
<li>Consulting IANA or regional NIC assignment information;</li>
<li>Performing reverse lookup then verifying control over the DNS name.</li>
</ol>
<p>The IETF <em>Automated Certificate Management Environment (ACME)</em> working group has an <a href="https://tools.ietf.org/html/draft-ietf-acme-ip">Internet-Draft for automated IP address validation</a> in the ACME protocol. It defines an automated approach to method <strong>1</strong> above. SAN IP addresses are <a href="https://community.letsencrypt.org/t/certificate-for-public-ip-without-domain-name/6082/91">not yet supported</a> by the most popular ACME CA, <em>Let’s Encrypt</em> (and might never be).</p>
<p>Depending on an organisation’s security goals, the verification methods mentioned above may or may not be appropriate for enterprise use (i.e. behind the firewall). Likewise, the decision about whether a particular kind of validation could or should be automated might have different answers for different organisations. It is not really a question of technical constraints; rather, one of philosophy and security doctrine. When it comes to certificate request validation, the public PKI and FreeIPA are asking different questions:</p>
<ul>
<li>FreeIPA asks: <em>does the indicated subject principal own the requested names?</em></li>
<li>The public PKI asks: <em>does the (potentially anonymous) applicant control the names they’re requestion?</em></li>
</ul>
<p>In a few words, it’s <em>ownership</em> versus <em>control</em>. In the future it might be possible for a FreeIPA CA to ask the latter question and issue certificates (or not) accordingly. But that isn’t the focus right now.</p>
<h2 id="demonstration">Demonstration</h2>
<h3 id="preliminaries">Preliminaries</h3>
<p>The scene is set. Let’s see this feature in action! The domain of my FreeIPA deployment is <code>ipa.local</code>. I will add a host called <code>iptest.example.com</code>, with the IP address <code>192.168.2.1</code>. The first step is to add the reverse zone for this IP address:</p>
<pre><code>% ipa dnszone-add --name-from-ip 192.168.2.1
Zone name [2.168.192.in-addr.arpa.]:
  Zone name: 2.168.192.in-addr.arpa.
  Active zone: TRUE
  Authoritative nameserver: f29-0.ipa.local.
  Administrator e-mail address: hostmaster
  SOA serial: 1550454790
  SOA refresh: 3600
  SOA retry: 900
  SOA expire: 1209600
  SOA minimum: 3600
  BIND update policy: grant IPA.LOCAL krb5-subdomain 2.168.192.in-addr.arpa. PTR;
  Dynamic update: FALSE
  Allow query: any;
  Allow transfer: none;</code></pre>
<p>If the reverse zone for the IP address already exists, there would be no need to do this first step.</p>
<p>Next I add the host entry. Supplying <code>--ip-address</code> causes forward and reverse records to be added for the supplied address (assuming the relevant zones are managed by FreeIPA):</p>
<pre><code>% ipa host-add iptest.ipa.local \
      --ip-address 192.168.2.1
-----------------------------
Added host &quot;iptest.ipa.local&quot;
-----------------------------
  Host name: iptest.ipa.local
  Principal name: host/iptest.ipa.local@IPA.LOCAL
  Principal alias: host/iptest.ipa.local@IPA.LOCAL
  Password: False
  Keytab: False
  Managed by: iptest.ipa.local</code></pre>
<h3 id="csr-generation">CSR generation</h3>
<p>There are several options for creating a certificate signing request (CSR) with IP addresses in the SAN extension.</p>
<ul>
<li>Lots of devices (routers, middleboxes, etc) generate CSRs containing their IP address. This is the significant driving use case for this feature, but there’s no point going into details because every device is different.</li>
<li>The <a href="https://pagure.io/certmonger">Certmonger</a> utility makes it easy to add DNS names and IP addresses to a CSR, via command line arguments. Several other name types are also supported. See <code>getcert-request(1)</code> for details.</li>
<li>OpenSSL requires a config file to specify SAN values for inclusing in CSRs and certificates. See <code>req(1)</code> and <code>x509v3_config(5)</code> for details.</li>
<li>The NSS <code>certutil(1)</code> command provides the <code>--extSAN</code> option for specifying SAN names, including DNS names and IP addresses.</li>
</ul>
<p>For this demonstration I use NSS and <code>certutil</code>. First I initialise a new certificate database:</p>
<pre><code>% mkdir nssdb ; cd nssdb ; certutil -d . -N
Enter a password which will be used to encrypt your keys.
The password should be at least 8 characters long,
and should contain at least one non-alphabetic character.

Enter new password:
Re-enter password:</code></pre>
<p>Next, I generate a key and create CSR with the desired names in the SAN extension. We do not specify a key type or size we get the default (2048-bit RSA).</p>
<pre><code>% certutil -d . -R -a -o ip.csr \
      -s CN=iptest.ipa.local \
      --extSAN dns:iptest.ipa.local,ip:192.168.2.1
Enter Password or Pin for &quot;NSS Certificate DB&quot;:

A random seed must be generated that will be used in the
creation of your key.  One of the easiest ways to create a
random seed is to use the timing of keystrokes on a keyboard.

To begin, type keys on the keyboard until this progress meter
is full.  DO NOT USE THE AUTOREPEAT FUNCTION ON YOUR KEYBOARD!


Continue typing until the progress meter is full:

|************************************************************|

Finished.  Press enter to continue:


Generating key.  This may take a few moments...</code></pre>
<p>The output file <code>ip.csr</code> contains the generated CSR. Let’s use OpenSSL to pretty-print it:</p>
<pre><code>% openssl req -text &lt; ip.csr
Certificate Request:
    Data:
        Version: 1 (0x0)
        Subject: CN = iptest.ipa.local
        Subject Public Key Info:
            &lt; elided &gt;
        Attributes:
        Requested Extensions:
            X509v3 Subject Alternative Name:
                DNS:iptest.ipa.local, IP Address:192.168.2.1
    Signature Algorithm: sha256WithRSAEncryption
         &lt; elided &gt;</code></pre>
<p>It all looks correct.</p>
<h3 id="issuing-the-certificate">Issuing the certificate</h3>
<p>I use the <code>ipa cert-request</code> command to request a certificate. The host <code>iptest.ipa.local</code> is the subject principal. The default profile is appropriate.</p>
<pre><code>% ipa cert-request ip.csr \
      --principal host/iptest.ipa.local \
      --certificate-out ip.pem
  Issuing CA: ipa
  Certificate: &lt; elided &gt;
  Subject: CN=iptest.ipa.local,O=IPA.LOCAL 201902181108
  Subject DNS name: iptest.ipa.local
  Issuer: CN=Certificate Authority,O=IPA.LOCAL 201902181108
  Not Before: Mon Feb 18 03:24:48 2019 UTC
  Not After: Thu Feb 18 03:24:48 2021 UTC
  Serial number: 10
  Serial number (hex): 0xA</code></pre>
<p>The command succeeded. As requested, the issued certificate has been written to <code>ip.pem</code>. Again we’ll use OpenSSL to inspect it:</p>
<pre><code>% openssl x509 -text &lt; ip.pem
Certificate:                                                                                                                                                                                               [42/694]
    Data:
        Version: 3 (0x2)
        Serial Number: 10 (0xa)
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: O = IPA.LOCAL 201902181108, CN = Certificate Authority
        Validity
            Not Before: Feb 18 03:24:48 2019 GMT
            Not After : Feb 18 03:24:48 2021 GMT
        Subject: O = IPA.LOCAL 201902181108, CN = iptest.ipa.local
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (2048 bit)
                Modulus:
                    &lt; elided &gt;
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Authority Key Identifier:
                keyid:70:C0:D3:02:EA:88:4A:4D:34:4C:84:CD:45:5F:64:8A:0B:59:54:71

            Authority Information Access:
                OCSP - URI:http://ipa-ca.ipa.local/ca/ocsp

            X509v3 Key Usage: critical
                Digital Signature, Non Repudiation, Key Encipherment, Data Encipherment
            X509v3 Extended Key Usage:
                TLS Web Server Authentication, TLS Web Client Authentication
            X509v3 CRL Distribution Points:

                Full Name:
                  URI:http://ipa-ca.ipa.local/ipa/crl/MasterCRL.bin
                CRL Issuer:
                  DirName:O = ipaca, CN = Certificate Authority

            X509v3 Subject Key Identifier:
                3D:A9:7E:E3:05:D6:03:6A:9E:85:BB:72:69:E1:E7:11:92:6F:29:08
            X509v3 Subject Alternative Name:
                DNS:iptest.ipa.local, IP Address:192.168.2.1
    Signature Algorithm: sha256WithRSAEncryption
         &lt; elided &gt;</code></pre>
<p>We can see that the Subject Alternative Name extension is present, and included the expected values.</p>
<h3 id="error-scenarios">Error scenarios</h3>
<p>It’s nice to see that we can get a certificate with IP address names. But it’s more important to know that we <em>cannot</em> get an IP address certificate when the validation requirements are not satisfied. I’ll run through a number of scenarios and show the results (without showing the whole procedure, which would repeat a lot of information).</p>
<p>If we omit the DNS name from the SAN extension, there is nothing linking the IP address to the subject principal and the request will be rejected. Note that the Subject DN Common Name (CN) attribute is ignored for the purposes of SAN IP address validation. The CSR was generated using <code>--extSAN ip:192.168.2.1</code>.</p>
<pre><code>% ipa cert-request ip-bad.csr --principal host/iptest.ipa.local
ipa: ERROR: invalid &#39;csr&#39;: IP address in
  subjectAltName (192.168.2.1) unreachable from DNS names</code></pre>
<p>If we reinstate the DNS name but add an extra IP address that does not relate to the hostname, the request gets rejected. The CSR was generated using <code>--extSAN dns:iptest.ipa.local,ip:192.168.2.1,ip:192.168.2.2</code>.</p>
<pre><code>% ipa cert-request ip-bad.csr --principal host/iptest.ipa.local
ipa: ERROR: invalid &#39;csr&#39;: IP address in
  subjectAltName (192.168.2.2) unreachable from DNS names</code></pre>
<p>Requesting a certificate for a user principal fails. The CSR has Subject DN <code>CN=alice</code> and the SAN extension contain an IP address. The user principal <code>alice</code> does exist.</p>
<pre><code>% ipa cert-request ip-bad.csr --principal alice
ipa: ERROR: invalid &#39;csr&#39;: subject alt name type
  IPAddress is forbidden for user principals</code></pre>
<p>Let’s return to our original, working CSR. If we alter the relevant PTR record so that it no longer points a DNS name in the SAN (or the canonical name thereof), the request will fail:</p>
<pre><code>% ipa dnsrecord-mod 2.168.192.in-addr.arpa. 1 \
      --ptr-rec f29-0.ipa.local.
  Record name: 1
  PTR record: f29-0.ipa.local.

% ipa cert-request ip.csr --principal host/iptest.ipa.local
ipa: ERROR: invalid &#39;csr&#39;: IP address in
  subjectAltName (192.168.2.1) does not match A/AAAA records</code></pre>
<p>Similarly if we delete the PTR record, the request fails (with a different message):</p>
<pre><code>% ipa dnsrecord-del 2.168.192.in-addr.arpa. 1 \
      --ptr-rec f29-0.ipa.local.
------------------
Deleted record &quot;1&quot;
------------------

% ipa cert-request ip.csr --principal host/iptest.ipa.local
ipa: ERROR: invalid &#39;csr&#39;: IP address in
  subjectAltName (192.168.2.1) does not have PTR record</code></pre>
<h3 id="ipv6">IPv6</h3>
<p>Assuming the relevant reverse zone is managed by FreeIPA and contains the correct records, FreeIPA can issue certificates with IPv6 names. First I have to add the relevant zones and records. I’m using the machine’s link-local address but the commands will be similar for other IPv6 addresses.</p>
<pre><code>% ipa dnsrecord-mod ipa.local. iptest \
      --a-rec=192.168.2.1 \
      --aaaa-rec=fe80::8f18:bdab:4299:95fa
  Record name: iptest
  A record: 192.168.2.1
  AAAA record: fe80::8f18:bdab:4299:95fa

% ipa dnszone-add \
      --name-from-ip fe80::8f18:bdab:4299:95fa
Zone name [0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f.ip6.arpa.]:
  Zone name: 0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f.ip6.arpa.
  Active zone: TRUE
  Authoritative nameserver: f29-0.ipa.local.
  Administrator e-mail address: hostmaster
  SOA serial: 1550468242
  SOA refresh: 3600
  SOA retry: 900
  SOA expire: 1209600
  SOA minimum: 3600
  BIND update policy: grant IPA.LOCAL krb5-subdomain 0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f.ip6.arpa. PTR;
  Dynamic update: FALSE
  Allow query: any;
  Allow transfer: none;

% ipa dnsrecord-add \
      0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f.ip6.arpa. \
      a.f.5.9.9.9.2.4.b.a.d.b.8.1.f.8 \
      --ptr-rec iptest.ipa.local.
  Record name: a.f.5.9.9.9.2.4.b.a.d.b.8.1.f.8
  PTR record: iptest.ipa.local.</code></pre>
<p>With these in place I’ll generate the CSR and issue the certificate. (This time I’ve used the <code>-f</code> and <code>-z</code> options to reduce user interaction.)</p>
<pre><code>% certutil -d . -f pwdfile.txt \
    -z &lt;(dd if=/dev/random bs=2048 count=1 status=none) \
    -R -a -o ip.csr -s CN=iptest.ipa.local \
    --extSAN dns:iptest.ipa.local,ip:fe80::8f18:bdab:4299:95fa


Generating key.  This may take a few moments...

% ipa cert-request ip.csr \
      --principal host/iptest.ipa.local \
      --certificate-out ip.pem
  Issuing CA: ipa
  Certificate: &lt; elided &gt;
  Subject: CN=iptest.ipa.local,O=IPA.LOCAL 201902181108
  Subject DNS name: iptest.ipa.local
  Issuer: CN=Certificate Authority,O=IPA.LOCAL 201902181108
  Not Before: Mon Feb 18 05:49:01 2019 UTC
  Not After: Thu Feb 18 05:49:01 2021 UTC
  Serial number: 12
  Serial number (hex): 0xC</code></pre>
<p>The issuance succeeded. Observe that the IPv6 address is present in the certificate:</p>
<pre><code>% openssl x509 -text &lt; ip.pem | grep -A 1 &quot;Subject Alt&quot;
    X509v3 Subject Alternative Name:
      DNS:iptest.ipa.local, IP Address:FE80:0:0:0:8F18:BDAB:4299:95FA</code></pre>
<p>Of course, it is possible to issue certificates with multiple IP addresses, including a mix of IPv4 and IPv6. Assuming all the necessary DNS records exist, with</p>
<pre><code>--extSAN ip:fe80::8f18:bdab:4299:95fa,ip:192.168.2.1,dns:iptest.ipa.local</code></pre>
<p>The resulting certificate will have the SAN:</p>
<pre><code>IP Address:FE80:0:0:0:8F18:BDAB:4299:95FA, IP Address:192.168.2.1, DNS:iptest.ipa.local</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>In this post I discussed the challenges of verifying IP addresses for inclusion in X.509 certificates. I discussed the approach we are taking in FreeIPA to finally support this, including its caveats and limitations. For comparison, I outlined how IP address verification is done by CAs on the open internet.</p>
<p>I then demonstrated how the feature will work in FreeIPA. Importantly, I showed (though not <em>exhaustively</em>), that FreeIPA refuses to issue the certificate if the verification requirements are not met. It is a bit hard to demonstrate, from a user perspective, that we only consult FreeIPA’s own DNS records and never consult another DNS server. But hey, <a href="https://github.com/freeipa/freeipa/pull/1843">the code is open source</a> so you can satisfy yourself that the behaviour fulfils the requirements (or leave a review / file an issue if you find that it does not!)</p>
<p>When will the feature land in <code>master</code>? Before the feature can be merged, I still need to write acceptance tests and have the feature reviewed by another FreeIPA developer. I am hoping to finish the work this week.</p>
<p>As a final remark, I must again acknowledge Ian Pilcher’s significant contribution. Were it not for him, it is likely that this longstanding RFE would still be in our <em>“too hard”</em> basket. Ian, thank you for your patience and I hope that your efforts are rewarded very soon with the feature finally being merged.</p>]]></summary>
</entry>
<entry>
    <title><code>staticmethod</code> considered beneficial</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-02-07-staticmethod-considered-beneficial.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-02-07-staticmethod-considered-beneficial.html</id>
    <published>2019-02-07T00:00:00Z</published>
    <updated>2019-02-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="staticmethod-considered-beneficial"><code>staticmethod</code> considered beneficial</h1>
<p>Some Python programmers hold that the <code>staticmethod</code> decorator, and to a lesser extent <code>classmethod</code>, are to be avoided where possible. This view is not correct, and in this post I will explain why.</p>
<p>This post will be useful to programmers in any language, but especially Python.</p>
<h2 id="the-constructions">The constructions</h2>
<p>I must begin with a brief overview of the <code>classmethod</code> and <code>staticmethod</code> constructions and their uses.</p>
<p><code>classmethod</code> is a function that transforms a method into a class method. The class method receives the <em>class object</em> as its first argument, rather than an <em>instance</em> of the class. It is typically used as a method <em>decorator</em>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">class</span> C:</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="at">@classmethod</span></a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="kw">def</span> f(cls, arg1, arg2, ...): ...</a></code></pre></div>
<p>By idiom, the class object argument is bound to the name <code>cls</code>. You can invoke a class method via an instance (<code>C().f()</code>) or via the class object itself (<code>C.f()</code>). In return for this flexibility you give up the ability to access instance methods or attributes from the method body, even when it was called via an instance.</p>
<p><code>staticmethod</code> is nearly identical to <code>classmethod</code>. The only difference is that instead of receiving the class object as the first argument, it does not receive any implicit argument:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">class</span> C:</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="at">@staticmethod</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="kw">def</span> f(arg1, arg2, ...): ...</a></code></pre></div>
<p>How are the <code>classmethod</code> and <code>staticmethod</code> constructions used? Consider the following (contrived) class:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">class</span> Foo(<span class="bu">object</span>):</a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3">  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, delta):</a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="va">self</span>.delta <span class="op">=</span> delta</a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6">  <span class="kw">def</span> forty_two(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="cf">return</span> <span class="dv">42</span></a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9">  <span class="kw">def</span> answer(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb3-10" title="10">    <span class="cf">return</span> <span class="va">self</span>.forty_two()</a>
<a class="sourceLine" id="cb3-11" title="11"></a>
<a class="sourceLine" id="cb3-12" title="12">  <span class="kw">def</span> modified_answer(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb3-13" title="13">    <span class="cf">return</span> <span class="va">self</span>.answer() <span class="op">+</span> <span class="va">self</span>.delta</a></code></pre></div>
<p>There are some places we could use <code>staticmethod</code> and <code>classmethod</code>. Should we? Let’s just do it and discuss the impact of the changes:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">class</span> Foo(<span class="bu">object</span>):</a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3">  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, delta):</a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="va">self</span>.delta <span class="op">=</span> delta</a>
<a class="sourceLine" id="cb4-5" title="5"></a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="at">@staticmethod</span></a>
<a class="sourceLine" id="cb4-7" title="7">  <span class="kw">def</span> forty_two():</a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="cf">return</span> <span class="dv">42</span></a>
<a class="sourceLine" id="cb4-9" title="9"></a>
<a class="sourceLine" id="cb4-10" title="10">  <span class="at">@classmethod</span></a>
<a class="sourceLine" id="cb4-11" title="11">  <span class="kw">def</span> answer(cls):</a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="cf">return</span> cls.forty_two()</a>
<a class="sourceLine" id="cb4-13" title="13"></a>
<a class="sourceLine" id="cb4-14" title="14">  <span class="kw">def</span> modified_answer(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb4-15" title="15">    <span class="cf">return</span> <span class="va">self</span>.answer() <span class="op">+</span> <span class="va">self</span>.delta</a></code></pre></div>
<p><code>forty_two</code> became a static method, and it no longer takes any argument. <code>answer</code> became a class method, and its <code>self</code> argument became <code>cls</code>. It cannot become a static method, because it references <code>cls.forty_two</code>. <code>modified_answer</code> can’t change at all, because it references an instance attribute (<code>self.delta</code>). <code>forty_two</code> could have been made a class method, but just as it had no need of <code>self</code>, it has no need <code>cls</code> either.</p>
<p>There is an alternative refactoring for <code>forty_two</code>. Because it doesn’t reference anything in the class, we could have extracted it as a top-level function (i.e. defined not in the class but directly in a module). Conceptually, <code>staticmethod</code> and top-level functions are equivalent modulo namespacing.</p>
<p>Was the change I made a good one? Well, you already know my answer will be <em>yes</em>. Before I justify my position, let’s discuss some counter-arguments.</p>
<h2 id="why-not-staticmethod-or-classmethod">Why not <code>staticmethod</code> or <code>classmethod</code>?</h2>
<p>Most Python programmers accept that alternative constructors, factories and the like are legitimate applications of <code>staticmethod</code> and <code>classmethod</code>. Apart from these applications, opinions vary.</p>
<ul>
<li>For some folks, the above are the <em>only</em> acceptable uses.</li>
<li>Some accept <code>staticmethod</code> for grouping utility functions closely related to some class, into that class; others regard this kind of <code>staticmethod</code> proliferation as a code smell.</li>
<li>Some feel that anything likely to only ever be called on an instance should use instance methods, i.e. having <code>self</code> as the first argument, even when not needed.</li>
<li>The decorator syntax “noise” seems to bother some people</li>
</ul>
<p>Guido van Rossum, author and BDFL of Python, <a href="https://mail.python.org/pipermail/python-ideas/2012-May/014969.html">wrote</a> that static methods were an accident. History is interesting, sure, but not all accidents are automatically bad.</p>
<p>I am sympathetic to some of these arguments. A class with a lot of static methods might just be better off as a module with top-level functions. It is true that <code>staticmethod</code> is not required for anything whatsoever and could be dispensed with (this is not true of <code>classmethod</code>). And clean code is better than noisy code. Surely if you’re going to clutter your class with decorators, you want something in return right? Well, you do get something in return.</p>
<h2 id="deny-thy-self">Deny thy <code>self</code></h2>
<p>Let us put to the side the side-argument of <code>staticmethod</code> versus top-level functions. The real debate is <em>instance methods</em> versus <em>not instance methods</em>. This is the crux. Why avoid instance methods (where possible)? Because doing so is a win for readability.</p>
<p>Forget the contrived <code>Foo</code> class from above and imagine you are in a non-trivial codebase. You are hunting a bug, or maybe trying to understand what some function does. You come across an interesting function. It is 50 lines long. What does it do?</p>
<p>If you are reading an instance method, in addition to its arguments, the module namespace, imports and builtins, it has access to <code>self</code>, the instance object. If you want to know what the function does or doesn’t do, you’ll have to read it.</p>
<p>But if that function is a <code>classmethod</code>, you now have <em>more information</em> about this function—namely that it cannot access any instance methods, even if it was invoked on an instance (including from within a sibling instance method). <code>staticmethod</code> (or a top-level function) gives you a bit more than this: not even class methods can be accessed (unless directly referencing the class, which is easily detected and definitely a code smell). By using these constructions when possible, the programmer has less to think about as they read or modify the function.</p>
<p>You can flip this scenario around, too. Say you know a program is failing in some <em>instance</em> method, but you’re not sure how the problematic code is reached. Well, you can rule out the class methods and static methods straight away.</p>
<p>These results are similar to the result of <a href="http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=F63444BB6DD3E18607EA7B3677036F09?doi=10.1.1.38.9875&amp;rep=rep1&amp;type=pdf">parametricity</a> in programming language theory. The profound and <em>actionable</em> observation in both settings is this: knowing <em>less</em> about something gives the programmer <em>more</em> information about its behaviour.</p>
<p>These might not seem like big wins. Because most of the time it’s only a small win. But it’s never a lose, and over the life of a codebase or the career of a programmer, the small readability wins add up. To me, this is a far more important goal than avoiding extra lines of code (decorator syntax), or spurning a feature because its author considers it an accident or it transgresses the <a href="https://www.python.org/dev/peps/pep-0020/">Zen of Python</a> or whatever.</p>
<p>But speaking of the Zen of Python…</p>
<blockquote>
<p>Readability counts.</p>
</blockquote>
<p>So use <code>classmethod</code> or <code>staticmethod</code> wherever you can.</p>]]></summary>
</entry>
<entry>
    <title>How does Dogtag PKI spawn?</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-02-04-dogtag-installation.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-02-04-dogtag-installation.html</id>
    <published>2019-02-04T00:00:00Z</published>
    <updated>2019-02-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="how-does-dogtag-pki-spawn">How does Dogtag PKI spawn?</h1>
<p>Dogtag PKI is a complex program. Anyone who has performed a standalone installation of Dogtag can attest to this (to say nothing of actually using it). The program you invoke to install Dogtag is called <code>pkispawn(8)</code>. When installing standalone, you invoke <code>pkispawn</code> directly. When FreeIPA installs a Dogtag instance, it invokes <code>pkispawn</code> behind the scenes.</p>
<p>So what does <code>pkispawn</code> actually <em>do</em>? In this post I’ll explain how <code>pkispawn</code> actually spawns a Dogtag instance. This post is not intended to be a guide to the many configuration options <code>pkispawn</code> knows about (although we’ll cover several). Rather, I’ll explain the actions <code>pkispawn</code> performs (or causes to be performed) to go from a fresh system to a working Dogtag CA instance.</p>
<p>This post is aimed at developers and support associates, and to a lesser extent, people who are trying to diagnose issues themselves or understand how to accomplish something fancy in their Dogtag installation. By explaining the steps involved in spawning a Dogtag instance, I hope to make it easier for readers to diagnose issues or implement fixes or enhancements.</p>
<h2 id="pkispawn-overview"><code>pkispawn</code> overview</h2>
<p><code>pkispawn(8)</code> is provided by the <code>pki-server</code> RPM (which is required by the <code>pki-ca</code> RPM that provides the CA subsystem).</p>
<p>You can invoke <code>pkispawn</code> without arguments, and it will prompt for the minimal data it needs to continue. These data include the subsystem to install (e.g. <code>CA</code> or <code>KRA</code>), and LDAP database connection details. For a fresh installation, most defaults are acceptable.</p>
<p>There are many ways to configure or customise an installation. A few important scenarios are:</p>
<ul>
<li>installing a <code>KRA</code>, <code>OCSP</code>, <code>TKS</code> or <code>TPS</code> subsystem associated with the existing <code>CA</code> subsystem (typically on the same machine as the <code>CA</code> subsystem).</li>
<li>installing a <em>clone</em> of a subsystem (typically on a different machine)</li>
<li>installing a CA subsystem with an externally-signed CA certificate</li>
<li>non-interactive installation</li>
</ul>
<p>For the above scenarios, and for many other possible variations, it is necessary to give <code>pkispawn</code> a configuration file. The <code>pki_default.cfg(5)</code> man page describes the format and available options. Some options are relevant to all subsystems, and others are subsystem-specific (i.e. only for <code>CA</code>, or <code>KRA</code>, etc.) Here is a basic configuration:</p>
<pre><code>[DEFAULT]
pki_server_database_password=Secret.123

[CA]
pki_admin_email=caadmin@example.com
pki_admin_name=caadmin
pki_admin_nickname=caadmin
pki_admin_password=Secret.123
pki_admin_uid=caadmin

pki_client_database_password=Secret.123
pki_client_database_purge=False
pki_client_pkcs12_password=Secret.123

pki_ds_base_dn=dc=ca,dc=pki,dc=example,dc=com
pki_ds_database=ca
pki_ds_password=Secret.123

pki_security_domain_name=EXAMPLE

pki_ca_signing_nickname=ca_signing
pki_ocsp_signing_nickname=ca_ocsp_signing
pki_audit_signing_nickname=ca_audit_signing
pki_sslserver_nickname=sslserver
pki_subsystem_nickname=subsystem</code></pre>
<p>The <code>-f</code> option tells <code>pkispawn</code> the configuration file to use. <code>-s CA</code> tell it install the CA subsystem.</p>
<pre><code>$ pkispawn -f ca.cfg -s CA</code></pre>
<p>For many more examples of how to install Dogtag subsystems for particular scenarios, see the <a href="https://www.dogtagpki.org/wiki/PKI_10_Installation">PKI 10 Installation guide</a> on the Dogtag wiki.</p>
<h2 id="terminology">Terminology</h2>
<p>It is worthwhile to clarify the meaning of some terms:</p>
<dl>
<dt><em>instance</em> or <em>installation</em></dt>
<dd><p>An installation of Dogtag on a particular machine. An instance may contain one or more <em>subsystems</em>. There may be more than one Dogtag instance on a single machine, although this is uncommon (and each instance must use a disjoint set of network ports). The default instance name is <code>pki-tomcat</code>.</p>
</dd>
<dt><em>subsystem</em></dt>
<dd><p>Each main function in Dogtag is provided by a subsystem. The subsystems are: <code>CA</code>, <code>KRA</code>, <code>OCSP</code>, <code>TKS</code> and <code>TPS</code>. Every Dogtag instance must have a <code>CA</code> subsystem (hence, the first subsystem installed must be the <code>CA</code> subsystem).</p>
</dd>
<dt><em>clone</em></dt>
<dd><p>For redundancy, a subsystem may be <em>cloned</em> to a different instance (usually on a different machine; this is not a technical requirement but it does not make sense to do otherwise). Different subsystems may have different numbers of clones in a topology.</p>
</dd>
<dt><em>topology</em> or <em>deployment</em></dt>
<dd><p>All of the clones of all subsystems derived from some original CA subsystem form a <em>deployment</em> or <em>topology</em>. Typically, each <em>instance</em> in the topology would have a replicated copy of the LDAP database.</p>
</dd>
</dl>
<h2 id="pkispawn-implementation"><code>pkispawn</code> implementation</h2>
<h3 id="two-main-phases">Two main phases</h3>
<p><code>pkispawn</code> has two main phases:</p>
<ol type="1">
<li>set up the Tomcat server and Dogtag application</li>
<li>send <em>configuration requests</em> to the Dogtag application, which performs further configuration steps.</li>
</ol>
<p>(This is not to be confused with a <em>two step</em> externally-signed CA installation.)</p>
<p>Of course there are many more steps than this. But there is an important reasons I am making such a high-level distinction: debugging. In the first phase <code>pkispawn</code> does everything. Any errors will show up in the <code>pkispawn</code> log file (<code>/var/log/pki/pki-&lt;subsystem&gt;-&lt;timestamp&gt;.log</code>). It is usually straightforward to work out what failed. <em>Why</em> it failed is sometimes easy to work out, and sometimes not so easy.</p>
<p>But in the second phase, <code>pkispawn</code> is handing over control to Dogtag to finish configuring itself. <code>pkispawn</code> sends a series of requests to the <code>pki-tomcatd</code> web application. These requests tell Dogtag to configure things like the database, security domain, and so on. If something goes wrong during these steps, you <em>might</em> see something useful in the <code>pkispawn</code> log, but you will probably also need to look at the Dogtag <code>debug</code> log, or even the Tomcat or Dogtag logs of another subsystem or clone. I detailed this (in the context of debugging clone installation failures) in <a href="">a previous post</a>.</p>
<h3 id="scriptlets">Scriptlets</h3>
<p><code>pkispawn</code> is implemented in Python. The various steps of installation are implemented as <em>scriptlets</em>: small subroutines that take care of one part of the installation. These are:</p>
<ol type="1">
<li><code>initialization</code>: sanity check and normalise installer configuration, and sanity check the system environment.</li>
<li><code>infrastructure_layout</code>: create PKI instance directories and configuration files.</li>
<li><code>instance_layout</code>: lay out the Tomcat instance and configuration files (skipped when spawning a second subsystem on an existing instance).</li>
<li><code>subsystem_layout</code>: lay out subsystem-specific files and directories.</li>
<li><code>webapp_deployment</code>: deploy the Tomcat web application.</li>
<li><code>security_databases</code>: set up the main Dogtag NSS database, and a client database where the administrator key and certificate will be created.</li>
<li><code>selinux_setup</code>: establish correct SELinux contexts on instance and subsystem files.</li>
<li><code>keygen</code>: generate keys and CSRs for the subsystem (for the CA subsystem, this inclues the CA signing key and CSR for external signing).</li>
<li><code>configuration</code>: For external CA installation, import the externally-signed CA certificate and chain. (Re)start the <code>pki-tomcatd</code> instance and send configuration requests to the Java application. The whole second phase discussed in the previous section occurs here. It will be discussed in more detail in the next section.</li>
<li><code>finalization</code>: enable PKI to start on boot (by default) and optionally purge client NSS databases that were set up during installation.</li>
</ol>
<p>For a two-step externally-signed CA installation, the <code>configuration</code> and <code>finalization</code> scriptlets are skipped during step 1, and in step 2 the scriptlets up to and including <code>keygen</code> are skipped. (A bit of hand-waving here; they not not really skipped but return early).</p>
<p>In the codebase, scriptlets are located under <code>base/server/python/pki/server/deployment/scriptlets/&lt;name&gt;.py</code>. The list of scriptlets and the order in which they’re run is given by the <code>spawn_scriplets</code> variable in <code>base/server/etc/default.cfg</code>. Note that <code>scriplet</code> there is not a typo. Or maybe it is, but it’s not <em>my</em> typo. In some parts of the codebase, we say <em>scriplet</em>, and in others it’s <em>scriptlet</em>. This is mildly annoying, but you just have to be careful to use the correct class or variable name.</p>
<p>Some other Python files contain a lot of code used during deployment. It’s not reasonable to make an exhaustive list, but <code>pki.server.deployment.pkihelper</code> and <code>pki.server.deployment.pkiparser</code> in particular include a lot of configuration processing code. If you are implementing or changing <code>pkispawn</code> configuration options, you’ll be defining them and following changes around in these files (and possibly others), as well as in <code>base/server/etc/default.cfg</code>.</p>
<h4 id="scriptlets-and-uninstallation">Scriptlets and uninstallation</h4>
<p>The installation scriptlets also implement corresponding uninstallation behaviours. When uninstalling a Dogtag instance or subsystem via the <code>pkidestroy</code> command, each scriptlets’ uninstallation behaviour is invoked. The order in which they’re invoked is different from installation, and is given by the <code>destroy_scriplets</code> variable in <code>base/server/etc/default.cfg</code>.</p>
<h3 id="configuration-requests">Configuration requests</h3>
<p>The <code>configuration</code> scriptlet sends a series of configuration requests to the Dogtag web API. Each request causes Dogtag to perform specific configuration behaviour(s). Depending on the subsystem being installed and whether it is a clone, these steps may including communication with other subsystems or instances, and/or the LDAP database.</p>
<p>The requests performed, in order, are:</p>
<ol type="1">
<li><code>/rest/installer/configure</code>: configure (but don’t yet create) the security domain. Import and verify certificates. If creating a clone, request number range allocations from the master.</li>
<li><code>/rest/installer/setupDatabase</code>: add database connection configuration to <code>CS.cfg</code>. Enable required DS plugins. Populate the database. If creating a clone, initialise replication (this can be suppressed if replication is managed externally, as is the case for FreeIPA in Domain Level 1). Populate VLV indices.</li>
<li><code>/rest/installer/configureCerts</code>: configure system certificates, generating keys and issuing certificates where necessary.</li>
<li><code>/rest/installer/setupAdmin</code> (skipped for clones): create admin user and issue certificate.</li>
<li><code>/rest/installer/backupKeys</code> (optional): back up system certificates and keys to a PKCS #12 file.</li>
<li><code>/rest/installer/setupSecurityDomain</code>: create the security domain data in LDAP (non-clone) or add the new clone to the security domain.</li>
<li><code>/rest/installer/setupDatabaseUser</code>: set up the LDAP database user, including certificate (if configured). This is the user that Dogtag uses to bind to LDAP.</li>
<li><code>/rest/installer/finalizeConfiguration</code>: remove <em>preop</em> configuration entries (which are only used during installation) and perform other finalisation in <code>CS.cfg</code>.</li>
</ol>
<p>For all of these requests, the <code>configuration</code> scriptlet builds the request data according to the <code>pkispawn</code> configuration. Then it sends the request to the current hostname. Communications between <code>pkispawn</code> and Tomcat are unlikely to fail (connection failure would suggest a major network configuration problem).</p>
<p>If something goes wrong during processing of the request, errors should appear in the subsystem debug log (<code>/etc/pki/pki-tomcat/ca/debug.YYYY-MM-DD.log</code>; <code>/etc/pki/pki-tomcat/ca/debug</code> on older versions), or the system journal. If the local system had to contact other subsystems or instances on other hosts, it may be necessary to look at the debug logs, system journal or Tomcat / Apache httpd logs of the relevant host / subsystem. I wrote about this at length in <a href="">a previous post</a> so I won’t say more about it here.</p>
<p>In terms of the code, the resource paths and servlet interface are defined in <code>com.netscape.certsrv.system.SystemConfigResource</code>. The implementation is in <code>com.netscape.certsrv.system.SystemConfigService</code>, with a considerable amount of behaviour residing as helper methods in <code>com.netscape.cms.servlet.csadmin.ConfigurationUtils</code>. If you are investigating or fixing configuration request failures, you will spend a fair bit of time grubbing around in these classes.</p>
<h2 id="conclusion">Conclusion</h2>
<p>As I have shown in this post, spawning a Dogtag PKI instance involves a lot of steps. There are many, <em>many</em> ways to customise the installation and I have glossed over many details. But my aim in this post was not to be a comprehensive reference guide or how-to. Rather the intent was to give a high-level view of what happens during installation, and how those behaviours are implemented. Hopefully I have achieved that, and as a result you are now able to more easily diagnose issues or implement changes or features in the Dogtag installer.</p>]]></summary>
</entry>
<entry>
    <title>X.509 Name Constraints and FreeIPA</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-01-29-name-constraints.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-01-29-name-constraints.html</id>
    <published>2019-01-29T00:00:00Z</published>
    <updated>2019-01-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="x.509-name-constraints-and-freeipa">X.509 Name Constraints and FreeIPA</h1>
<p>The X.509 <em>Name Constraints</em> extension is a mechanism for constraining the name space(s) in which a <em>certificate authority (CA)</em> may (or may not) issue <em>end-entity</em> certificates. For example, a CA could issue to <em>Bob’s Widgets, Inc</em> a contrained CA certificate that only allows the CA to issue server certificates for <code>bobswidgets.com</code>, or subdomains thereof. In a similar way, an enterprise root CA could issue constrained certificates to different departments in a company.</p>
<p>What is the advantage? Efficiency can be improved without sacrificing security by enabling <em>scoped</em> delegation of certificate issuance capability to subordinate CAs controlled by different organisations. The name constraints extension is essential for the security of such a mechanism. The <em>Bob’s Widgets, Inc</em> CA must not be allowed to issue valid certificates for <code>google.com</code> (and vice versa!)</p>
<p>FreeIPA supports installation with an externally signed CA. It is possible that such a CA certificate could have a name constraints extension, defined and imposed by the external issuer. Does FreeIPA support this? What are the caveats? In this blog post I will describe in detail how Name Constraints work and the state of FreeIPA support. Along the way I will dive into the state of Name Constraints verfication in the NSS security library. And I will conclude with a discussion of limitations, alternatives and complementary controls.</p>
<h2 id="name-constraints">Name Constraints</h2>
<p>The Name Constraints extension is <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.10">defined in RFC 5280</a>. Just as the <em>Subject Alternative Name (SAN)</em> is a list of <code>GeneralName</code> values with various possible types (DNS name, IP address, DN, etc), the Name Constraints extension also contains a list of <code>GeneralName</code> values. The difference is in interpretation. In the Name Constraints extension:</p>
<ul>
<li>A DNS name means that the CA may issue certificates with DNS names in the given domain, or a subdomain of arbitrary depth.</li>
<li>An IP address is interpreted as a CIDR address range.</li>
<li>A directory name is interpreted as a base DN.</li>
<li>An RFC822 name can be a single mailbox, all mailboxes at a particular host, or all mailboxes at a particular domain (including subdomains).</li>
<li>The <code>SRVName</code> name type, and corresponding Name Constraints matching rules, are defined in <a href="https://tools.ietf.org/html/rfc4985#section-4">RFC 4985</a>.</li>
</ul>
<p>There are other rules for other name types, but I won’t elaborate them here.</p>
<p>In X.509 terminology, these name spaces are called <em>subtrees</em>. The Name Constraints extension can define <em>permitted subtrees</em> and/or <em>excluded subtrees</em>. Permitted subtrees is more often used because it defines what is allowed, and anything not explicitly allowed is prohibited. It is possible for a single Name Constraints extension to define both permitted and excluded subtrees. But I have never seen this in the wild, and I will not bother explaining the rules.</p>
<p>When validating a certificate, the Name Constraints subtrees of all CA certificates in the certification path are merged, and the certificate is checked against the merged results. Name values in the SAN extension are compared to Name Constraint subtrees of the same type (the comparison rules differ for each name type.)</p>
<p>In addition to comparing SAN names against Name Constraints, there are a couple of additional requirements:</p>
<ul>
<li><code>directoryName</code> constraints are checked against the whole Subject DN, in additional to <code>directoryName</code> SAN values.</li>
<li><code>rfc822Name</code> constraints are checked against the <code>emailAddress</code> Subject DN attribute (if present) in addition to <code>rfc822Name</code> SAN values. (Use of the <code>emailAddress</code> attribute is deprecated in favour of <code>rfc822Name</code> SAN values.)</li>
</ul>
<p>Beyond this, because of the legacy <em>de facto</em> use of the Subject DN CN attribute to carry DNS names, several implementations check the CN attribute against <code>dnsName</code> constraints. This behaviour is not defined (let alone required) by RFC 5280. It is reasonable behaviour when dealing with server certificates. But we will see that this behaviour can lead to problems in other scenarios.</p>
<p>It is important to mention that nothing prevents a constrained CA from issuing a certificate that violates its Name Constraints (either direct or transitive). Validation must be performed by a client. If a client does not validate Name Constraints, then even a (trusted) issuing CA with a <code>permittedSubtrees</code> <code>dnsName</code> constraint of <code>bobswidgets.com</code> could issue a certificate for <code>google.com</code> and the client will accept it. Fortunately, modern web browsers strictly enforce DNS name constraints. For other clients, or other name types, Name Constraint enforcement support is less consistent. I haven’t done a thorough survey yet but you should make your own investigations into the state of Name Constraint validation support in libraries or programs relevant to your use case.</p>
<h2 id="freeipa-support-for-constrained-ca-certificates">FreeIPA support for constrained CA certificates</h2>
<p>It is common to deploy FreeIPA with a subordinate CA certificate signed by an external CA (e.g. the organisation’s Active Directory CA). If the FreeIPA deployment controls the <code>ipa.bobswidgets.com</code> subdomain, then it is reasonable for the CA administrator to issue the FreeIPA CA certificate with a Name Constraints <code>permittedSubtree</code> of <code>ipa.bobswidgets.com</code>. Will this work?</p>
<p>The most important thing to consider is that all names in all certificates issued by the FreeIPA CA must conform to whatever Name Constraints are imposed by the external CA. Above all else, the constraints must permit all DNS names used by the IPA servers across the whole topology. Support for DNS name constraint enforcement is widespread, so if this condition is not met, nothing with work. Most likely not even installation with succeed. So if the permitted <code>dnsName</code> constraint is <code>ipa.bobswidgets.com</code>, then every server hostname must be in that subtree. Likewise for SRV names, RFC822 names and so on.</p>
<p>In a typical deployment scenario this is not a burdensome requirement. And if the requirements change (e.g. needing to add a FreeIPA replica with a hostname excluded by Name Constraints) then the CA certificate could be re-issued with an updated Name Constraints extension to allow it. In some use cases (e.g. FreeIPA issuing certificates for cloud services), Name Constraints in the CA certificate may be untenable.</p>
<p>If the external issuer imposes a <code>directoryName</code> constraint, more care must be taken, because as mentioned above, these constraints apply to the Subject DN of issued certificates. The deployment’s <em>subject base</em> (an installation parameter that defines the base subject DN used in all default certificate profiles) must correspond to the <code>directoryName</code> constraint. Also, the Subject DN configuration for custom certificate profiles must correspond to the constraint.</p>
<p>If all of these conditions are met, then there should be no problem having a constrained FreeIPA CA.</p>
<h2 id="a-wild-name-constraint-validation-bug-appears">A wild Name Constraint validation bug appears!</h2>
<p>You didn’t think the story would end there, did you? As is often the case, my study of some less commonly used feature of X.509 was inspired by a customer issue. The customer’s external CA issued a CA certificate with <code>dnsName</code> and <code>directoryName</code> constraints. The <code>permittedSubtree</code> values were reasonable. Everything looked fine, but nothing worked (not even installation). Dogtag would not start up, and the debug log showed that the startup self-test was complaining about the OCSP signing certificate:</p>
<pre><code>The Certifying Authority for this certificate is not
permitted to issue a certificate with this name.</code></pre>
<p>Adding to the mystery, when the <code>certutil(1)</code> program was used to validate the certificate, the result was success:</p>
<pre><code># certutil -V -e -u O \
  -d /etc/pki/pki-tomcat/alias \
  -f /etc/pki/pki-tomcat/alias/pwdfile.txt \
  -n &quot;ocspSigningCert cert-pki-ca&quot;
certutil: certificate is valid</code></pre>
<p>Furthermore, the customer was experiencing (and I was also able to reproduce) the issue on RHEL 7, but I could not reproduce the issue on recent versions of Fedora or the RHEL 8 beta.</p>
<p><code>directoryName</code> constraints are uncommon (relative to <code>dnsName</code> constraints). And having in my past encountered many issues caused by DN string encoding mismatches (a valid scenario, but some libraries do not handle it correctly), my initial theory was that this was the cause. Dogtag uses the NSS security library (via the JSS binding for Java), and a search of the NSS commit log uncovered an interesting change that supported my theory:</p>
<pre><code>Author: David Keeler &lt;dkeeler@mozilla.com&gt;
Date:   Wed Apr 8 16:17:39 2015 -0700

  bug 1150114 - allow PrintableString to match UTF8String
                in name constraints checking r=briansmith</code></pre>
<p>On closer examination however, this change affected code in the <em>mozpkix</em> library (part of NSS), which is not invoked by the certificate validation routines used by Dogtag and <code>certutil</code> program. But if the <em>mozpkix</em> Name Constraint validation code was not being used, where was the relevant code.</p>
<h3 id="finding-the-source-of-the-problem">Finding the source of the problem</h3>
<p>Some more reading of NSS code showed that the error originated in <em>libpkix</em> (also part of NSS).</p>
<p>To work out why <code>certutil</code> was succeeding where Dogtag was failing, I launched <code>certutil</code> in a debugger to see what was going on. Eventually I reached the following routine:</p>
<pre><code>SECStatus
cert_VerifyCertChain(CERTCertDBHandle *handle, CERTCertificate *cert,
                     PRBool checkSig, PRBool *sigerror,
                     SECCertUsage certUsage, PRTime t, void *wincx,
                     CERTVerifyLog *log, PRBool *revoked)
{
  if (CERT_GetUsePKIXForValidation()) {
    return cert_VerifyCertChainPkix(cert, checkSig, certUsage, t,
                                    wincx, log, sigerror, revoked);
  }
  return cert_VerifyCertChainOld(handle, cert, checkSig, sigerror,
}</code></pre>
<p>OK, now I was getting somewhere. It turns out that during library initialisation, NSS reads the <code>NSS_ENABLE_PKIX_VERIFY</code> environment variable and sets a global variable, the value of which determines the return value of <code>CERT_GetUsePKIXForValidation()</code>. The behaviour can also be controlled explicitly via <code>CERT_SetUsePKIXForValidation(PRBool enable)</code>.</p>
<p>When invoking <code>certutil</code> ourselves, this environment variable was not set so “old” validation subroutine was invoked. Both routines performs cryptographic validation of a certification path to a trusted CA, and several other important checks. But it seems that the <em>libpkix</em> routine is more thorough, performing Name Constraints checks, as well as OCSP and perhaps other checks that are not also performed by the “old” subroutine.</p>
<p>If an environment variable or explicit library call is required to enable <em>libpkix</em> validation, why was the error occuring in Dogtag? The answer is simple: as part of <code>ipa-server-install</code>, we update <code>/etc/sysconfig/pki-tomcat</code> to set <code>NSS_ENABLE_PKIX_VERIFY=1</code> in Dogtag’s process environment. This was implemented a few years ago to support OCSP validation of server certificates in connections made by Dogtag (e.g. to the LDAP server).</p>
<h3 id="the-bug">The bug</h3>
<p>Stepping through the code revealed the true nature of the bug. <em>libpkix</em> Name Constraints validation treats the Common Name (CN) attribute of the Subject DN as a DNS name for the purposes of name constraints validation. I already mentioned that this is reasonable behaviour for server certificates. But <em>libpkix</em> has this behaviour for <em>all end-entity certiticates</em>. For an OCSP signing certificate, whose CN attribute carries no special meaning (formally or conventially), this behaviour is wrong. And it is the bug at the root of this problem. I filed a <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1523484">bug in the Mozilla tracker</a> along with a patch—my attempt at fixing the issue. Hopefully a fix can be merged soon.</p>
<h3 id="why-no-failure-on-newer-releases">Why no failure on newer releases?</h3>
<p>The issue does not occur on Fedora &gt;= 28 (or maybe earlier, but I haven’t tested), nor the RHEL 8 beta. So was there already a fix for the issue in NSS, or did something change in Dogtag, FreeIPA or elsewhere?</p>
<p>In fact, the change was in Dogtag. In recent versions we switched to a less comprehensive certificate validation routine—one that does not use <em>libpkix</em>. This is just the default behaviour; the old behaviour can still be enabled. We made this change because in some scenarios the OCSP checking performed by <em>libpkix</em> causes Dogtag startup to hang. Because the OCSP server it is trying to reach to validate certificates during start self-test <em>is the same Dogtag instance that is starting up!</em> Because of the change to the self-test validation behaviour, FreeIPA deployments on Fedora &gt;= 28 and RHEL 8 beta do not experience this issue.</p>
<h3 id="workaround">Workaround?</h3>
<p>If you were experiencing this issue in an existing release (e.g. because you <em>renewed</em> the CA certificate on your <em>existing</em> FreeIPA deployment, and the Name Constraints <em>appeared on the new certificate</em>), an obvious workaround would be to remove the environment variable from <code>/etc/sysconfig/pki-tomcat</code>. That would work, and the change will persist even after an <code>ipa-server-upgrade</code>. But that assumes you already had a working installation. Which the customer doesn’t have, becaues installation itself is failing. So apart from modifying the FreeIPA code to avoid setting this environment variable in the first place, I don’t yet know of a reliable workaround.</p>
<p>This concludes the discussion of constrained CA certificate support in FreeIPA.</p>
<h2 id="limitiations-alternatives-and-related-topics">Limitiations, alternatives and related topics</h2>
<p>Name Constraints only constrains names. There are other ways you might want to constrain a CA. For example: <em>can only issue certificates with validity period &lt;= δ</em>, or <em>can only issue certificates with Extended Key Usages ∈ S</em>. But there exists no mechanism for constraining CAs in such ways.</p>
<p>Not all defined <code>GeneralName</code> types have Name Constraints syntax and semantics defined for them. Documents that define <code>otherName</code> types <em>may</em> define corresponding Name Constraints matching rules, but are not required to. For example <a href="https://tools.ietf.org/html/rfc4985#section-4">RFC 4985</a>, which defines the <code>SRVName</code> type, also defines Name Constraints rules for it. But <a href="https://tools.ietf.org/html/rfc4556">RFC 4556</a>, which specifies the Kerberos PKINIT protocol, defines the <code>KRB5PrincipalName</code> <code>otherName</code> type but no Name Constraints semantics.</p>
<p>For applications where the set of domains (or other names) is volatile, a constrained CA certificate is likely to be more of a problem than a solution. An example might be a cloud or Platform-as-a-Service provider wanting to issue certificates on behalf of customers, who bring their own domains. For this use case it would be better to use an existing CA that supports automated domain validation and issuance, such as <a href="https://letsencrypt.org/">Let’s Encrypt</a>.</p>
<p>Name Constraints say which names a CA is or is not allowed to issue certificates for. But this restriction is controlled by the superior CA(s), not the end-entity. Interestingly there is a way for a domain owner to indicate which CAs are authorised to issue certificates for names in the domain. The DNS <a href="https://tools.ietf.org/html/rfc6844">CAA record (RFC 6844)</a> can anoint one more CAs, implicitly prohibiting other CAs from issuing certificates for that domain. The CA itself can check for these records, as a control against mis-issuance. For publicly-trusted CAs, the CA-Browser Forum <em>Baseline Requirements</em> <strong>requires</strong> CAs to check and obey CAA records. DNSSEC is recommended but not required.</p>
<p>CAA is an <em>authorisation</em> control—relying parties do not consult or care about CAA records when verifying certificates. The verification counterpart of CAA is <em>DANE—DNS-based Authentication of Named Entities</em>, defined in <a href="https://tools.ietf.org/html/rfc6698">RFC 6698</a>. Like CAA, DANE uses DNS (the <em>TLSA</em> record type), but DNSSEC is required. TLSA records can be used to indicate the authorised CA(s) for a certificate. Or they can specify the exact certificate(s) for the domain, a kind of <em>certificate pinning</em>. So DANE can work hand-in-hand with the existing public PKI infrastructure, or it can do an end-run around it. Depending on who you talk to, the reliance on DNSSEC makes it a non-starter, or humanity’s last hope! In any case, support is not yet widespread. Today DANE can be used in some browsers via add-ons, and the OpenSSL and GnuTLS libraries have some support.</p>
<p>Nowadays all publicly-trusted CAs, and some private PKIs, log all issued certificates to <em>Certificate Transparency (CT)</em> logs. These logs are auditable (publicly if the log is public), cryptographically verifiable logs of CA activity. CT was imposed after the detection of many serious misissuances by several publicly-trusted CAs (most of whom are no longer trusted by anyone). Now, even failure to log a certificate to a CT log is reason enough to revoke trust (because <em>what else</em> might they have failed to log? Certificates for <code>google.com</code> or <code>yourbank.ch</code>?) What does CT have to do with Name Constraints? When you consider that client Name Constraints validation support is patchy at best, a CT-based logging and audit solution is a credible alternative to Name Constraints, or at least a valuable complementary control.</p>
<h2 id="conclusion">Conclusion</h2>
<p>So, we have looked at what the Name Constraints extension does, and why it can be useful. We have discussed its limitations and some alternative or related mechanisms. We looked at the state of FreeIPA support, and did a deep dive into NSS to investigate the one bug that seems to be getting in the way.</p>
<p>Name Constraints is one of the many complex features that makes X.509 both so versatile yet so painful to work with. It’s a necessary feature, but support is not consistent and where it exists, there are usually bugs. Although I did discuss some “alternatives”, a big reason you might look for an alternative is because the support is not great in the first place. In my opinion, the best way forward is to ensure Name Constraints validation is performed more often, and more correctly, while (separately) preparing the way for comprehensive CT logging in enterprise CAs. A combination of monitoring (CT) and validation controls (browsers correctly validating names, Name Constraints and requiring evidence of CT logging) seems to be improving security in the public PKI. If we fix the client libraries and make CT logging and monitoring easy, it could work well for enterprise PKIs too.</p>]]></summary>
</entry>
<entry>
    <title>Diagnosing Dogtag cloning failures</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2018-11-30-dogtag-clone-failure-debugging.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2018-11-30-dogtag-clone-failure-debugging.html</id>
    <published>2018-11-30T00:00:00Z</published>
    <updated>2018-11-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="diagnosing-dogtag-cloning-failures">Diagnosing Dogtag cloning failures</h1>
<p>Sometimes, creating a Dogtag clone or a FreeIPA CA replica fails. I worked with Dogtag and FreeIPA for nearly five years. Over these years I’ve analysed a lot of these clone/replica installation failures and internalised a lot of knowledge about how cloning works, and how it can break. Often when I read a problem report and inspect the logs I quickly get a “gut feeling” about the cause. The purpose of this post is to <em>externalise</em> my internal intuition so that others can benefit. Whether you are an engineer or not, this post explains what you can do to get to the bottom of Dogtag cloning failures faster.</p>
<h2 id="how-dogtag-clones-are-created">How Dogtag clones are created</h2>
<p>Some notes about terminology: in FreeIPA we talk about <em>replicas</em>, but in Dogtag we say <em>clones</em>. These terms mean the same thing. When you create a FreeIPA CA replica, FreeIPA creates a clone of the Dogtag CA instance behind the scenes. I will use the term <em>master</em> to refer to the server from which the clone/replica is being created.</p>
<p>The <code>pkispawn(8)</code> program, depending on its configuration, can be used to create a new Dogtag subsystem or a clone. <code>pkispawn</code>, a Python program, manages the whole clone creation process, with the possible exception of setting up LDAP database and replication. But some stages of the configuration are handled by the Dogtag server itself (thus implemented in Java). Furthermore, the Dogtag server on the <em>master</em> must service some requests to allow the new clone to integrate into the topology.</p>
<p>The high level procedure of CA cloning is roughly:</p>
<ol>
<li>(<code>ipa-replica-install</code>) Create temporary Dogtag admin user account and add to relevant groups</li>
<li>(<code>ipa-replica-install</code> or <code>pkispawn</code>) Establish LDAP replication of the Dogtag database</li>
<li>(<code>pkispawn</code>) Extract private keys and system certifiates into Dogtag’s NSSDB</li>
<li>(<code>pkispawn</code>) Lay out the Dogtag instance on the filesystem</li>
<li>(<code>pkispawn</code>) Start the <code>pki-tomcatd</code> instance</li>
<li>(<code>pkispawn</code>) Send a <em>configuration request</em> to the new Dogtag instance
<ol>
<li>(<code>pki-tomcatd</code> on <em>clone</em>) Send <em>security domain</em> login request to master (using temporary admin user credentials)</li>
<li>(<code>pki-tomcatd</code> on <em>master</em>) Authenticate user, return cookie.</li>
<li>(<code>pki-tomcatd</code> on <em>clone</em>) Send number range requests to master</li>
<li>(<code>pki-tomcatd</code> on <em>master</em>) Service number range requests for clone</li>
</ol></li>
<li>(<code>ipa-replica-install</code>) remove temporary admin user account</li>
</ol>
<p>There are several places a problem could occur: in <code>pkispawn</code>, <code>pki-tomcatd</code> on the clone, or <code>pki-tomcatd</code> on the master. Therefore, depending on what failed, the best data about the failure could be in <code>pkispawn</code> output/logs, the Dogtag <code>debug</code> log on the replica, or the master, or even the system journal on either of the hosts. <strong>Recommendation:</strong> when analysing Dogtag cloning or FreeIPA CA replica installation failures, inspect <em>all of these logs</em>. It is often not obvious where the error is occurring, or what caused it. Having all these log files helps a lot.</p>
<h2 id="case-studies">Case studies</h2>
<h3 id="failure-to-set-up-replication">Failure to set up replication</h3>
<p><strong>Description</strong>: <code>ipa-replica-install</code> or <code>pkispawn</code> fail with errors related to replication (failure to establish). I don’t know how common this is in production environments. I’ve encountered it in my development environments. I <em>think</em> it is usually caused by stale replication agreements or something of that nature.</p>
<p><strong>Workaround</strong>: A “folk remedy”: uninstall and clean up the instance, then try again. Most often the error does not recur.</p>
<h3 id="replication-races">Replication races</h3>
<p><strong>Description:</strong> <code>pkispawn</code> fails; <em>replica</em> <code>debug</code> log indicates security domain login failure; <em>master</em> <code>debug</code> log indicates user unknown; <code>debug</code> log indicates token/session unkonwn</p>
<p>During cloning, the <em>clone</em> adds LDAP objects in its own database. It then performs requests against the <em>master</em>, assuming that those objects (or effects of other LDAP operations) have been replicated to the master. Due to replication lag, the data have not been replicated and as a consequence, a request fails.</p>
<p>In the past couple of years several replication races were discovered and fixed (or mitigated) in Dogtag or FreeIPA:</p>
<h4 id="updatenumberrange-failure-due-to-missing-session-object"><code>updateNumberRange</code> failure due to missing session object</h4>
<p><strong>Ticket</strong>: <a href="https://pagure.io/dogtagpki/issue/2557">https://pagure.io/dogtagpki/issue/2557</a></p>
<p><strong>Description</strong>: After security domain login (locally on the <em>replica</em>) the session object gets replicated to the <em>master</em>. The cookie/token conveyed in the <code>updateNumberRange</code> range referred to a session that the <em>master</em> did not yet know about.</p>
<p><strong>Resolution</strong>: the <em>replica</em> sleeps (duration configuration; default 5s) after security domain login, giving time for replication. This is not guaranteed the avoid the problem: the complete solution (yet to be implemented) will be to <a href="https://pagure.io/dogtagpki/issue/2831">use a signed/MACed token</a>.</p>
<h4 id="security-domain-login-failure-due-to-missing-user-or-group-membership">Security domain login failure due to missing user or group membership</h4>
<p><strong>Ticket</strong>: <a href="https://pagure.io/freeipa/issue/7593">https://pagure.io/freeipa/issue/7593</a></p>
<p><strong>Description</strong>: This bug was actually in FreeIPA, but manifested in <code>pki-tomcatd</code> on <em>master</em> as a failure to log into the security domain. This could occur for one of two reasons: either the user was unknown, or the user was not a member of a required group. FreeIPA performs the relevant LDAP operations on the <em>replica</em>, but they have not replicated to <em>master</em> yet. The <code>pkispawn</code>/<code>ipa-replica-install</code> error message looks something like:</p>
<pre><code>com.netscape.certsrv.base.PKIException: Failed to obtain
installation token from security domain:
com.netscape.certsrv.base.UnauthorizedException: User
admin-replica1.ipa.example is not a member of Enterprise CA
Administrators group.</code></pre>
<p><strong>Workaround</strong>: no supported workaround. (You could hack in a <code>sleep</code> though).</p>
<p><strong>Resolution</strong>: The user creation routine was already waiting for replication but the wait routine had a timeout bug causing false positives, <em>and</em> the group memberships were not being waited on. The timeout bug was fixed. The wait routine was enhanced to support waiting for particular attribute values; this feature was used to ensure group memberships have been replicated before continuing.</p>
<h3 id="other-updatenumberrange-failures">Other <code>updateNumberRange</code> failures</h3>
<p><strong>Ticket</strong>: <a href="https://pagure.io/dogtagpki/issue/3055">https://pagure.io/dogtagpki/issue/3055</a></p>
<p><strong>Description</strong>: When creating a clone from a master that was itself a clone, an <code>updateNumberRange</code> request fails at <em>master</em> with status 500. A <code>NullPointerException</code> backtrace appears in the journal for the <code>pki-tomcatd@pki-tomcat</code> unit (on <em>master</em>). The problem arises because the initial number range assignment for the second clone is equal to the range size of the first clone (range transfer size is a fixed number). This scenario was not handled correctly, leading to the exception.</p>
<p><strong>Workaround</strong>: Ensure that each clone services one of each kind of number (e.g. one full certificate request and issuance operation). This ensures that the clone’s range is smaller than the range transfer size, so that a subsequent <code>updateNumberRange</code> request will be satisfied from the master’s “standby” range.</p>
<p><strong>Resolution</strong>: detect range depletion due to <code>updateNumberRange</code> requests and eagerly switch to the standby range. A better fix (yet to be implemented) will be to <a href="https://pagure.io/dogtagpki/issue/3060">allocate each clone a full-sized range</a> from the unallocated numbers.</p>
<h2 id="discussion">Discussion</h2>
<p>Dogtag subsystem cloning is a complex procedure. Even more so in the FreeIPA context. There are lots of places failure can occur.</p>
<p>The case studies above are a few examples of difficult-to-debug failures where the cause was non-obvious. Often the error occurs on a different host (the <em>master</em>) from where the error was observed. And the important data about the true cause may reside in <code>ipareplica-install.log</code>, <code>pkispawn</code> log output, the Dogtag CA <code>debug</code> log (on <em>replica</em> or <em>master</em>) or the system journal (again on <em>replica</em> or <em>master</em>). Sometimes the 389DS logs can be helpful too.</p>
<p>Normally the fastest way to understand a problem is to gather all these sources of data and look at them all around the time the error occurred. When you see one failure, don’t assume that that is <em>the</em> failure. Cross-reference the log files. If you can’t see anything about an error, you probably need to look in a different file…</p>
<p>…or a different part of the file! It is important to note that <strong>Dogtag time stamps are in local time</strong>, whereas most other logs are UTC. Different machines in the topology can be in different timezones, so you could be dealing with up to three timezones across the log files. Check carefully what timezone the timestamps are in when you are “lining up” the logfiles. Many times I have seen (and often erred myself) an incorrect conclusion that “there is no error in the debug log” because of this trap.</p>
<p>In my experience, the most common causes of Dogtag cloning failure have involved Security Domain authentication issues and number range management. Over time I and others have fixed several bugs in these areas, but I am not confident that all potential problems have been fixed. The good news is that checking <em>all</em> the relevant logs usually leads to a good theory about the root cause.</p>
<p>What if you are not an engineer or not able to make sense of the Dogtag codebase? (This is fine by the way—Dogtag is a huge, gnarly beast!) The best thing you can do to help us analyse and resolve the issue is to collect <em>all</em> the logs (from the master and replica) and prune them to the relevant timeframe (minding the timezones) before passing them to an engineer for analysis.</p>
<p>In this post I only looked at Dogtag cloning failures. I have lots of other Dogtag “gut knowledge” that I plan to get out in upcoming posts.</p>]]></summary>
</entry>

</feed>
