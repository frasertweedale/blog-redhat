<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Fraser's IdM Blog</title>
    <link href="https://frasertweedale.github.io/blog-redhat/atom.xml" rel="self" />
    <link href="https://frasertweedale.github.io/blog-redhat" />
    <id>https://frasertweedale.github.io/blog-redhat/atom.xml</id>
    <author>
        <name>Fraser Tweedale</name>
        <email>frase@frase.id.au</email>
    </author>
    <updated>2020-05-06T00:00:00Z</updated>
    <entry>
    <title>Introducing the FreeIPA ACME service</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2020-05-06-ipa-acme-intro.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2020-05-06-ipa-acme-intro.html</id>
    <published>2020-05-06T00:00:00Z</published>
    <updated>2020-05-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="introducing-the-freeipa-acme-service">Introducing the FreeIPA ACME service</h1>
<p><em>Automated Certificate Management Environment (ACME)</em> is a protocol for automated identifier validation and certificate issuance. Its goal is to improve security on the Internet by reducing certificate lifetimes and avoiding manual processes from certificate lifecycle management.</p>
<p>ACME’s original use case is HTTPS on the public Internet. The public CA <a href="https://letsencrypt.org/">*Let's Encrypt*</a> is already one of the biggest CAs. Clients use ACME to talk to <em>Let’s Encrypt</em>, automating DNS name validation, certificate issuance and in most cases, certificate installation and renewal.</p>
<p>But ACME is not limited to Let’s Encrypt. Other CAs implement it and enterprise (private) CAs can implement it too. And after a few years of talking about it, we are finally implementing an ACME service in FreeIPA.</p>
<p>In this post I will give a high-level overview of the ACME protocol, and the ACME service architecture in FreeIPA. If that doesn’t interest you, scroll down to the demo where I show the Certbot ACME client acquiring a certificate from the FreeIPA CA.</p>
<h2 id="acme-protocol-in-brief">ACME protocol, in brief</h2>
<ol type="1">
<li><p>ACME client registers with ACME server. ACME accounts <em>may</em> be bound to some external accounts but more commonly clients register <em>ad hoc</em> with no binding to any other service. This is the case for the FreeIPA ACME service.</p></li>
<li><p>ACME client creates an <em>order</em> for a certificate with one or more <em>identifiers</em> (e.g. DNS names). The FreeIPA ACME service initially supports only DNS identifiers, but the IETF ACME working has defined challenges for other identifier types including IP addresses and email addresses.</p></li>
<li><p>ACME service offers <em>challenges</em> that the client can use to prove <em>control</em> of the identifier. For DNS names there are three challenge types:</p>
<dl>
<dt><code>dns-01</code></dt>
<dd><p>Client creates DNS records to prove control of the identifier.</p>
</dd>
<dt><code>http-01</code></dt>
<dd><p>Client provisions HTTP resource to prove control of the identifier.</p>
</dd>
<dt><code>tls-alpn-01</code></dt>
<dd><p>Client configures TLS server use <em>Application Layer Protocol Negotiation (ALPN)</em> and a special X.509 certificate to prove control of the identifier.</p>
</dd>
</dl>
<p>The FreeIPA ACME service currently implements the <code>dns-01</code> and <code>http-01</code> challenges.</p></li>
<li><p>Client responds to the challenge and advises ACME server to proceed with validation.</p></li>
<li><p>Server attempts to validate the clients response to the challenge. The identifier is <em>authorised</em> when sufficient challenges (usually one per identifier) have been validated.</p></li>
<li><p>After all identifiers in the order have been authorised, the client <em>finalises</em> the order causing the CA to issue the certificate.</p></li>
<li><p>The client retrieves the issued certificate and (commonly) configures an application to use it.</p></li>
</ol>
<p>There are many ACME client implementations. Some, such as <a href="https://certbot.eff.org/">Certbot</a>, are general purpose and can be used standalone or integrated with many kinds of applications. Others are application specific, like <a href="https://httpd.apache.org/docs/current/mod/mod_md.html">mod_md</a> for Apache httpd.</p>
<h2 id="freeipa-acme-service-architecture">FreeIPA ACME service architecture</h2>
<p>The FreeIPA ACME service uses <a href="https://www.dogtagpki.org/wiki/PKI_ACME_Responder">Dogtag PKI ACME responder</a>. This is an optional component of Dogtag, separate from the CA or other subsystems. Like other Dogtag subsystems it run in the same process and is accessed via Tomcat.</p>
<p>The Dogtag ACME subsystem will automatically be deployed on every CA server in a FreeIPA deployment. But <strong>it will not service requests</strong> until the administrator enables it. There are two reasons for this approach.</p>
<p>For ease of client configuration it is desired to have a single, permanent name for the ACME service across the whole topology. The topology should be able to evolve without having the reconfigure ACME clients. There is already a candidate DNS name that is either managed by FreeIPA (when using internal DNS) or required to managed by administrators (when not using internal DNS). That is <code>ipa-ca.$DOMAIN</code>. This points to all CA replicas in the topology. If we let administrators choose the FreeIPA servers upon which to configure the ACME service, we would have to introduce a new DNS name to manage. It will complicate code, and impose a new burden on administrators if the internal DNS is not used. By automatically deploying the ACME service on all CA replicas, the <code>ipa-ca.$DOMAIN</code> name is always a valid name for ACME clients to use.</p>
<p>The second reason is that there is just less for adminstrators to worry about. How do I install the ACME service? Don’t worry about it, it’s already there, just turn it on.</p>
<p>Turning the ACME service on or off, or other configuration changes, will be effected deployment-wide. At least, that is the goal. Early releases <em>might</em> require per-server configuration steps. But eventually configuration will be contained in the replicated LDAP database and administrators will just use regular <code>ipa</code> subcommands to control the ACME service deployment-wide.</p>
<p>The ACME database, too, will be replicated deployment wide. It is possible that some data, such as <em>nonces</em>, might have to be kept server-local for performance reasons (this is not the case now, but load testing is coming).</p>
<h2 id="demo-certbot-client-running-standalone-http-server">Demo: Certbot client running standalone HTTP server</h2>
<p>The following demo scenario was carried out on a FreeIPA-enrolled host. The ACME protocol requires the use of TLS between client and server. The FreeIPA ACME service certificate is (usually) signed by the FreeIPA CA, so the client needs to trust it. On machines that are not FreeIPA clients CA trust would have to be established by other means so that the ACME client will trust the ACME server.</p>
<p>The general purpose ACME client <a href="https://certbot.eff.org/">Certbot</a> integrates with many different server program and can also be used “standalone”. That is what I will do in this demo. It is not representative of real-world use but is a straightforward way to demonstrate that an ACME server is operating correctly.</p>
<p>The two steps, registration and issuance, can be rolled into a single command. For clarity I will keep these as two separate steps.</p>
<h3 id="registration">Registration</h3>
<p>First, the registration step creates an account with the ACME service:</p>
<pre><code>[root@f31-0 ~]# certbot \
    --server https://ipa-ca.ipa.local/acme/directory \
    register -m ftweedal@redhat.com --agree-tos \
Saving debug log to /var/log/letsencrypt/letsencrypt.log

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Would you be willing to share your email address with the Electronic Frontier
Foundation, a founding partner of the Let&#39;s Encrypt project and the non-profit
organization that develops Certbot? We&#39;d like to send you email about our work
encrypting the web, EFF news, campaigns, and ways to support digital freedom.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
(Y)es/(N)o: n

IMPORTANT NOTES:
 - Your account credentials have been saved in your Certbot
   configuration directory at /etc/letsencrypt. You should make a
   secure backup of this folder now. This configuration directory will
   also contain certificates and private keys obtained by Certbot so
   making regular backups of this folder is ideal.</code></pre>
<p>By default Certbot will contact <em>Let’s Encrypt</em>, the public CA. The <code>--server</code> option is given to point Certbot to the FreeIPA ACME service instead.</p>
<p><code>-m</code> gives a contact email address (this is optional). <code>--agree-tos</code> agrees to the terms of service of the ACME server. The “share email with EFF” prompt is only relevant when using Let’s Encrypt and can be ignored.</p>
<h3 id="identifier-validation-and-certificate-issuance">Identifier validation and certificate issuance</h3>
<p>and ACME account then request a certificate for the machine’s hostname from the FreeIPA CA.</p>
<p>The next step is to issue the certificate. The <code>certonly</code> command means: just write the issued certificate to disk; don’t configure any programs to use it. The <code>--domain</code> option can be given multiple times to request a certificate with multiple subject alternative names.</p>
<p>The <code>--standalone</code> option tells Certbot to start its own HTTP server to fulfil the <code>http-01</code> challenge. This server will listen on <code>tcp/80</code> therefore it must run as <code>root</code>. In typical production scenarios Certbot will instead integrate with existing HTTP servers and avoid running it with <code>root</code> privileges. Or you would use an alternative client implementation suited to your use case.</p>
<pre><code>[root@f31-0 ~]# certbot \
    --server https://ipa-ca.ipa.local/acme/directory \
    certonly \
    --domain $(hostname) \
    --standalone
Saving debug log to /var/log/letsencrypt/letsencrypt.log
Plugins selected: Authenticator standalone, Installer None
Obtaining a new certificate
Performing the following challenges:
http-01 challenge for f31-0.ipa.local
Waiting for verification...
Cleaning up challenges

IMPORTANT NOTES:
 - Congratulations! Your certificate and chain have been saved at:
   /etc/letsencrypt/live/f31-0.ipa.local/fullchain.pem
   Your key file has been saved at:
   /etc/letsencrypt/live/f31-0.ipa.local/privkey.pem
   Your cert will expire on 2020-08-03. To obtain a new or tweaked
   version of this certificate in the future, simply run certbot
   again. To non-interactively renew *all* of your certificates, run
   &quot;certbot renew&quot;
 - If you like Certbot, please consider supporting our work by:

   Donating to ISRG / Let&#39;s Encrypt:   https://letsencrypt.org/donate
   Donating to EFF:                    https://eff.org/donate-le</code></pre>
<p>The whole command completed in a few seconds. Below is the pretty print of the certificate. Observe the ~3 month validity and that the issuer is the FreeIPA CA, not Let’s Encrypt.</p>
<pre><code>[root@f31-0 ~]# openssl x509 -text -noout -in /etc/letsencrypt/live/f31-0.ipa.local/cert.pem
Certificate:
  Data:
  Version: 3 (0x2)
  Serial Number: 25 (0x19)
  Signature Algorithm: sha256WithRSAEncryption
  Issuer: O = IPA.LOCAL 202004011654, CN = Certificate Authority
  Validity
      Not Before: May  5 11:30:33 2020 GMT
      Not After : Aug  3 11:30:33 2020 GMT
  Subject: CN = f31-0.ipa.local
  Subject Public Key Info:
      Public Key Algorithm: rsaEncryption
          RSA Public-Key: (2048 bit)
          Modulus:
              &lt;snip&gt;
          Exponent: 65537 (0x10001)
  X509v3 extensions:
      X509v3 Subject Key Identifier: 
          2D:75:79:C2:A0:8C:EF:44:D2:6B:E4:19:E6:BC:42:23:BA:66:1E:D9
      X509v3 Authority Key Identifier: 
          keyid:5E:55:7C:10:82:C1:19:09:E2:42:EC:65:96:89:08:50:35:62:FE:8F

      X509v3 Subject Alternative Name: 
          DNS:f31-0.ipa.local
      X509v3 Key Usage: critical
          Digital Signature, Key Encipherment
      X509v3 Extended Key Usage: 
          TLS Web Server Authentication, TLS Web Client Authentication
      Authority Information Access: 
          OCSP - URI:http://ipa-ca.ipa.local/ca/ocsp

      X509v3 CRL Distribution Points: 

          Full Name:
            URI:http://ipa-ca.ipa.local/ipa/crl/MasterCRL.bin
          CRL Issuer:
            DirName:O = ipaca, CN = Certificate Authority

  Signature Algorithm: sha256WithRSAEncryption
       &lt;snip&gt;</code></pre>
<h2 id="discussion">Discussion</h2>
<p>In this post I demonstrated just one basic client scenario. In upcoming posts I will explore some more advanced and more realistic client scenarios including use of the DNS-based challenges and the <a href="https://httpd.apache.org/docs/current/mod/mod_md.html">mod_md</a> client module for Apache httpd.</p>
<p>The Dogtag ACME responder and FreeIPA ACME service are still undergoing rapid development and are <strong>not production ready</strong>. Some parts of the Dogtag implementation have made their way into releases, but should be considered a “preview”. That said, if you would like to play with the ACME service or perform integration testing, we are happy to collaborate and you should reach out on <code>pki-devel@redhat.com</code>.</p>
<p>The fact that ACME accounts have no “binding” to any existing FreeIPA may surprise some people. In the initial release we want to implement the “baseline” use case also addressed by the public ACME CAs (Let’s Encrypt). That is: <em>an essentially anonymous client proves control of an identifier and gets a certificate.</em> We recognise that organisiations <em>may</em> want ACME accounts to be associated with (or views of) existing identities, and implement authorisation policies based on those accounts and their groups. But we don’t <em>know</em> whether this is required, or exactly what it would look like. So we are going to “wait and see” if customers tell us what “enterprise ACME” should be. In the mean time we are focused on the core use case.</p>
<p>Other considerations for the FreeIPA ACME service include:</p>
<ul>
<li>customising the ACME certificate profile (e.g. altering the validity period, Certificate Policies extension, etc)</li>
<li>issuing ACME certificates from a sub-CA of the FreeIPA CA</li>
<li>controlling which validation challenges are enabled</li>
<li>block/allow lists or other mechanisms to decide whether a particular identifier (DNS name) can be issued via ACME</li>
</ul>
<p>All of these are on the roadmap, but they are likely to be deferred beyond the initial release.</p>
<h2 id="conclusion">Conclusion</h2>
<p>That’s all for this post. I’ll be following up soon with a post about using Apache <a href="https://httpd.apache.org/docs/current/mod/mod_md.html">mod_md</a> with the FreeIPA ACME service.</p>]]></summary>
</entry>
<entry>
    <title>Deploying FreeIPA with a 4096-bit CA signing key</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2020-01-28-freeipa-override-ca-key-size.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2020-01-28-freeipa-override-ca-key-size.html</id>
    <published>2020-01-28T00:00:00Z</published>
    <updated>2020-01-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="deploying-freeipa-with-a-4096-bit-ca-signing-key">Deploying FreeIPA with a 4096-bit CA signing key</h1>
<p>Recent versions of FreeIPA create a 3072-bit CA signing key by default. Older versions used 2048-bit signing keys. Until recently, there was no supported way to deploy FreeIPA with a larger signing key. It was an open secret that you could hack a single file to change the key size when deploying, and everything would work just fine. But still, it was not supported or recommended to do this.</p>
<p>As of FreeIPA 4.8 (RHEL 8.1; Fedora 30) there is an officially supported way to choose a different key size when installing FreeIPA. In this short post I will demonstrate how to do it.</p>
<p>First, an admonition. Choosing a larger key size can negatively affect performance, for both signing and verification (i.e. <em>all clients are affected</em>). 4096-bit RSA operations are twice as slow as 3072-bit RSA, but the bits of security grows at a smaller rate. 3072-bit RSA has 128 bits of security, but 4096-bit RSA only increases your security to 140 bits. For 256 bits of security you need a 15360-bit key. In practice 3072-bit RSA is expected to be secure for at least another decade.</p>
<p>With that out of the way, let’s look at how to do it. The procedure works for both self-signed and externally-signed CAs. It is done via the <code>--pki-config-override</code> option, which allows the server administrator to specify a file that sets or overrides Dogtag <code>pkispawn(8)</code> configuration directives. <code>pki_default.cfg(5)</code> gives a comprehensive overview of the directives available, although not all of these are allowed to be overriden in a FreeIPA installation (<code>ipa-server-install</code> itself checks the file for directives that are not allowed to be overridden).</p>
<p>Fortunately, override is allowed for the <code>pki_ca_signing_key_size</code> directive. Setting this to 4096 (or some other sensible value) will have the desired effect, as the following transcript demonstrates:</p>
<pre><code>[root@rhel82-0 ~]# cat &gt; pki_override.cfg &lt;&lt;EOF
[CA]
pki_ca_signing_key_size=4096
EOF

[root@rhel82-0 ~]# ipa-server-install \
    --unattended \
    --realm IPA.LOCAL \
    --ds-password &quot;$DM_PASS&quot; --admin-password &quot;$ADMIN_PASS&quot; \
    --external-ca \
    --pki-config-override $PWD/pki_override.cfg

... stuff happens ...

  [1/10]: configuring certificate server instance
The next step is to get /root/ipa.csr signed by your
CA and re-run /usr/sbin/ipa-server-install as:
/usr/sbin/ipa-server-install \
  --external-cert-file=/path/to/signed_certificate \
  --external-cert-file=/path/to/external_ca_certificate
The ipa-server-install command was successful

[root@rhel82-0 ~]# openssl req -text &lt; /root/ipa.csr | head
Certificate Request:
    Data:
        Version: 1 (0x0)
        Subject: O = IPA.LOCAL, CN = Certificate Authority
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (4096 bit)
                Modulus:
                    00:c6:05:36:7b:28:c6:03:19:19:91:d3:e9:31:28:
                    5f:50:ab:60:a4:e8:fa:09:ba:5d:a1:25:53:cf:74:</code></pre>
<p>The key size is 4096-bit, as expected. Had the <code>--external-ca</code> option <em>not</em> been provided a 4096-bit self-signed CA would have been created and the installation would have run to completion.</p>]]></summary>
</entry>
<entry>
    <title>Disabling Certmonger auto-renewal</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-12-12-certmonger-disable-auto-renew.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-12-12-certmonger-disable-auto-renew.html</id>
    <published>2019-12-12T00:00:00Z</published>
    <updated>2019-12-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="disabling-certmonger-auto-renewal">Disabling Certmonger auto-renewal</h1>
<p>A customer recently asked how to disable Certmonger auto-renewal of some FreeIPA system certificates. Their organisation’s security policy prohibited auto-renewal. (This is not a good idea in general, but this was a very security-conscious organisation so I’ll assume they have good reasons).</p>
<p>One way to achieve this is to remove the Certmonger tracking requests via <code>getcert stop-tracking</code>. But when it comes time to renew the certificate, this makes life hard. The Certmonger tracking requests are set up to:</p>
<ul>
<li>Use the correct renewal helpers to issue the certificate properly</li>
<li>Store the certificate in the correct place</li>
<li>Copy the certificate to particular LDAP entries to ensure the FreeIPA system continues to function</li>
</ul>
<p>Removing the tracking request means that you have to do all the above tasks yourself. And the steps differ depending on the certificate being renewed. There are many ways to mess up.</p>
<p>A better approach is to keep the Certmonger tracking requests defined, but disable auto-renewal. It is not obvious that you can even do this, let alone <em>how</em> to do it. And that is why I wrote this post. The command is:</p>
<pre><code># getcert start-tracking -i $REQUEST_ID --no-renew</code></pre>
<p>Don’t let the name <code>start-tracking</code> trick you. If you supply <code>-i $REQUEST_ID</code> this command will modify the existing request. With auto-renewal disabled, to renew the certificate you must manually trigger it via:</p>
<pre><code># getcert resubmit -i $REQUEST_ID</code></pre>
<p>If you want to reenable auto-renewal, use the <code>--renew</code> flag:</p>
<pre><code># getcert start-tracking -i $REQUEST_ID --renew</code></pre>
<p>The following transcript deals with the IPA RA agent certificate tracking request. We first disable auto-renewal, then manually renew the certificate, and finally reenable auto-renewal.</p>
<pre><code># getcert list -i 20191206060652                                                                                                                        [6/38]
Number of certificates and requests being tracked: 9.           
Request ID &#39;20191206060652&#39;:                                                          
        status: MONITORING                                                            
        stuck: no                                                                     
        key pair storage: type=FILE,location=&#39;/var/lib/ipa/ra-agent.key&#39;
        certificate: type=FILE,location=&#39;/var/lib/ipa/ra-agent.pem&#39;
        CA: dogtag-ipa-ca-renew-agent
        issuer: CN=Certificate Authority,O=IPA ACME 201912061604
        subject: CN=IPA RA,O=IPA ACME 201912061604                                                                                                                           
        expires: 2021-11-25 17:06:54 AEDT
        key usage: digitalSignature,keyEncipherment,dataEncipherment
        eku: id-kp-clientAuth
        pre-save command: /usr/libexec/ipa/certmonger/renew_ra_cert_pre
        post-save command: /usr/libexec/ipa/certmonger/renew_ra_cert
        track: yes
        auto-renew: yes

# getcert start-tracking -i 20191206060652 --no-renew
Request &quot;20191206060652&quot; modified.

# getcert list -i 20191206060652 |grep auto-renew                       
        auto-renew: no

# openssl x509 -serial &lt; /var/lib/ipa/ra-agent.pem
serial=07

# getcert resubmit -i 20191206060652
Resubmitting &quot;20191206060652&quot; to &quot;dogtag-ipa-ca-renew-agent&quot;.

# getcert list -i 20191206060652 |grep status
        status: MONITORING

# openssl x509 -serial -noout &lt; /var/lib/ipa/ra-agent.pem
serial=0B

# getcert start-tracking -i 20191206060652 --renew
Request &quot;20191206060652&quot; modified.

# getcert list -i 20191206060652 |grep auto-renew
        auto-renew: yes</code></pre>
<p>A final note. I used the long form <code>--[no-]renew</code> options. I prefer long options because they are usually easier for readers (including <em>future me</em>) to understand. But <code>getcert-start-tracking(1)</code> and other Certmonger man pages don’t even mention the long options. The corresponding short options are <code>-r</code> (enable auto-renew) and <code>-R</code> (disable auto-renew).</p>]]></summary>
</entry>
<entry>
    <title>Plans for ACME support in FreeIPA</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-12-06-freeipa-acme-plans.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-12-06-freeipa-acme-plans.html</id>
    <published>2019-12-06T00:00:00Z</published>
    <updated>2019-12-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="plans-for-acme-support-in-freeipa">Plans for ACME support in FreeIPA</h1>
<p>In this post I outline the plans for ACME support in FreeIPA. It’s not intended as a general introduction to ACME or a deep dive into the protocol; if you don’t know what ACME is, the <a href="https://en.wikipedia.org/wiki/Automated_Certificate_Management_Environment">Wikipedia page</a> is a good place to start. Instead this post will focus on how ACME could fit into enterprise environments, and our initial plans for ACME support in <a href="https://www.freeipa.org/page/Main_Page">FreeIPA</a>.</p>
<h2 id="acme-in-the-enterprise">ACME in the enterprise</h2>
<p><em>Automated Certificate Management Environment</em> or <em>ACME</em> (defined in <a href="https://tools.ietf.org/html/rfc8555">RFC 8555</a>) is a Certificate Authority (CA) protocol for automated DNS name validation and certificate issuance. It was first used by <a href="https://letsencrypt.org/">Let's Encrypt</a>, a free publicly-trusted CA. And ACME is increasingly supported by other CAs. Also, some enterprises are interested in ACME to simplify certificate issuance within their organisation.</p>
<p>Therefore we are planning to implement ACME support in FreeIPA. It took us a long time to reach this point, because it was not clear what we should do. One of the main problems ACME solves—automated DNS name validation—doesn’t have the same importance in enterprise environments where systems and services can already prove their identity to a CA.</p>
<p>The other main part of ACME is the certificate request and issuance part, which is already a solved problem. That said, consolidation around ACME and the value of server-integrated clients is a good reason to adopt ACME, even if the name validation parts don’t solve an acute problem.</p>
<p>The “impedence mismatch” of the name validation parts of ACME in enterprise environments has been recognised by the IETF ACME Working Group. There is an active Internet-Draft for an <a href="https://datatracker.ietf.org/doc/draft-ietf-acme-authority-token/">"authority token" challenge type</a>. This challenge type allows a client to present to the ACME CA a verificable token, issued by a <em>Token Authority</em>, that authorises the client to use a particular name. But this specification is still in development and it does not answer questions like how the Token Authority decides whether or not to grant an authorisation.</p>
<p>So at this stage we have no firm idea of what “enterprise ACME” should be. We could make something up, but we prefer to do work that is driven by (or anticipates) real customer requirements. Although lots of customers have asked for or expressed interest in ACME, noone has expressed a clear picture of how it should work with their enterprise identity management.</p>
<h2 id="basic-acme">Basic ACME</h2>
<p>So we will infer the simplest requirement. Customers want ACME support in FreeIPA, so we will give them the ACME they already know. ACME clients are essentially anonymous and have no association with enterprise identities. Clients must perform DNS name validation challenges just as they would if they were talking to a public CA like Let’s Encrypt. The ACME service will validate the challenges in the same way under the prevailing DNS view, which may be different from the DNS view that a public CA would see.</p>
<p>When issuance is approved, the ACME service acts as a Registration Authority (RA) and issues the certificate. The client has no control over the profile used.</p>
<p>Additional authentication, authorisation or account binding layers will be deferred. We can implement them when we know what they should be. If we build this “basic ACME” support, and customers start using it, then hopefully they will tell us what they need more control over. When a clear picture of what “enterprise ACME” should be emerges, we can be confident that we are implementing the right thing.</p>
<h2 id="dogtag-acme-service">Dogtag ACME service</h2>
<p>Already a lot of work has been done implementing an <a href="https://www.dogtagpki.org/wiki/ACME">ACME service in Dogtag</a>. Although it lives in the main Dogtag repository, this is essentially a separate server. It can be configured with different database backends (e.g. PostgreSQL, MongoDB) and different issuance backends (Dogtag, OpenSSL, or even another ACME server).</p>
<p>This work will be the core of the FreeIPA ACME service. We will deploy the ACME service on FreeIPA CA servers and expose it via the Apache front end.</p>
<h2 id="additional-work-required-for-freeipa">Additional work required for FreeIPA</h2>
<p>Although the core of the Dogtag ACME service has already been implemented there is still a lot of work to do for the FreeIPA use case.</p>
<h3 id="ldap-database-backend">LDAP database backend</h3>
<p>We need to implement an LDAP database backend for the Dogtag ACME service. This includes devising the LDAP attribute and object class schemas. I’m currently working on this part.</p>
<p>There are clear advantages to using an LDAP database. First, in a FreeIPA deployment we already have LDAP databases configured, and replication established, for Dogtag and FreeIPA. And we do not want to introduce and configure new dependencies, especially a database server e.g. PostgreSQL.</p>
<h3 id="ldap-configuration-backend">LDAP configuration backend</h3>
<p>In addition to the storage of ACME objects, we also want the ACME service configuration to be stored in LDAP. This ensures a consistent configuration across the topology. Taking advantage of LDAP replication and using a persistent search will ensure that configuration changes (e.g. enable/disable the service or change the profile to use) are applied across the topology almost immediately.</p>
<h3 id="dogtag-backend-authentication">Dogtag backend authentication</h3>
<p>The Dogtag CA backend for the ACME service currently supports password authentication. This will not do. It must be enhanced to support another form of authentication. Certificate authentication seems an obvious target but it presents some challenges. First, we cannot use the IPA RA certificate as-is. The Java TLS client implementation we use uses NSS, and the IPA RA certificate and key are in PEM format. So we would need to:</p>
<ul>
<li>Make another copy of the IPA RA certificate in an NSS DB (nope)</li>
<li>Add support for PEM certificates in the Java TLS client (maybe, and we would have to do some SELinux-fu too)</li>
<li>Create a dedicated RA agent account and certificate for the ACME service (nope)</li>
</ul>
<p>Alternatively we should pursue GSS-API (Kerberos) authentication. We would need to implement support for this in the Java PKI client libraries. But we already know we want to get there one day. And when we get there, we want to do away with the IPA RA credential. It might be worth the up-front effort to implement GSS-API authentication for the ACME RA and avoid the long-term challenges presented by certificate authentication.</p>
<p>The decision on which way we will go has not been made yet.</p>
<h3 id="lightweight-ca-support">Lightweight CA support</h3>
<p>The Dogtag CA backend for the ACME service will be enhanced to allow configuration of the (lightweight) CA to use for issuance. This will allow administrators to use a dedicated sub-CA for ACME certificates.</p>
<h3 id="adding-ipa-ca.domain-to-the-http-certificate">Adding <code>ipa-ca.$DOMAIN</code> to the HTTP certificate</h3>
<p>ACME requires TLS to authenticate the server to the client and secure the connection. In the FreeIPA deployment, the CA capabilities are accessed via the <code>ipa-ca.$DOMAIN</code> DNS name. This is an A/AAAA record pointing to the servers that have the CA role installed. So if your domain name is <code>example.org</code> the ACME service will be hosted at <code>https://ipa-ca.example.org/acme</code> (or something like that).</p>
<p>This means that the DNS name <code>ipa-ca.$DOMAIN</code> must be added to the Subject Alternative Name extension in the HTTP certificate on every FreeIPA CA server. For the sake of simplicity we will actually add the name on the HTTP certificate on <em>all FreeIPA servers</em> whether they have the CA role or not. This will avoid having to issue a new certificate when a replica without the CA role gets promoted to a CA server. Having the name on the certificate of a non-CA server has no operational impact and minimal security risk.</p>
<p>In terms of implementation, for new replicas it is trivial to create the Certmonger tracking request with the DNS name. Some tweaks to CSR validation may be required to allow FreeIPA servers to use the name. For upgrade, we will need to add the name to the Certmonger tracking request <em>and</em> resubmit the request.</p>
<h3 id="acme-certificate-profile">ACME certificate profile</h3>
<p>We need to define and install a default certificate profile for use with ACME. In particular, it must handle empty Subject DNs in CSRs; some ACME clients including the popular Certbot generate CSRs with empty subjects. Furthermore the default validity period will be around 3 months, in line with the Let’s Encrypt profile and in recognition of how increased automation allows certificate lifetimes to be reduced, limiting security risks associated with long certificate lifetimes.</p>
<h3 id="freeipa-management-api-and-commands">FreeIPA management API and commands</h3>
<p>We need to implement commands for administrators to configure the ACME service. The ACME service will be automatically deployed on all CA servers, but by default will not service requests. API methods and corresponding CLI commands are needed to:</p>
<ul>
<li>enable or disable the service</li>
<li>configure which ACME challenges are enabled</li>
<li>configure the certificate profile and (lightweight) CA to use</li>
</ul>
<h3 id="pruning-expired-certificates">Pruning expired certificates</h3>
<p>ACME will typically be used to issue (many) short-lived certificates. If we do not prune expired certificates from the database the disk usage will continue to grow, possibly too much. So we want a procedure to prune expired certificates from the Dogtag CA certificate database. The pruning feature should be able to be turned on or off depending on the organisation’s needs.</p>
<p>Similarly, we want to prune expired authorisations, challenges and orders from the ACME database. Perhaps inactive accounts too.</p>
<h2 id="conclusion">Conclusion</h2>
<p>So, those are the plans for ACME support in FreeIPA. There is a lot of work to do. I’m hoping to make good progress in the next few months. I look forward to giving progress updates and demos in early 2020.</p>]]></summary>
</entry>
<entry>
    <title>Removing the CA from a FreeIPA deployment</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-10-24-removing-ipa-ca.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-10-24-removing-ipa-ca.html</id>
    <published>2019-10-24T00:00:00Z</published>
    <updated>2019-10-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="removing-the-ca-from-a-freeipa-deployment">Removing the CA from a FreeIPA deployment</h1>
<p>FreeIPA can be deployed with or without a CA. By default a CA is installed; we call this a <em>CA-ful</em> deployment. But if you provide third party signed certificates for the HTTP, LDAP and (optionally) Kerberos KDC, then you can create a <em>CA-less</em> deployment.</p>
<p>It is possible and supported to promote a CA-less deployment to CA-ful via the <code>ipa-ca-install</code> command. But the opposite is not true. There is no supported way to remove the CA from a CA-ful deployment. Nevertheless this is sometimes desired, for example to comply with a corporate security policy.</p>
<p>In this post I will explore how to mutate an existing FreeIPA deployment from CA-ful to CA-less.</p>
<h2 id="deployment-overview">Deployment overview</h2>
<p>The deployment I used for this exercise has two servers: <code>f30-0.ipa.local</code> and <code>f30-1.ipa.local</code>. Both have the CA role installed. The CA subject DN is <code>CN=Doomed CA,O=IPA.LOCAL</code>. There is no KRA installed. Kerberos PKINIT is disabled.</p>
<p>Both servers are running builds of the FreeIPA <code>master</code> branch from October 2019, on Fedora 30. There should be no substantial differences in the procedure for official builds in recent versions of Fedora, RHEL 8 or RHEL 7.</p>
<p>The external CA that will sign the HTTP and LDAP service certificates is <code>CN=Certificate Authority,O=ACME Corporation</code>.</p>
<h2 id="success-criteria">Success criteria</h2>
<p>Simply uninstalling the Dogtag CA on all CA replicas is not enough. We want all servers to migrate away from certificate that were issued by the internal CA. Specific goals include:</p>
<ul>
<li>Replace HTTP, LDAP and (if Kerberos PKINIT enabled) KDC certificates with certificates issued by an external CA, on all replicas.</li>
<li>Actually uninstall the Dogtag CA on all CA replicas.</li>
<li>Cause IPA servers and clients to behave as if the deployment is (and always was) CA-less. In particular, programs like <code>ipa-server-upgrade</code> and <code>ipa-certupdate</code> must work.</li>
<li>Replica installation succeeds in the modified deployment (third-party service certificates must be supplied, of course).</li>
<li>Be able to promote the deployment to CA-ful again via the <code>ipa-ca-install</code> command.</li>
</ul>
<h2 id="removing-the-internal-ca">Removing the internal CA</h2>
<p>There are two main approaches one could take. The first is to remove the CA role from existing CA replicas. The second is to install replicas without the CA role, then remove the CA replicas from the topology. In both cases some of the steps (e.g. installing externally-signed service certificates) will be the same. This post describes the first approach (it seems like less work overall).</p>
<h3 id="add-external-ca-to-trust-store">Add external CA to trust store</h3>
<p>First add the external root CA certificate to the FreeIPA trust store:</p>
<pre><code>[root@f30-0 ~]# ipa-cacert-manage install /root/extca.pem
Installing CA certificate, please wait
Verified CN=Certificate Authority,O=ACME Corporation
CA certificate successfully installed
The ipa-cacert-manage command was successful</code></pre>
<p>Then run <code>ipa-certupdate</code> to add the new certificate to system certificate databases, <strong>on every replica</strong> (not just CA replicas):</p>
<pre><code>[root@f30-0 ~]# ipa-certupdate
Systemwide CA database updated.
Systemwide CA database updated.
The ipa-certupdate command was successful</code></pre>
<h3 id="replacing-service-certificates">Replacing service certificates</h3>
<p>Next run <code>ipa-server-certinstall</code> to replace the HTTP and LDAP service certificates issued by the internal CA with externally-signed certificates. Do this <strong>for every server</strong> (only <code>f30-0.ipa.local</code> is shown below). <code>/root/dmpass</code> contains the <code>Directory Manager</code> password. <code>/root/httpd.pin</code> and <code>/root/ldap.pin</code> contain the passwords for the HTTP and LDAP private keys.</p>
<pre><code>[root@f30-0 ~]# ipa-server-certinstall \
    --dirman-pass $(cat /root/dmpass) \
    --http /root/httpd.pem --pin $(cat /root/httpd.pin)
Please restart ipa services after installing certificate (ipactl restart)
The ipa-server-certinstall command was successful

[root@f30-0 ~]# ipa-server-certinstall \
    --dirman-pass $(cat /root/dmpass) \
    --dirsrv /root/ldap.pem --pin $(cat /root/ldap.pin)
Please restart ipa services after installing certificate (ipactl restart)
The ipa-server-certinstall command was successful

[root@f30-0 ~]# ipactl restart
Restarting Directory Service
Restarting krb5kdc Service
Restarting kadmin Service
Restarting httpd Service
Restarting ipa-custodia Service
Restarting pki-tomcatd Service
Restarting ipa-otpd Service
ipa: INFO: The ipactl command was successful</code></pre>
<p>Verify that Apache is presenting the externally-signed service certificate:</p>
<pre><code>[root@f30-0 ~]# echo \
   | openssl s_client -connect $(hostname):443 &gt;/dev/null
depth=1 O = ACME Corporation, CN = Certificate Authority
verify return:1
depth=0 O = ACME Corporation, CN = f30-0.ipa.local
verify return:1
DONE</code></pre>
<h3 id="delete-ca-role-configuration">Delete CA role configuration</h3>
<p>FreeIPA uses role entries to track which servers have which features (CA, KRA, DNS, etc.) enabled. Search for the entries to delete:</p>
<pre><code>[root@f30-0 ~]# ldapsearch -Y GSSAPI -QLLL \
    -b cn=masters,cn=ipa,cn=etc,dc=ipa,dc=local \
    &#39;(cn=CA)&#39;
dn: cn=CA,cn=f30-0.ipa.local,cn=masters,cn=ipa,cn=etc,dc=ipa,dc=local
ipaConfigString: startOrder 50
ipaConfigString: caRenewalMaster
ipaConfigString: enabledService
cn: CA
objectClass: nsContainer
objectClass: ipaConfigObject
objectClass: top

dn: cn=CA,cn=f30-1.ipa.local,cn=masters,cn=ipa,cn=etc,dc=ipa,dc=local
objectClass: nsContainer
objectClass: ipaConfigObject
objectClass: top
cn: CA
ipaConfigString: startOrder 50
ipaConfigString: enabledService</code></pre>
<p>Delete these entries:</p>
<pre><code>[root@f30-0 ~]# ldapdelete -Y GSSAPI -Q \
    cn=CA,cn=f30-0.ipa.local,cn=masters,cn=ipa,cn=etc,dc=ipa,dc=local

[root@f30-0 ~]# ldapdelete -Y GSSAPI -Q \
    cn=CA,cn=f30-1.ipa.local,cn=masters,cn=ipa,cn=etc,dc=ipa,dc=local</code></pre>
<p>At this point, any command that attempts to communicate with the CA will fail with a message that the CA is not configured:</p>
<pre><code>[root@f30-0 ~]# ipa ca-find
ipa: ERROR: CA is not configured
[root@f30-0 ~]# ipa cert-show 5
ipa: ERROR: CA is not configured</code></pre>
<h3 id="uninstalling-dogtag">Uninstalling Dogtag</h3>
<p>Issue the <code>pkidestroy</code> command <strong>on each CA replica</strong> to uninstall the Dogtag CA:</p>
<pre><code>[root@f30-0 ~]# pkidestroy -i pki-tomcat -s CA                                                                                 
Uninstallation log: /var/log/pki/pki-ca-destroy.20191023173820.log                      
Loading deployment configuration from /var/lib/pki/pki-tomcat/ca/registry/ca/deployment.cfg.
WARNING: The &#39;pki_ssl_server_token&#39; in [CA] has been deprecated. Use &#39;pki_sslserver_token&#39; instead.
WARNING: The &#39;pki_pin&#39; in [DEFAULT] has been deprecated. Use &#39;pki_server_database_password&#39; instead.
Uninstalling CA from /var/lib/pki/pki-tomcat.                                                                                  
WARNING: pkihelper      Directory &#39;/etc/pki/pki-tomcat/alias&#39; is either missing or is NOT a directory!

Uninstallation complete.        </code></pre>
<p>The warnings can be ignored.</p>
<h3 id="remove-service-configuration-from-state-file">Remove service configuration from state file</h3>
<p>Some processes read from the deployment state file at <code>/var/lib/ipa/sysrestore/sysrestore.state</code> to decide whether the CA is installed. <strong>On every CA replica</strong> delete the following lines from this file:</p>
<pre><code>[pki-tomcatd]
installed = True</code></pre>
<h3 id="removing-or-retaining-trust-in-the-deleted-ca">Removing (or retaining) trust in the deleted CA</h3>
<p>If there are no more certificates in use that were issued by the (now removed) internal CA, we can remove it from the LDAP trust store:</p>
<pre><code>% ldapdelete -Y GSSAPI -Q \
    &quot;cn=IPA.LOCAL IPA CA,cn=certificates,cn=ipa,cn=etc,dc=ipa,dc=local&quot;</code></pre>
<p>Otherwise if we still need to trust the old IPA CA, we can rename it. This step is necessary because the name <code>{REALM} IPA CA</code> indicates that this is the internal CA (which it no longer is).</p>
<pre><code>% ldapmodrdn -Y GSSAPI -Q -r \
    &quot;cn=IPA.LOCAL IPA CA,cn=certificates,cn=ipa,cn=etc,dc=ipa,dc=local&quot; \
    &quot;cn=CN\=Doomed CA\,O\=IPA.LOCAL&quot;</code></pre>
<p>We also have to remove the <code>{REALM} IPA CA</code> certificate from the FreeIPA 389 DS certificate databases <strong>on every replica</strong>. Leaving it as-is will impede future reinstallation of the CA:</p>
<pre><code>[root@f30-0 ~]# certutil -d /etc/dirsrv/slapd-IPA-LOCAL \
                    -D -n &#39;IPA.LOCAL IPA CA&#39;

[root@f30-0 ~]# certutil -d /etc/ipa/nssdb \
                    -D -n &#39;IPA.LOCAL IPA CA&#39;</code></pre>
<h3 id="delete-ipa-ca-and-sub-ca-entries">Delete IPA CA and sub-CA entries</h3>
<p>Search for all entries with object class <code>ipaca</code> and delete them:</p>
<pre><code>[root@f30-0 ~]# ldapsearch -Y GSSAPI -QLLL \
     -b dc=ipa,dc=local &#39;(objectclass=ipaca)&#39; 1.1
dn: cn=ipa,cn=cas,cn=ca,dc=ipa,dc=local

[root@f30-0 ~]# ldapdelete -Y GSSAPI -Q \
     cn=ipa,cn=cas,cn=ca,dc=ipa,dc=local</code></pre>
<p>Unless you have created additional (sub-)CAs via the <code>ipa ca-add</code> command there will be only one entry (<code>cn=ipa</code>).</p>
<h3 id="remove-certmonger-tracking-requests">Remove Certmonger tracking requests</h3>
<p>Certmonger tracking requests for the Dogtag system certificates and IPA RA agent certificate should be removed <strong>on each server</strong>. The easiest way to achieve this is with a small Python script:</p>
<pre><code>[root@f30-0 ~]# python3 &lt;&lt;EOF
from ipaserver.install.cainstance import CAInstance
ca = CAInstance()
ca.stop_tracking_certificates()
EOF</code></pre>
<h2 id="testing-the-outcome">Testing the outcome</h2>
<p>We already confirmed that the <code>ipa</code> subcommands (i.e. commands that query the IPA API) fail gracefully with a message that the CA role is not installed. But there are other commands to check. In particular we want to test <code>ipa-certupdate</code>, <code>ipa-server-upgrade</code>, and client and replica installation.</p>
<pre><code>[root@f30-0 ~]# ipa-certupdate
Systemwide CA database updated.
Systemwide CA database updated.
The ipa-certupdate command was successful</code></pre>
<pre><code>[root@f30-0 ~]# ipa-server-upgrade
Upgrading IPA:. Estimated time: 1 minute 30 seconds
...
The IPA services were upgraded                                      
The ipa-server-upgrade command was successful                       </code></pre>
<p>So far so good. I used a third host, <code>f30-2.ipa.local</code>, to test client and replica installation. I don’t have the required DNS records so I had to specify the domain and server.</p>
<pre><code>[root@f30-2 ~]# ipa-client-install --server f30-0.ipa.local --domain ipa.local
This program will set up FreeIPA client.
Version 4.9.0.dev201910230357+gitc6769ad12

Autodiscovery of servers for failover cannot work with this configuration.
If you proceed with the installation, services will be configured to always acce
ss the discovered server for all operations and will not fail over to other serv
ers in case of failure.
Proceed with fixed values and no DNS discovery? [no]: y
Do you want to configure chrony with NTP server or pool address? [no]: 
Client hostname: f30-2.ipa.local
Realm: IPA.LOCAL
DNS Domain: ipa.local
IPA Server: f30-0.ipa.local
BaseDN: dc=ipa,dc=local

Continue to configure the system with these values? [no]: y
Synchronizing time
No SRV records of NTP servers found and no NTP server or pool address was provid
ed.
Using default chrony configuration.
Attempting to sync time with chronyc.
Time synchronization was successful.
User authorized to enroll computers: admin
Password for admin@IPA.LOCAL: 
Successfully retrieved CA cert
    Subject:     CN=Certificate Authority,O=ACME Corporation
    Issuer:      CN=Certificate Authority,O=ACME Corporation
    Valid From:  2019-10-24 04:01:33
    Valid Until: 2039-10-24 04:01:33

Enrolled in IPA realm IPA.LOCAL
Created /etc/ipa/default.conf
Configured sudoers in /etc/authselect/user-nsswitch.conf
Configured /etc/sssd/sssd.conf
Configured /etc/krb5.conf for IPA realm IPA.LOCAL
Systemwide CA database updated.
Adding SSH public key from /etc/ssh/ssh_host_ed25519_key.pub
Adding SSH public key from /etc/ssh/ssh_host_ecdsa_key.pub
Adding SSH public key from /etc/ssh/ssh_host_rsa_key.pub
Could not update DNS SSHFP records.
SSSD enabled
Configured /etc/openldap/ldap.conf
Configured /etc/ssh/ssh_config
Configured /etc/ssh/sshd_config
Configuring ipa.local as NIS domain.
Client configuration complete.
The ipa-client-install command was successful</code></pre>
<p>Client installation succeeded. We can see that external CA certificate was retrieved. I proceeded with replica installation:</p>
<pre><code>[root@f30-2 ~]# kinit admin                                                     
Password for admin@IPA.LOCAL: XXXXXXX

[root@f30-2 ~]# ipa-replica-install \
    --http-cert-file /root/httpd.pem \
    --http-pin $(cat /root/httpd.pin) \
    --dirsrv-cert-file /root/ldap.pem \
    --dirsrv-pin $(cat /root/ldap.pin) \
    --no-pkinit --unattended
Run connection check to master
Connection check OK
Disabled p11-kit-proxy
Configuring directory server (dirsrv). Estimated time: 30 seconds
  [1/41]: creating directory server instance
  ...
  [10/10]: starting directory server
Done.
Finalize replication settings
Restarting the KDC
The ipa-replica-install command was successful</code></pre>
<h2 id="reinstating-the-internal-ca">Reinstating the internal CA</h2>
<p>If you want to once again have a CA-ful FreeIPA deployment, use the <code>ipa-ca-install</code> command to install the CA. There is one critical constraint: <strong>the new CA must not have the same Subject DN as the previous CA</strong>. This is to avoid a recurrence of the same issuer/serial combination, which is a big no-no both for security and because errors are likely to arise.</p>
<p>So let’s install the CA again. To play it safe I’ll use the newly-installed replica <code>f30-2.ipa.local</code>. Just in case there is some “residue” left on the other servers that would prevent reinstallation of the CA role.</p>
<pre><code>[root@f30-2 ~]# ipa-ca-install \
      --ca-subject &quot;CN=Restored CA,O=IPA.LOCAL&quot;
Directory Manager (existing master) password:                                   

The CA will be configured with:                                                 
Subject DN:   CN=Restored CA,O=IPA.LOCAL                      
Subject base: O=IPA.LOCAL                                                       
Chaining:     self-signed                                                       

Continue to configure the CA with these values? [no]: y                         
Configuring certificate server (pki-tomcatd). Estimated time: 3 minutes
  [1/29]: configuring certificate server instance               
  [2/29]: Add ipa-pki-wait-running                                              
  [3/29]: reindex attributes                                                    
  [4/29]: exporting Dogtag certificate store pin                
  [5/29]: stopping certificate server instance to update CS.cfg 
  [6/29]: backing up CS.cfg                                                     
  [7/29]: disabling nonces                                                      
  [8/29]: set up CRL publishing
  [9/29]: enable PKIX certificate path discovery and validation
  [10/29]: starting certificate server instance
  [11/29]: configure certmonger for renewals
  [12/29]: requesting RA certificate from CA
  [13/29]: setting audit signing renewal to 2 years
  [14/29]: restarting certificate server 
  [15/29]: publishing the CA certificate 
  [16/29]: adding RA agent as a trusted user
  [17/29]: authorizing RA to modify profiles
  [18/29]: authorizing RA to manage lightweight CAs
  [19/29]: Ensure lightweight CAs container exists
  [20/29]: configure certificate renewals
  [21/29]: Configure HTTP to proxy connections
  [22/29]: restarting certificate server 
  [23/29]: updating IPA configuration
  [24/29]: enabling CA instance
  [25/29]: migrating certificate profiles to LDAP
  [26/29]: importing IPA certificate profiles
  [27/29]: adding default CA ACL
  [28/29]: adding &#39;ipa&#39; CA entry
  [29/29]: configuring certmonger renewal for lightweight CAs
Done configuring certificate server (pki-tomcatd).</code></pre>
<p>The installation completed without error. The deployment is CA-ful again, but it is a different CA from before.</p>
<h2 id="issues-encountered">Issues encountered</h2>
<p>I encountered a significant issue when reinstalling the CA. If there are multiple trusted CAs (including the old internal CA) in <code>/etc/ipa/ca.crt</code>, then if the issuer of the 389 DS service certificate is not the first certificate in that file Dogtag installation will fail. This is because the wrong CA certificate is imported into Dogtag’s NSSDB and the issuer of the LDAP certificate is <em>not</em> imported. As a consequence, Dogtag cannot verify the LDAP certificate and cannot communicate with the database. Installation fails.</p>
<p>This issue is tracked in <a href="https://pagure.io/freeipa/issue/8103">upstream ticket 8103</a>.</p>
<p>I also encountered problems when reinstalling a CA on the servers from which it had been uninstalled. A <em>duplicate entry</em> error occurs when setting up the LDAP database:</p>
<pre><code>[root@f30-1 ~]# ipa-ca-install
Directory Manager (existing master) password:

Run connection check to master
Connection check OK
Configuring certificate server (pki-tomcatd). Estimated time: 3 minutes
  [1/27]: creating certificate server db
  [error] DuplicateEntry: This entry already exists

Your system may be partly configured.
Run /usr/sbin/ipa-server-install --uninstall to clean up.

Unexpected error - see /var/log/ipareplica-ca-install.log for details:
DuplicateEntry: This entry already exists</code></pre>
<p>This can probably be averted with additional cleanup steps. I did not investigate further because installation of the CA role on a <em>new replica</em> did succeed. That seems good enough to me.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post I explored how to demote a CA-ful FreeIPA deployment to a CA-less deployment. The procedure has many steps. Even in a CA-less deployment TLS is still required for secure communication between components. So one important step is to install externally-signed service certificates for the web server, directory server and (if used) the KDC certificates. But there are several other steps required to remove the CA from an existing deployment.</p>
<p>The procedure is not officially supported. If you need to perform this operation make a snapshot of your deployment so you can roll back if anything goes wrong, or verify everything in a test environment first (or both!)</p>
<p>If you need to move from a CA-ful to a CA-less deployment, an alternative approach would be to create a new, CA-less deployment and migrate your data across. Neither approach is very attractive, to be fair.</p>
<p>As a final observation, the procedure has several steps that are similar or identical to the steps for <a href="2018-05-31-replacing-lost-ca.html">replacing a lost CA</a>.</p>]]></summary>
</entry>
<entry>
    <title>Requesting certificates from FreeIPA on Active Directory clients</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-09-23-direct-integration-ipa-certs.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-09-23-direct-integration-ipa-certs.html</id>
    <published>2019-09-23T00:00:00Z</published>
    <updated>2019-09-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="requesting-certificates-from-freeipa-on-active-directory-clients">Requesting certificates from FreeIPA on Active Directory clients</h1>
<p>In recent times I have seen some support cases and sales inquiries about getting certificates on Linux systems that are enrolled in Active Directory (AD). Linux hosts can be directly enrolled in AD via <code>realmd</code> or <code>adcli</code>. On AD-enrolled machines, SSSD can provide authentication services, access control and some Group Policy enforcement (see <code>sssd-ad(5)</code>). At Red Hat we call this approach <em>direct integration</em>. The alternative approach is to enrol hosts in a FreeIPA / IDM realm, and use <em>cross-realm trusts</em> to allow AD users/principals to authenticate to FreeIPA services, or vice-versa.</p>
<p>Unfortunately when it comes to getting certificates from AD-CS (the Active Directory certificate authority component) we don’t have a good story yet. Certmonger lacks an out-of-the-box capability to talk to AD-CS (except via SCEP, but that is not what we want). I do not know how much work would be involved in writing an AD-CS request helper for Certmonger. It might be a large effort or small; the little AD-CS enrolment documentation I have found is hard to penetrate. But even if we could write the AD-CS helper and ship it tomorrow, it would not help users and customers on older releases.</p>
<p>For now the best solution is to deploy FreeIPA / IDM, and use the IPA CA to issue certificates to AD-enrolled hosts. In this HOWTO-style post I walk through this scenario with a RHEL 6 client.</p>
<h2 id="environment">Environment</h2>
<p>My local Windows Server 2012 R2 server defines the <code>AD.LOCAL</code> Active Directory (AD) realm. The DNS zone is <code>ad.local</code>. I configured a DNS <em>Conditional Forwarder</em> for <code>ipa.local</code>, delegating that namespace to the FreeIPA DNS server.</p>
<p>The FreeIPA server is <code>rhel76-0.ipa.local</code>. There is no AD trust. The integrated DNS is in use so KDC discovery will work.</p>
<p>In a typical scenario the IPA CA might be a subordinate of the AD CA. In my setup the IPA CA is self-signed. Operationally there is one additional step when the IPA CA is not subordinate to the AD CA: the IPA CA certificate has to be explicitly trusted. To trust the certificate copy it to a file under <code>/etc/pki/ca-trust/source/anchors/</code> then execute <code>update-ca-trust</code>.</p>
<p>The RHEL 6 host is named <code>rhel610-0.ipa.local</code> The packages required were <code>adcli</code> and <code>ipa-client</code>. On RHEL 7 and later or Fedora the <code>realm</code> command, which is provided by the <code>realmd</code> package, is a better choice than <code>adcli</code>. <code>/etc/resolv.conf</code> points to the Windows Server.</p>
<h2 id="active-directory-enrolment">Active Directory enrolment</h2>
<p>I used the <code>adcli</code> command to enrol <code>rhel610-0</code> in Active Directory:</p>
<pre><code>[root@rhel610-0 ~]# adcli join ad.local --show-details
Password for Administrator@AD.LOCAL: XXXXXXXX
[domain]
domain-name = ad.local
domain-realm = AD.LOCAL
domain-controller = win-ppk015f9mdq.ad.local
domain-short = AD
domain-SID = S-1-5-21-3519545429-1027502194-913185514
naming-context = DC=ad,DC=local
domain-ou = (null)
[computer]
host-fqdn = rhel610-0.ipa.local
computer-name = RHEL610-0
computer-dn = CN=RHEL610-0,CN=Computers,DC=ad,DC=local
os-name = redhat-linux-gnu
[keytab]
kvno = 2
keytab = FILE:/etc/krb5.keytab</code></pre>
<p>The output shows that the enrolment succeeded and prints information about the realm and enrolment. Inspecting the system keytab <code>/etc/krb5.keytab</code> shows the Kerberos keys:</p>
<pre><code>[root@rhel610-0 ~]# ktutil
ktutil:  read_kt /etc/krb5.keytab
ktutil:  list
slot KVNO Principal
---- ---- ---------------------------------------------------------------------
   1    2                      RHEL610-0$@AD.LOCAL
   2    2                      RHEL610-0$@AD.LOCAL
   3    2                      RHEL610-0$@AD.LOCAL
   4    2                      RHEL610-0$@AD.LOCAL
   5    2                      RHEL610-0$@AD.LOCAL
   6    2                      RHEL610-0$@AD.LOCAL
   7    2                  host/RHEL610-0@AD.LOCAL
   8    2                  host/RHEL610-0@AD.LOCAL
   9    2                  host/RHEL610-0@AD.LOCAL
  10    2                  host/RHEL610-0@AD.LOCAL
  11    2                  host/RHEL610-0@AD.LOCAL
  12    2                  host/RHEL610-0@AD.LOCAL
  13    2        host/rhel610-0.ipa.local@AD.LOCAL
  14    2        host/rhel610-0.ipa.local@AD.LOCAL
  15    2        host/rhel610-0.ipa.local@AD.LOCAL
  16    2        host/rhel610-0.ipa.local@AD.LOCAL
  17    2        host/rhel610-0.ipa.local@AD.LOCAL
  18    2        host/rhel610-0.ipa.local@AD.LOCAL
  19    2     RestrictedKrbHost/RHEL610-0@AD.LOCAL
  20    2     RestrictedKrbHost/RHEL610-0@AD.LOCAL
  21    2     RestrictedKrbHost/RHEL610-0@AD.LOCAL
  22    2     RestrictedKrbHost/RHEL610-0@AD.LOCAL
  23    2     RestrictedKrbHost/RHEL610-0@AD.LOCAL
  24    2     RestrictedKrbHost/RHEL610-0@AD.LOCAL
  25    2 RestrictedKrbHost/rhel610-0.ipa.local@AD.LOCAL
  26    2 RestrictedKrbHost/rhel610-0.ipa.local@AD.LOCAL
  27    2 RestrictedKrbHost/rhel610-0.ipa.local@AD.LOCAL
  28    2 RestrictedKrbHost/rhel610-0.ipa.local@AD.LOCAL
  29    2 RestrictedKrbHost/rhel610-0.ipa.local@AD.LOCAL
  30    2 RestrictedKrbHost/rhel610-0.ipa.local@AD.LOCAL
ktutil:  quit</code></pre>
<h2 id="freeipa-enrolment">FreeIPA “enrolment”</h2>
<p>Next I created a host princpial for <code>rhel610-0.ipa.local</code> in the FreeIPA realm:</p>
<pre><code>[root@rhel76-0 ~]# ipa host-add rhel610-0.ipa.local
--------------------------------
Added host &quot;rhel610-0.ipa.local&quot;
--------------------------------
  Host name: rhel610-0.ipa.local
  Principal name: host/rhel610-0.ipa.local@IPA.LOCAL
  Principal alias: host/rhel610-0.ipa.local@IPA.LOCAL
  Password: False
  Keytab: False
  Managed by: rhel610-0.ipa.local</code></pre>
<p>Because the integrated DNS is in use, we do not need to explicitly tell the Kerberos library about the <code>IPA.LOCAL</code> KDC. Instead you only need to ensure that <code>/etc/krb5.conf</code> <strong>does not contain</strong>:</p>
<pre><code>[libdefaults]
  dns_lookup_kdc = false</code></pre>
<p>When not using KDC discovery a section like the following is needed:</p>
<pre><code>[realms]
 IPA.LOCAL = {
  kdc = rhel76-0.ipa.local
  admin_server = rhel76-0.ipa.local
 }</code></pre>
<p>I also needed to add a <code>[domain_realm]</code> section to tell the Kerberos client library what realm to use when talking to the IPA server:</p>
<pre><code>[domain_realm]
 .ipa.local = IPA.LOCAL</code></pre>
<p>Reading <code>krb5.conf(5)</code>, there is a <code>[libdefaults]</code> knob called <code>realm_try_domains</code>. From the description, it seems that using it could avoid the need for a <code>[domain_realm]</code> section. But it did not work for me, in the way I expected (on this RHEL 6 client at least).</p>
<p>Next I had to retrieve the host keys for the <code>IPA.LOCAL</code> realm into the system keytab. The Certmonger IPA helper will use those keys to authenticate to FreeIPA when requesting a certificate:</p>
<pre><code>[root@rhel610-0 ~]# kinit admin@IPA.LOCAL
Password for admin@IPA.LOCAL: 
[root@rhel610-0 ~]# ipa-getkeytab -s rhel76-0.ipa.local \
    -p host/rhel610-0.ipa.local@IPA.LOCAL \
    -k /etc/krb5.keytab
Keytab successfully retrieved and stored in: /etc/krb5.keytab</code></pre>
<p>Listing the keys in <code>/etc/krb5.conf</code> we now see that the <code>IPA.LOCAL</code> host keys have been <em>appended</em>:</p>
<pre><code>[root@rhel610-0 ~]# ktutil
ktutil:  read_kt /etc/krb5.keytab
ktutil:  list
slot KVNO Principal
---- ---- ---------------------------------------------------------------------
   1    2                      RHEL610-0$@AD.LOCAL
    ...
  30    2 RestrictedKrbHost/rhel610-0.ipa.local@AD.LOCAL
  31    1       host/rhel610-0.ipa.local@IPA.LOCAL
  32    1       host/rhel610-0.ipa.local@IPA.LOCAL
  33    1       host/rhel610-0.ipa.local@IPA.LOCAL
  34    1       host/rhel610-0.ipa.local@IPA.LOCAL
ktutil:  quit</code></pre>
<h2 id="selinux-considerations">SELinux considerations</h2>
<p>I will store certificates and keys under <code>/etc/pki/tls/private/</code> because this directory has the correct SELinux context (and default context rules) for Certmonger to use it:</p>
<pre><code>[root@rhel610-0 ~]# ls -l -d -Z /etc/pki/tls/private/
drwxr-xr-x. root root system_u:object_r:cert_t:s0 /etc/pki/tls/private/</code></pre>
<p>If you want Certmonger to manage keys and certificates in other directories you need to ensure the files/directory have the <code>cert_t</code> type label. This can be achieved via the <code>semanage(8)</code> and <code>restorecon(8)</code>, but I will not go into further detail here.</p>
<h2 id="certmonger-ipa-configuration">Certmonger IPA configuration</h2>
<p>Certmonger comes out of the box with a request/renewal helper for an IPA CA. But it assumes that the client is an IPA-enrolled server, i.e. per <code>ipa-client-install</code>. In particular there are two files that must be manually set up. First, the IPA CA (and chain) must be present in <code>/etc/ipa/ca.crt</code>. It can be copied from the IPA server without changes. I have filed a ticket to <a href="https://pagure.io/certmonger/issue/132">make Certmonger use the system CA trust store</a>.</p>
<p>The other file is <code>/etc/ipa/default.conf</code>. The Certmonger IPA helper reads several fields from this file to locate the IPA server and work out how to initialise Kerberos credentials. I used the following configuration:</p>
<pre><code>[global]
server = rhel76-0.ipa.local
basedn = dc=ipa,dc=local
realm = IPA.LOCAL
domain = ipa.local
xmlrpc_uri = https://rhel76-0.ipa.local/ipa/xml
ldap_uri = ldaps://rhel76-0.ipa.local</code></pre>
<h2 id="requesting-the-certificate">Requesting the certificate</h2>
<p>Now we can tell Certmonger to request a certificate using the IPA CA:</p>
<pre><code>[root@rhel610-0 ~]# getcert request \
    -c IPA \
    -k /etc/pki/tls/private/cert.key \
    -f /etc/pki/tls/private/cert.pem \
    -K host/rhel610-0.ipa.local@IPA.LOCAL \
    -D rhel610-0.ipa.local
New signing request &quot;20190920053226&quot; added.</code></pre>
<p>The options used are:</p>
<dl>
<dt><code>-c</code></dt>
<dd><p>Use the <code>IPA</code> CA request/renewal helper. To see a list of all the defined CA helpers execute <code>getcert list-cas</code>.</p>
</dd>
<dt><code>-k</code></dt>
<dd><p>Where to store the newly generated, or read the existing, private key.</p>
</dd>
<dt><code>-f</code></dt>
<dd><p>Where to store the issued certificate.</p>
</dd>
</dl>
<p><code>-K</code></p>
<blockquote>
<p>Kerberos principal name, which will appear in the CSR’s Subject Alternative Name extension. The <code>IPA</code> request helper requires this parameter.</p>
</blockquote>
<dl>
<dt><code>-D</code></dt>
<dd><p>DNS name to include in the Subject Alternative Name extension.</p>
</dd>
</dl>
<p>We can use the request ID to print the details of the certificate request:</p>
<pre><code>[root@rhel610-0 ~]# getcert list -i 20190920053226
Number of certificates and requests being tracked: 1.
Request ID &#39;20190920053226&#39;:
  status: MONITORING
  stuck: no
  key pair storage: type=FILE,location=&#39;/etc/pki/tls/private/cert.key&#39;
  certificate: type=FILE,location=&#39;/etc/pki/tls/private/cert.pem&#39;
  CA: IPA
  issuer: CN=Certificate Authority,O=IPA.LOCAL 201909191314
  subject: CN=rhel610-0.ipa.local,O=IPA.LOCAL 201909191314
  expires: 2021-09-23 09:34:49 UTC
  dns: rhel610-0.ipa.local
  principal name: host/rhel610-0.ipa.local@IPA.LOCAL
  key usage: digitalSignature,nonRepudiation,keyEncipherment,dataEncipherment
  eku: id-kp-serverAuth,id-kp-clientAuth
  pre-save command: 
  post-save command: 
  track: yes
  auto-renew: yes</code></pre>
<p>The <code>MONITORING</code> status shows that the initial certificate request was successful. Certmonger is now tracking the certificate and will attempt to renew it when its <code>notAfter</code> (expiration) time approaches. We can also pretty-print the certificate to see the gory details:</p>
<pre><code>[root@rhel610-0 ~]# openssl x509 -text -noout \
    &lt; /etc/pki/tls/private/cert.pem
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 19 (0x13)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: O=IPA.LOCAL 201909191314, CN=Certificate Authority
        Validity
            Not Before: Sep 23 09:34:49 2019 GMT
            Not After : Sep 23 09:34:49 2021 GMT
        Subject: O=IPA.LOCAL 201909191314, CN=rhel610-0.ipa.local
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:da:ca:ca:08:d5:da:d5:79:9e:46:49:85:3f:c9:
                    ... &lt;snip&gt;
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Authority Key Identifier: 
                keyid:DB:24:C2:6B:51:FD:F7:6B:25:79:6B:37:23:02:51:05:07:52:2D:39

            Authority Information Access: 
                OCSP - URI:http://ipa-ca.ipa.local/ca/ocsp

            X509v3 Key Usage: critical
                Digital Signature, Non Repudiation, Key Encipherment, Data Encipherment
            X509v3 Extended Key Usage: 
                TLS Web Server Authentication, TLS Web Client Authentication
            X509v3 CRL Distribution Points: 

                Full Name:
                  URI:http://ipa-ca.ipa.local/ipa/crl/MasterCRL.bin
                CRL Issuer:
                  DirName: O = ipaca, CN = Certificate Authority

            X509v3 Subject Key Identifier: 
                87:71:B3:6C:1D:9B:B9:7E:9D:2E:25:B0:CC:68:A4:92:FA:EE:33:C3
            X509v3 Subject Alternative Name: 
                DNS:rhel610-0.ipa.local, othername:&lt;unsupported&gt;, othername:&lt;unsupported&gt;
    Signature Algorithm: sha256WithRSAEncryption
         5e:36:e3:21:c3:14:7f:d9:1c:c1:ac:7e:12:3e:6b:34:76:a6:
         ... &lt;snip&gt;</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>I have shown how AD-enrolled Linux hosts can request certificates from FreeIPA. Reviewing the major considerations and steps:</p>
<ol type="1">
<li>Create a host principal in the FreeIPA realm</li>
<li>Retrieve the keytab</li>
<li>Adjust <code>/etc/krb5.conf</code> for the FreeIPA realm (DNS-based KDC discovery means there is less to do)</li>
<li>Add IPA CA certificate to <code>/etc/ipa/ca.crt</code> and add <code>/etc/ipa/default.conf</code>; these are needed by the Certmonger request helper</li>
<li>Request certificate (some SELinux-fu needed if storing certs/keys in non-default locations)</li>
</ol>
<p>The exact steps were for a RHEL 6 machine. The procedure may differ for newer systems, but not in any big ways.</p>
<p>In the course of exploring the procedure for this post I found it helpful to invoke the Certmonger IPA helper directly, e.g.:</p>
<pre><code>[root@rhel610-0 ~]# /usr/libexec/certmonger/ipa-submit \
    -P host/rhel610-0.ipa.local@IPA.LOCAL foo.req
Submitting request to &quot;https://rhel76-0.ipa.local/ipa/xml&quot;.
Fault 3009: (RPC failed at server.  invalid &#39;csr&#39;: hostname in
  subject of request &#39;freebsd10-0.ipa.local&#39; does not match name
  or aliases of principal &#39;host/rhel610-0.ipa.local@IPA.LOCAL&#39;).
Server at https://rhel76-0.ipa.local/ipa/xml denied our request,
  giving up: 3009 (RPC failed at server.  invalid &#39;csr&#39;: hostname
  in subject of request &#39;freebsd10-0.ipa.local&#39; does not match
  name or aliases of principal &#39;host/rhel610-0.ipa.local@IPA.LOCAL&#39;).</code></pre>
<p>In the preceding example, I invoked the helper directly, supplying a (bogus) CSR and specifying the subject principal. The goal was not to successfully request a certificate but to verify the Kerberos configuration. If you are trying to use the IPA helper on a non-IPA-enrolled system you may also find this approach helpful for diagnosing issues.</p>
<p>Newer releases of Certmonger added support for requesting certificates using a different certificate profile, or a different IPA (sub-)CA. On RHEL 6, it is not possible to request a different profile so the default profile (<code>caIPAserviceCert</code>) is always used. IPA server on RHEL 7 and later does support modifying profiles, including the default profile.</p>
<p>The Certmonger IPA request helper uses <code>/etc/ipa/ca.crt</code> as the trust store for the HTTPS requests it makes to the FreeIPA server. If the IPA CA certificate is updated, this file will have to be updated on clients. When there are systems not IPA-enrolled á la <code>ipa-client-install</code>, it may be worthwhile to use configuration management tools such as Ansible to do this.</p>
<p>As for getting certificates from AD-CS directly, there is interest from users and customers. I would like to see it implemented, but when or by whom, or whether we even will, has not been decided as of September 2019.</p>]]></summary>
</entry>
<entry>
    <title>Certificates need not be limited to the CA’s validity period</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-08-02-validity-exceeding-ca.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-08-02-validity-exceeding-ca.html</id>
    <published>2019-08-02T00:00:00Z</published>
    <updated>2019-08-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="certificates-need-not-be-limited-to-the-cas-validity-period">Certificates need not be limited to the CA’s validity period</h1>
<p>All X.509 certificates have a <code>notBefore</code> and <code>notAfter</code> date. These define the <em>validity period</em> of the certificate. When we talk about certificate <em>expiry</em>, we are talking about the <code>notAfter</code> date. The question often arises: can a certificate’s <code>notAfter</code> date exceed the <code>notAfter</code> date of the issuer’s certificate?</p>
<p>The naïve intuition says, <em>surely a certificate’s validity period cannot exceed the CA’s</em>. But let’s think it through, and look at what these fields actually mean. According to <a href="https://tools.ietf.org/html/rfc5280#section-4.1.2.5">RFC 5280 §4.1.2.5</a>:</p>
<pre><code>The certificate validity period is the time interval
during which the CA warrants that it will maintain
information about the status of the certificate.</code></pre>
<p>The whole section makes no mention of the issuer’s <code>notAfter</code> date or validity period. It only says that the CA must maintain status (i.e. revocation) information about the issued certificate until (at least) the <code>notAfter</code> date.</p>
<p>But what if the CA certificate expires before an issued certificate? One of two things happens:</p>
<ol type="1">
<li>The CA certificate got renewed and the verifier has a copy of the new certificate. The certificate being verified is within its validity period and so is the CA certificate, so there is a certificate path and everything is fine.</li>
<li>The CA certificate was not renewed (or the verifier doesn’t have the renewed certificate). The certificate being verified is within its validity period, but the issuer certificate is <em>not</em>. So there is no certificate path; the certificate being verified cannot not be trusted.</li>
</ol>
<p>So it is fine for issued certificate to have expiry dates beyond that of the CA.</p>
<p>In fact, clamping the <code>notAfter</code> of issued certificates to the <code>notAfter</code> of the CA can cause operational challenges. At the same time as the CA needs renewal, so do potentially many issued certificates! You may end up with certificates with short validity periods if the CA certificate is renewed close to its <code>notAfter</code> time, and a flood of renewals to perform at the same time.</p>
<p>There is one situation where it is required to clamp the <code>notAfter</code> of issued certificates to the issuer <code>notAfter</code>. This is when it is known that the issuer, including its CRL and OCSP facilities, will be decommissioned shortly after the expiry of the issuer certificate. Otherwise, in light of the potential operational hazards, I recommend issuing certificates with whatever validity period is appropriate for the application, regardless of when the issuer certificate expires.</p>]]></summary>
</entry>
<entry>
    <title>Dogtag replica range management</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-07-26-dogtag-replica-ranges.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-07-26-dogtag-replica-ranges.html</id>
    <published>2019-07-26T00:00:00Z</published>
    <updated>2019-07-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="dogtag-replica-range-management">Dogtag replica range management</h1>
<p>Dogtag supports distributed deployment, with multiple <em>replicas</em> (also called <em>clones</em>) processing requests and issuing certificates. All replicas read and write a replicated LDAP database. A Dogtag server can create many kinds of objects: certificates, requests, archived keys or secrets. These objects need identifiers that are unique across the deployment.</p>
<p>How does a Dogtag clone choose an identifier for a new object? In this post I will explain Dogtag’s <em>range management</em>—how it works, how it can break, and what to do if it does.</p>
<h2 id="object-types-with-managed-ranges">Object types with managed ranges</h2>
<p>There are several types of objects for which Dogtag manages identifier ranges. For example:</p>
<ul>
<li>Certificate serial numbers; it is essential that these be unique. Collisions are a violation of X.509 and can lead to erroneous <strong>denial of service</strong>, or <strong>false positive</strong> validity, when revocation comes into play.</li>
<li>Certificate requests (including revocation and renewal requests) are stored in the database and must have a unique ID. Clobbering of requests objects due to range conflicts can lead to renewal request failures resulting in <strong>denial of service</strong>, or worse, issuance of a valid certificate with incorrect details, allowing <strong>impersonation</strong> attacks.</li>
<li>KRA request identifiers are assigned from a managed range.</li>
<li>KRA archived key and data objects are assigned from a managed range.</li>
<li>Clones themselves are assigned identifiers when they are created; these come from managed ranges.</li>
</ul>
<p>The identifiers themselves are unbounded nonzero integers. All of the managed ranges are separate domains. That is, the same numbers exist in each range, and the ranges are managed independently.</p>
<h2 id="active-and-standby-ranges">Active and standby ranges</h2>
<p>For each kind of range, each replica remembers up to two range assignments. The <em>active</em> range is the range from which identifiers are actively assigned. When the active range is exhausted, the <em>standby</em> range becomes the active range and the clone acquires a new range assignment, which will be the new standby range. A clone doesn’t necessarily have a standby range at all times. It only acquires a new allocation for the standby range when the unused amount of its active range falls below some configured <em>low water mark</em>.</p>
<h2 id="range-assignments">Range assignments</h2>
<p>Range assignments are recorded in LDAP. A clone’s active and standby ranges are also recorded in the clone’s <code>CS.cfg</code> configuration file. A range object looks like:</p>
<pre><code>dn: cn=10000001,ou=certificateRepository,ou=ranges,o=ipaca
objectClass: top
objectClass: pkiRange
beginRange: 10000001
endRange: 20000000
cn: 10000001
host: f30-1.ipa.local
SecurePort: 443</code></pre>
<p>This is a serial number range assignment. Host <code>f30-1.ipa.local</code> has been assigned the range <code>10000001..20000000</code>. It is not apparent from this object, but these are actually <strong>hexadecimal</strong> numbers! Whether the numbers are decimal or hexadecimal varies among managed ranges.</p>
<p>The directives in the <code>CS.cfg</code> on <code>f30-1.ipa.local</code> reflect this assignment:</p>
<pre><code>dbs.enableSerialManagement=true

dbs.beginSerialNumber=fff0001
dbs.endSerialNumber=10000000

dbs.nextBeginSerialNumber=10000001
dbs.nextEndSerialNumber=20000000

dbs.enableRandomSerialNumbers=false
dbs.randomSerialNumberCounter=-1

dbs.serialCloneTransferNumber=10000
dbs.serialIncrement=10000000
dbs.serialLowWaterMark=2000000</code></pre>
<p>The active range is <code>fff0001..10000000</code>, and the standby range is <code>10000001..20000000</code>, which corresponds to the LDAP entry shown above.</p>
<h3 id="range-delegation">Range delegation</h3>
<p>Why is <code>f30-1</code>’s active range so much smaller than its standby range? This is the result of how ranges are assigned during cloning. When creating a clone, the server being configured contacts an existing clone and asks it for some configuration values, including serial/request/replica ID ranges. The existing clone <em>delegates</em> to the new clone a small segment of either its active or standby range. It delegates <em>from the end</em> of its active range, but if there are not enough numbers left in the active range, it delegates from the end the standby range instead.</p>
<p>The size of the range delegation is configured in <code>CS.cfg</code>. For example, for serial numbers it is the <code>dbs.serialCloneTransferNumber</code> setting. I have never heard of anyone changing the default, and I can’t think of a reason to do so.</p>
<p>Because the delegation is a portion of an already-assigned range (with corresponding LDAP object), new LDAP range objects are not created for delegated ranges, and the existing range object is not modified in any way. Therefore, LDAP only ever shows the <em>original</em> range assignments.</p>
<p>This range delegation procedure has been a source of bugs. For example, <a href="https://pagure.io/dogtagpki/issue/3055">issue 3055</a> was a cloning failure when creating two clones (call them <em>C</em> and <em>D</em>) from a server that is itself a clone (call it <em>B</em>). Because the delegation size is fixed (the <code>dbs.serialCloneTransferNumber</code> setting), creating <em>C</em> delegates <em>B</em>’s whole active range to <em>C</em>. Unless <em>B</em> had a chance to switch to its standby range (when didn’t happen during cloning), creating the second clone <em>D</em> would fail because <em>B</em>’s active range was exhausted. This issue was fixed, but a more robust solution is to do away with range delegation entirely; the server can create full range assignments for the new clone instead of delegating part of its own range assignment. <a href="https://pagure.io/dogtagpki/issue/3060">Issue 3060</a> tracks this work.</p>
<h2 id="random-serial-numbers">Random serial numbers</h2>
<p>Most repositories with range management yield numbers sequentially from the active ranges. For the certificate repository only, you can optionally enable <em>random</em> serial numbers. Numbers are chosen by a uniform random sample from the clone’s assigned range. Dogtag checks to make sure the number was not already used; if it was used, it tries again (and again, up to a limit).</p>
<p>Some additional configuration values come into play when using random serial numbers:</p>
<dl>
<dt><code>dbs.enableRandomSerialNumbers</code></dt>
<dd><p>Enable random serial numbers (default: off)</p>
</dd>
<dt><code>dbs.collisionRecoverySteps</code></dt>
<dd><p>How many retries when a collision is detected (default: 10)</p>
</dd>
<dt><code>dbs.minimumRandomBits</code></dt>
<dd><p>Minimum size of the range, in bits (default: 4 bits)</p>
</dd>
<dt><code>dbs.serialLowWaterMark</code></dt>
<dd><p>Switch to standby range when there are fewer than this many serials left in the range (default: 2000000)</p>
</dd>
</dl>
<p>Critically, The <code>dbs.minimumRandomBits</code> does <em>not</em> determine how much entry is in the serial number. If many serial numbers in the range have already been used, the actual number of serials left could be less than <code>dbs.minimumRandomBits</code> of entropy. When issuing random serial numbers, the server keeps a running count of how many serial numbers have been used in the active range. When the range size minus the current count falls below <code>dbs.serialLowWaterMark</code>, the server switches to the standby range. Therefore it is <code>dbs.serialLowWaterMark</code>, not <code>dbs.minimumRandomBits</code>, that actually controls the minimum amount of randomness in the serial number.</p>
<h2 id="switching-to-the-standby-range">Switching to the standby range</h2>
<p>The actions performed by the subroutine that switches to the next range are:</p>
<dl>
<dt>1. Set the active range start and end variables to the standby range</dt>
<dd><p>start and end</p>
</dd>
</dl>
<ol>
<li>Reset the standby range start and end variables to <code>null</code></li>
<li>Reset counters</li>
<li>Persist these changes to <code>CS.cfg</code>.</li>
</ol>
<p>The switchover procedure <strong>does not acquire a new standby range assignment</strong>. Immediately after switching to the standby range, there isn’t a standby range anymore.</p>
<h2 id="acquiring-a-new-range-assignment">Acquiring a new range assignment</h2>
<p>As currently implemented, a new standby range is <strong>only acquired at system startup</strong>. Dogtag checks each repository to see if the amount of unused numbers in the active range has fallen below the <em>low water mark</em>. If it has, and if there is no standby range, it self-allocates a new range assignment in LDAP. The size of the allocation is determined by <code>CS.cfg</code> configurables, and its lower bound is the value of the <code>nextRange</code> attribute in the repository parent LDAP object. It adds a range object to the ranges subtree, and updates the <code>nextRange</code> attribute on the repository parent. See the appendix for a list of which subtree parents and range entries are involved for each repository.</p>
<p>This procedure is brittle under the possibliity of LDAP replication races or transient failures. Two clones could end up adding the same range, and a replication error will occur. This can lead to identifier collisions resulting in problems later (see earlier discussion).</p>
<h2 id="internals">Internals</h2>
<p>Most of everything discussed so far lives in the <code>Repository</code> class, with <code>CertificateRepository</code> providing additional behaviour related to random serial numbers. Code for acquiring a new range assignment lives in <code>DBSubsystem</code>. Some methods of interest include:</p>
<dl>
<dt><code>Repository.getNextSerialNumber</code></dt>
<dd><p>Get the next number; calls <code>checkRange</code> before returning it</p>
</dd>
<dt><code>Repository.checkRange</code></dt>
<dd><p>Check if the range is exhausted; if so call <code>switchToNextRange</code></p>
</dd>
<dt><code>Repository.switchToNextRange</code></dt>
<dd><p>Switches to next range (see discussion in earlier section)</p>
</dd>
<dt><code>Repository.checkRanges</code></dt>
<dd><p>Sanity checks the active and standby ranges; acquires new range allocation if necessary (by calling <code>DBSubsystem.getNextRange</code>) and persists the changes to <code>CS.cfg</code>.</p>
</dd>
<dt><code>DBSubsystem.getNextRange</code></dt>
<dd><p>This method creates the LDAP range object and updates the <code>nextRange</code> attribute, returning the range bounds to the caller.</p>
</dd>
</dl>
<h2 id="fixing-range-conflicts">Fixing range conflicts</h2>
<p>If you have range conflicts, the following high-level steps can be followed to fix them:</p>
<ol type="1">
<li>Stop all Dogtag servers.</li>
<li>Resolve any replication issues or conflict entries.</li>
<li>Examine active and standby ranges in <code>CS.cfg</code> on all replicas.</li>
<li>If there are any conflicts (including between active and standby ranges), choose new ranges such that there are no conflicts. Update <code>CS.cfg</code> of each replica with its new ranges.</li>
<li>Update the <code>nextRange</code> attribute for each repository object to a number <em>greater than</em> the highest number of any allocated range (<em>max + 1</em> is fine). See appendix for the objects involved.</li>
<li><em>(Optional)</em> Update and add new range entries. This is not essential because nothing will break if the ranges entries don’t actually correspond to what’s in each replica’s <code>CS.cfg</code>. But is is still desirable that the LDAP entries reflect the configuration of each server.</li>
<li>Start Dogtag servers. If some servers do not have a standby range, it is a good idea to stagger their startup. Otherwise there is a high risk of an immediate replication race causing range conflicts as servers acquire new range assignments.</li>
</ol>
<p>Note that this procedure will <em>not</em> save your skin if, e.g., multiple certificates with the same serial number were issued. Renewal problems may be unavoidable when collisions have occurred. This is the main reason we are switching to <a href="https://pagure.io/freeipa/issue/7991">profile-based renewal</a> for FreeIPA system certificates. Renewal requests refer to existing certificate and requests by serial / request ID. Thus if there have been range conflicts they are susceptible to failure or issuance of certificates with incorrect attributes. Performing a “fresh enrolment” when renewing system certificates avoids these problems because the profile enrolment request does not refer to any existing certificates or requests.</p>
<h2 id="discussion">Discussion</h2>
<p>Dogtag is over 20 years old, and I suppose that sequential numbers with range management made sense at the time. Maybe a multi-server deployment with a replicated database was not foreseen, and range management was bolted on later when the requirement emerged. Maybe using random identifiers was seen as difficult to get write; UUIDs were not widespread back then. Or maybe using random numbers was seen as not user-friendly (and that is true, but when you have more than one replica the ranged identifiers aren’t much better).</p>
<p>On the fact of some ranges using base 16 (hexademical) and others using base 10: I cannot even imagine why this is so. Extra user and operator pain, for what gain? I cannot tell. The reasons are probably, like so many things in old programs, lost in time.</p>
<p>The random serial number configuration and behaviour is… not state of the art. The program logic is difficult to follow and it is not clear which configuration directives govern the (minimum) amount of entropy in the chosen numbers.</p>
<p>If I were designing a system like Dogtag today, I would use random UUIDs for everything, except possibly serial numbers. There are <a href="https://en.wikipedia.org/wiki/UUID#Version_4_(random)">122 bits of entropy</a> in a Version 4 UUID. The current CA/Browser Forum <a href="https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.6.5.pdf">Baseline Requirements</a> (v1.6.5) require serial numbers with 64 bits of high-quality randomness, but if that is ever increased beyond 122 bits a UUID won’t cut it anymore. So I would just use very large random numbers for all serial numbers.</p>
<p>Can we move Dogtag from what we have now to something more robust? Of course it is possible, but it would be a big effort. So all that is likely to happen is smaller, well understood and bounded efforts with an obvious payoff, like avoiding range delegation (<a href="https://pagure.io/dogtagpki/issue/3060">Issue 3060</a>).</p>
<p>The new FreeIPA <a href="https://www.freeipa.org/page/V4/Healthcheck">Health Check</a> system provides pluggable checks for system health. There is an open ticket to implement Dogtag range conflict and sanity checking in the Health Check tool, so that problems can be detected before they cause major failures.</p>
<h2 id="appendix-range-configuration-directives-and-objects">Appendix: range configuration directives and objects</h2>
<p>In all LDAP DNs below, substitute <code>o=ipaca</code> with the relevant base DN.</p>
<h3 id="certificate-serial-numbers">Certificate serial numbers</h3>
<p>Base: <strong>hexademical</strong></p>
<p><code>CS.cfg</code> attributes:</p>
<pre><code>dbs.beginSerialNumber
dbs.endSerialNumber
dbs.nextBeginSerialNumber
dbs.nextEndSerialNumber
dbs.serialIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=certificateRepository,ou=ca,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=certificateRepository,ou=ranges,o=ipaca</code></pre>
<h3 id="ca-requests">CA requests</h3>
<p>Base: <strong>demical</strong></p>
<p><code>CS.cfg</code> attributes:</p>
<pre><code>dbs.beginRequestNumber
dbs.endRequestNumber
dbs.nextBeginRequestNumber
dbs.nextEndRequestNumber
dbs.requestIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=ca,ou=requests,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=requests,ou=ranges,o=ipaca</code></pre>
<h3 id="replica-numbers">Replica numbers</h3>
<p>Base: <strong>demical</strong></p>
<p><code>CS.cfg</code> attributes:</p>
<pre><code>dbs.beginReplicaNumber
dbs.endReplicaNumber
dbs.nextBeginReplicaNumber
dbs.nextEndReplicaNumber
dbs.replicaIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=replica,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=replica,ou=ranges,o=ipaca</code></pre>
<h3 id="kra-keys">KRA keys</h3>
<p>Base: <strong>hexademical</strong></p>
<p><code>kra/CS.cfg</code> attributes:</p>
<pre><code>dbs.beginSerialNumber
dbs.endSerialNumber
dbs.nextBeginSerialNumber
dbs.nextEndSerialNumber
dbs.serialIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=keyRepository,ou=kra,o=kra,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=keyRepository,ou=ranges,o=kra,o=ipaca</code></pre>
<h3 id="kra-requests">KRA requests</h3>
<p>Base: <strong>demical</strong></p>
<p><code>kra/CS.cfg</code> attributes:</p>
<pre><code>dbs.beginRequestNumber
dbs.endRequestNumber
dbs.nextBeginRequestNumber
dbs.nextEndRequestNumber
dbs.requestIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=kra,ou=requests,o=kra,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=requests,ou=ranges,o=kra,o=ipaca</code></pre>
<h3 id="kra-replicas-numbers">KRA replicas numbers</h3>
<p>Base: <strong>demical</strong></p>
<p><code>CS.cfg</code> attributes:</p>
<pre><code>dbs.beginReplicaNumber
dbs.endReplicaNumber
dbs.nextBeginReplicaNumber
dbs.nextEndReplicaNumber
dbs.replicaIncrement</code></pre>
<p>LDAP repository object (<code>nextRange</code> attribute):</p>
<pre><code>dn: ou=replica,o=kra,o=ipaca</code></pre>
<p>LDAP ranges subtree parent:</p>
<pre><code>dn: ou=replica,ou=ranges,o=kra,o=ipaca</code></pre>]]></summary>
</entry>
<entry>
    <title>Designing revocation self-service for FreeIPA</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-07-19-revocation-self-service.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-07-19-revocation-self-service.html</id>
    <published>2019-07-19T00:00:00Z</published>
    <updated>2019-07-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="designing-revocation-self-service-for-freeipa">Designing revocation self-service for FreeIPA</h1>
<p>The FreeIPA team recently received a <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1730363">feature request</a> for self-service certificate revocation. At the moment, revocation must be performed by a privileged user with the <code>Revoke Certificate</code> permission. The one exception to this is that a host principal can revoke certificates for the same hostname. There are no expections when it comes to user certificates.</p>
<p>In this post I’ll discuss revocation self-service and how it might work in FreeIPA.</p>
<h2 id="requirements-and-approaches-for-self-service">Requirements and approaches for self-service</h2>
<p>It is critical to avoid scenarios where a user could revoke a certificate they should not be able to revoke; this would constitute a Denial-of-Service (DoS) vulnerability. Therefore FreeIPA must establish that the principal issuing the revocation request has authority to revoke the nominated certificate. Conceptually, there are several ways we might establish that authority. Each scenario has trade-offs, either fundamental to the scenario or specific to FreeIPA.</p>
<h3 id="proof-of-possession">Proof of possession</h3>
<p>Proof of possession (PoP) establishes a cryptographic proof that the operator possess the private key for the certificate to be revoked. Either they are rightful subject of the certificate, in which case it is reasonable to service their revocation request. Or they have compromised the subject’s key, in which case it is reasonable to revoke it anyway.</p>
<p>A PoP-based revocation system must defeat replay attacks. Using a nonce would complicate the client-server interaction—the client would first have to request the nonce, and the server would have to remember it. Instead of a nonce, it would be sufficient for the client to sign a timestamped statement of intent to revoke.</p>
<p>The main issue with PoP-based revocation is that the user interface must consider how to access the key. The UI must learn options related to key or certificate database paths, passphrases, and so on. This is a significant burden for users.</p>
<p>Finally, there is an important use case this scenario does not handle: when the user no longer has control of their private key (they deleted it, forgot the passphrase, etc.)</p>
<h3 id="certificate-inspection">Certificate inspection</h3>
<p>The revocation command could inspect the certificate and decide if it “belongs to” the requestor. This must be done with extreme care, because a false-positive is equivalent to a DoS vulnerability. For example, merely checking that the UID or CN attribute in the certificate Subject DN corresponds to the requestor is inadequate.</p>
<p>It is hard to attain 100% certainty, especially considering administrators can create custom certificate profiles. But there are some options that seem safe enough to implement. It should be reasonable to authorise the revocation if:</p>
<ul>
<li><p>The Subject Alternative Name (SAN) extension contains a <code>KRB5PrincipalName</code> or <code>UPN</code> value equal to the authenticated principal. FreeIPA supports such certificates out of the box, contingent on the CSR including these data.</p></li>
<li><p>The SAN contains a <code>rfc822Name</code> (email address) equal to one of the user’s email addresses. Again, FreeIPA supports this with the same CSR caveat.</p></li>
<li><p>The SAN contains a <code>directoryName</code> (DN) equal to the user’s full DN in the FreeIPA LDAP directory. Supported, with CSR caveat.</p></li>
<li><p>The certificate Subject DN is equal to the user’s full DN in the FreeIPA LDAP directory. Supported with a custom profile having <code>subjectNameDefaultImpl</code> configuration like (wrapped for display):</p>
<pre><code>policyset.serverCertSet.1.default.params.name=
  UID=$request.req_subject_name.cn$,
  CN=users,CN=accounts,DC=example,DC=com</code></pre></li>
</ul>
<p>The CSR caveat presents a burden to users: they must lovingly handcraft their CSR to include the relevant data. To say the tools have poor usability in this area is an understatement. But the SAN options are supported out of the box by the default user certificate profile <code>IECUserRoles</code> (don’t ask about the name).</p>
<p>On the other hand, the Subject DN approach requires a custom profile but nothing special needs to go in the CSR. A Subject DN of <code>CN=username</code> will suffice.</p>
<h3 id="audit-based-approach">Audit-based approach</h3>
<p>When issuing a certificate via <code>ipa cert-request</code>, there are two principals at play: the <em>operator</em> who is performing the request, and the <em>subject</em> principal who the certificate is for. (These could be the same principal). Subject to organisational security policy, it may be reasonable to revoke a certificate if <em>either</em> of these principals requests it.</p>
<p>Unfortunately, in FreeIPA today we do not record these data in a way that is useful to make a revocation authorisation decision. In the future, when FreeIPA authenticates to Dogtag using GSS-API and a Kerberos proxy credential for the operator (instead of the IPA RA agent credential we use today), we will be able to store the needed data. Then it may be feasible to implement this approach. Until then, forget about it.</p>
<h2 id="the-way-forward">The way forward</h2>
<p>So, which way will we go? Nothing is decided yet (including <em>whether to implement this at all</em>). If we go ahead, I would like to implement the <em>certificate inspection</em> approach. Proof of possession is tractable, but a lot of extra complexity and probably a usability nightmare for users. The audit-based approach is infeasible at this time, though it is a solid option if/when the right pieces are in place. Certificate inspection carries a risk of DoS exposure through revocation of inappropriate certificates, but if we carefully choose which data to inspect and match, the risk is minimised while achieving satisfactory usability.</p>]]></summary>
</entry>
<entry>
    <title>A Distinguished Name is not a string</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2019-05-28-a-dn-is-not-a-string.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2019-05-28-a-dn-is-not-a-string.html</id>
    <published>2019-05-28T00:00:00Z</published>
    <updated>2019-05-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="a-distinguished-name-is-not-a-string">A Distinguished Name is not a string</h1>
<p><em>Distinguished Names (DNs)</em> are used to identify entities in LDAP databases and X.509 certificates. Although DNs are often presented as strings, they have a complex structure. Because of the numerous formal and ad-hoc serialisations have been devised, and the prevalence of ad-hoc or buggy parsers, treating DNs as string in the interals of a program inevitably leads to errors. In fact, dangerous security issues can arise!</p>
<p>In this post I will explain the structure of DNs, review the common serialisation regimes, and review some DN-related bugs in projects I worked on. I’ll conclude with my <em>best practices</em> recommendations for working with DNs.</p>
<h2 id="dn-structure">DN structure</h2>
<p>DNs are defined by the ITU-T <strong>X.501</strong> standard a ASN.1 objects:</p>
<pre><code>Name ::= CHOICE {
  -- only one possibility for now --
  rdnSequence RDNSequence }

RDNSequence ::= SEQUENCE OF RelativeDistinguishedName

DistinguishedName ::= RDNSequence

RelativeDistinguishedName ::=
  SET SIZE (1..MAX) OF AttributeTypeAndValue

AttributeTypeAndValue ::= SEQUENCE {
  type  ATTRIBUTE.&amp;id({SupportedAttributes}),
  value ATTRIBUTE.&amp;Type({SupportedAttributes}{@type}),
  ... }</code></pre>
<p>The <code>AttributeTypeAndValue</code> definition refers to some other definitions. It means that <code>type</code> is an <em>object identifier (OID)</em> of some supported attribute, and the syntax of <code>value</code> is determined by <code>type</code>. The term <em>attribute-value assertion (AVA)</em> is a common synonym for <code>AttributeTypeAndValue</code>.</p>
<p>Applications define a bounded set of supported attributes. For example the X.509 certificate standard suggests a minimal set of supported attributes, and an LDAP server’s schema defines all the attribute types understood by that server. Depending on the application, a program might fail to process a DN with an unrecognised attribute type, or it might process it just fine, treating the corresponding value as opaque data.</p>
<p>Whereas the order of AVAs within an RDN is insignificant (it is a <code>SET</code>), the order of RDNs within the DN is significant. If you view the list left-to-right, then the <em>root</em> is on the left. X.501 formalises it thus:</p>
<blockquote>
<p>Each initial sub-sequence of the name of an object is also the name of an object. The sequence of objects so identified, starting with the root and ending with the object being named, is such that each is the immediate superior of that which follows it in the sequence.</p>
</blockquote>
<p>This also means that the empty DN is a valid DN.</p>
<h2 id="comparing-dns">Comparing DNs</h2>
<p>Testing DNs for equality is an important operation. For example, when constructing an X.509 certification path, we have to find a trusted CA certificate based on the certificate chain presented by an entity (e.g. a TLS server), then verify that the chain is complete by ensuring that each <em>Issuer DN</em>, starting from the end entity certificate, matches the <em>Subject DN</em> of the certificate “above” it, all the way up to a trusted CA certificate. (Then the signatures must be verified, and several more checks performed).</p>
<p>Continuing with this example, if an implementation falsely determines that two equal DNs (under X.500) are inequal, then it will fail to construct the certification path and reject the certificate. This is not good. But even worse would be if it decides that two unequal DNs are in fact equal! Similarly, if you are issuing certificates or creating LDAP objects or anything else, a user could exploit bugs in your DN handling code to cause you to issue certificates, or create objects, that you did not intend.</p>
<p>Having motivated the importance of correct DN comparison, well, how <em>do</em> you compare DNs correctly?</p>
<p>First, the program must represent the DNs according to their true structure: a list of sets (<em>RDNs</em>) of attribute-value pairs (<em>AVAs</em>). If the DNs are not already represented this way in the program, they must be parsed or processed—correctly.</p>
<p>Now that the structure is correct, AVAs can be compared for equality. Each attribute type defines an <em>equality matching rule</em> that says how values should be compared. In some cases this is just binary matching. In other cases, normalisation or other rules must be applied to the values. For example, some string types may be case insensitive.</p>
<p>A notable case is the <code>DirectoryString</code> syntax used by several attribute types in X.509:</p>
<pre><code>DirectoryString ::= CHOICE {
    teletexString       TeletexString   (SIZE (1..MAX)),
    printableString     PrintableString (SIZE (1..MAX)),
    universalString     UniversalString (SIZE (1..MAX)),
    utf8String          UTF8String      (SIZE (1..MAX)),
    bmpString           BMPString       (SIZE (1..MAX)) }</code></pre>
<p><code>DirectoryString</code> supports a choice of string encodings. Values of use <code>PrintableString</code> orr <code>UTF8String</code> encoding must be preprocessed using the LDAP <em>Internationalized String Preparation</em> rules (<a href="https://tools.ietf.org/html/rfc4518">RFC 4518</a>), including case folding and insignificant whitespace compression.</p>
<p>Taking the DN as a whole, two DNs are equal if they have the same RDNs in the same order, and two RDNs are equal if they have the same AVAs in <em>any</em> order (i.e. sets of equal size, with each AVA in one set having a matching AVA in the other set).</p>
<p>Ultimately this means that, despite X.509 certificates using <em>Distinguised Encoding Rules (DER)</em> for serialisation, there can still be multiple ways to represent equivalent data (by using different string encodings). Therefore, binary matching of serialised DNs, or even binary matching of individual attribute values, is incorrect behaviour and may lead to failures.</p>
<h2 id="string-representations">String representations</h2>
<p>Several string representations of DNs, both formally-specified and ad-hoc, are in widespread use. In this section I’ll list some of the more important ones.</p>
<p>Because DNs are ordered, one of the most obvious characteristics of a string representation is whether it lists the RDNs in <em>forward</em> or <em>reverse</em> order, i.e. with the root at the left or right. Some popular libraries and programs differ in this regard.</p>
<p>As we look at some of these common implementations, we’ll use the following DN as an example:</p>
<pre><code>SEQUENCE (3 elem)
  SET (2 elem)
    SEQUENCE (2 elem)
      OBJECT IDENTIFIER 2.5.4.6 countryName
      PrintableString AU
    SEQUENCE (2 elem)
      OBJECT IDENTIFIER 2.5.4.8 stateOrProvinceName
      PrintableString Queensland
  SET (1 elem)
    SEQUENCE (2 elem)
      OBJECT IDENTIFIER 2.5.4.10 organizationName
      PrintableString Acme, Inc.
  SET (1 elem)
    SEQUENCE (2 elem)
      OBJECT IDENTIFIER 2.5.4.3 commonName
      PrintableString CA</code></pre>
<h3 id="rfc-4514">RFC 4514</h3>
<pre><code>CN=CA,O=Acme\, Inc.,C=AU+ST=Queensland
CN=CA,O=Acme\2C Inc.,C=AU+ST=Queensland</code></pre>
<p><a href="https://tools.ietf.org/html/rfc4514">RFC 4514</a> defines the string representation of distinguished names used in LDAP. As such, there is widespread library support for parsing and printing DNs in this format. The RDNs are in reverse order, separated by <code>,</code>. Special characters are escaped using backslash (<code>\</code>), and can be represented using the escaped character itself (e.g. <code>\,</code>) or two hex nibbles (<code>\2C</code>). The AVAs within a multi-valued RDN are separated by <code>+</code>, in any order.</p>
<p>Due to the multiple ways of escaping special characters, this is not a distinguished encoding.</p>
<p>This format is used by GnuTLS, OpenLDAP and FreeIPA, among other projects.</p>
<h3 id="rfc-1485">RFC 1485</h3>
<pre><code>CN=CA,O=&quot;Acme, Inc.&quot;,C=AU+ST=Queensland</code></pre>
<p><a href="https://tools.ietf.org/html/rfc1485">RFC 1485</a> is a predecessor of a predecessor (RFC 1779) of a predecessor (RFC 2253) of RFC 4514. There are some differences from RFC 4514. For example, special character escapes are not supported; quotes must be used. This format is still relevant today because NSS uses it for pretty-printing and parsing DNs.</p>
<h3 id="openssl">OpenSSL</h3>
<p>OpenSSL prints DNs in its own special way. Unlike most other implementations, it works with DNs in <em>forward</em> order (root at left). The pretty-print looks like:</p>
<pre><code>C = AU + ST = Queensland, O = &quot;Acme, Inc.&quot;, CN = CA</code></pre>
<p>The format when parsing is different again. Some commands need a flag to enable support for multi-valued RDNs; e.g. <code>openssl req -multivalue-rdn ...</code>.</p>
<pre><code>/C=AU+ST=Queensland/O=Acme, Inc./CN=CA</code></pre>
<p>OpenSSL can also read DNs from a config file where AVAs are given line by line (see <code>config</code> and <code>x509v3_config(5)</code>). But this is not a DN string representation <em>per se</em> so I won’t cover it here.</p>
<h2 id="bugs-bugs-bugs">Bugs, bugs, bugs</h2>
<p>Here are three interesting bugs I discovered, related to DN string encoding.</p>
<h3 id="ds-49543-certmap-fails-when-issuer-dn-has-comma-in-name">389 DS <a href="https://pagure.io/389-ds-base/issue/49543">#49543</a>: certmap fails when Issuer DN has comma in name</h3>
<p>389 DS supports TLS certificate authentication for binding to LDAP. Different certificate mapping (<em>certmap</em>) policies can be defined for different CAs. The issuer DN in the client certificate is used to look up a certmap configuration. Unfortunately, a string comparison was used to perform this lookup. 389 uses NSS, which serialised the DN using RFC 1485 syntax. If this disagreed with how the DN in the certmap configuration appeared (after normalisation), the lookup—hence the LDAP bind—would fail. The normalisation function was also buggy.</p>
<p>The <a href="https://pagure.io/389-ds-base/pull-request/49611#request_diff">fix</a> was to parse the certmap DN string into an a NSS <code>CertNAME</code> using the <code>CERT_AsciiToName</code> routine, then compare the Issuer DN from the certificate against it using the NSS DN comparison routine (<code>CERT_CompareName</code>). The buggy normalisation routine was deleted.</p>
<h3 id="certmonger-90-incorrect-dn-in-csr">Certmonger <a href="https://pagure.io/certmonger/issue/90">#90</a>: incorrect DN in CSR</h3>
<p>Certmonger stores tracking request configuration in a flat text file. This configuration includes the string representation of the DN, ostensibly in RFC 4514 syntax. When constructing a CSR for the tracking request, it parsed the DN then used the result to construct an OpenSSL <code>X509_NAME</code>, which would be used in OpenSSL routines to create the CSR.</p>
<p>Unfortunately, the DN parsing implementation—a custom routine in Certmonger itself—was busted. A DN string like:</p>
<pre><code>CN=IPA RA,O=Acme\, Inc.,ST=Massachusetts,C=US</code></pre>
<p>Resulted in a CSR with the following DN:</p>
<pre><code>CN=IPA RA,CN=Inc.,O=Acme\\,ST=Massachusetts,C=US</code></pre>
<p>The <a href="https://pagure.io/certmonger/pull-request/108#request_diff">fix</a> was to remove the buggy parser and use the OpenLDAP <code>ldap_str2dn</code> routine instead. This was a joint effort between Rob Crittenden and myself.</p>
<h3 id="freeipa-7750-invalid-modlist-when-attribute-encoding-can-vary">FreeIPA <a href="https://pagure.io/freeipa/issue/7750">#7750</a>: invalid modlist when attribute encoding can vary</h3>
<p>FreeIPA’s LDAP library, <em>ipaldap</em>, uses <em>python-ldap</em> for handling low-level stuff and provides a lot of useful stuff on top. One useful thing it does is keeps track of the original attribute values for an object, so that we can perform changes locally and efficiently produce a list of modifications (<em>modlist</em>) for when we want to update the object at the server.</p>
<p><em>ipaldap</em> did not take into account the possibility of the attribute encoding returned by <em>python-ldap</em> differing from the attribute encoding produced by FreeIPA. A disagreement could arise when DN attribute values contained special characters requiring escaping. For example, <em>python-ldap</em> escaped characters using hex encoding:</p>
<pre><code>CN=CA,O=Red Hat\2C Inc.,L=Brisbane,C=AU</code></pre>
<p>The representation produced by <em>python-ldap</em> is recorded as the original value of the attribute. However, if you wrote the same attribute value back, it would pass through FreeIPA’s encoding routine, which might encode it differently and record it as a new value:</p>
<pre><code>CN=CA,O=Red Hat\, Inc.,L=Brisbane,C=AU</code></pre>
<p>When you go to update the object, the modlist would look like:</p>
<pre><code>[ (ldap.MOD_ADD, &#39;ipacaissuerdn&#39;,
    [b&#39;CN=CA,O=Red Hat\, Inc.,L=Brisbane,C=AU&#39;])
, (ldap.MOD_DELETE, &#39;ipacaissuerdn&#39;,
    [b&#39;CN=CA,O=Red Hat\2C Inc.,L=Brisbane,C=AU&#39;])
]</code></pre>
<p>Though encoded differently, <em>these are the same value</em> but that in itself is not a problem. The problem is that the server also has the same value, and processing the <code>MOD_ADD</code> first results in an <code>attributeOrValueExists</code> error. You can’t add a value that’s already there!</p>
<p>The ideal fix for this would be to update <em>ipaldap</em> to record all values as ASN.1 data or DER, rather than strings. But that would be a large and risky change. Instead, we <a href="https://github.com/freeipa/freeipa/pull/2511">work around</a> the issue by always putting deletes before adds in the modlist. LDAP servers process changes in the order they are presented (389 DS does so atomically). So deleting an attribute value then adding it straight back is a safe, albeit inefficient, workaround.</p>
<h2 id="discussion">Discussion</h2>
<p>So you have to compare or handle some DNs. What do you do? My recommendations are:</p>
<ul>
<li>If you need to print/parse DNs as strings, if possible use RFC 4514 because it has the most widespread library support.</li>
<li>Don’t write your own DN parsing code. This is where security vulnerabilities are most likely. Use existing library routines for parsing DNs. If you have no other choice, take extreme care and if possible use a parser combinator library or parser generator to make the definitions more declarative and reduce likelihood of error.</li>
<li>Always decode attribute values (if the DN parsing routine doesn’t do it for you). This avoids confusion where attribute values could be encoded in different ways (due to escaped characters or differing string encodings).</li>
<li>Use established library routines for comparing DNs <em>using the internal DN structures, not strings</em>.</li>
</ul>
<p>Above all, just remember: <em>a Distinguished Name is not a string</em>, so don’t treat it like a string. For sure it’s more work, but DNs need special treatment or bugs will certainly arise.</p>
<p>That’s not to say that “native” DN parsing and comparison routines are bug-free. They are not. A common error is equal DNs comparing inequal due to differing attribute string encodings (e.g. <code>PrintableString</code> versus <code>UTF8String</code>). I have written about this in a <a href="2018-03-15-x509-dn-attribute-encoding.html">previous post</a>. In Dogtag we’ve enountered this kind of bug <a href="https://pagure.io/dogtagpki/issue/2475">quite</a> <a href="https://pagure.io/dogtagpki/issue/2828">a</a> <a href="https://pagure.io/dogtagpki/issue/2865">few</a> times. In these situations the DN comparison should be fixed, but it may be a satisfactory workaround to serialise <em>both</em> DNs and perform a string comparison.</p>
<p>Another common issue is lack of support for multi-valued RDNs. A few years ago we wanted to switch FreeIPA’s certificate handling from <em>python-nss</em> to the <em>cryptography</em> library. I had to <a href="https://github.com/pyca/cryptography/issues/3199">add support</a> for multi-valued RDNs before we could make the switch.</p>
<p>A final takeaway for authors of standards. Providing multiple ways to serialise the same value leads to incompatibilities and bugs. For sure, there is a tradeoff between usability, implementation complexity and risk of interoperability issues and bugs. RFC 4514 would be less human-friendly if it only permitted hex-escapes. But implementations would be simpler and the interop/bug risk would be reduced. It’s important to think about these tradeoffs and the consequences, especially for standards and protocols relating to security.</p>]]></summary>
</entry>

</feed>
