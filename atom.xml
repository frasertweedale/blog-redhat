<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Fraser's IdM Blog</title>
    <link href="https://frasertweedale.github.io/blog-redhat/atom.xml" rel="self" />
    <link href="https://frasertweedale.github.io/blog-redhat" />
    <id>https://frasertweedale.github.io/blog-redhat/atom.xml</id>
    <author>
        <name>Fraser Tweedale</name>
        <email>frase@frase.id.au</email>
    </author>
    <updated>2018-11-20T00:00:00Z</updated>
    <entry>
    <title>FreeIPA CA renewal master explained</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2018-11-20-ca-renewal-master.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2018-11-20-ca-renewal-master.html</id>
    <published>2018-11-20T00:00:00Z</published>
    <updated>2018-11-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="freeipa-ca-renewal-master-explained">FreeIPA CA renewal master explained</h1>
<p>Every FreeIPA deployment has a critical setting called the <em>CA renewal master</em>. In this post I explain how this setting is used, why it is important, and the consequences of improper configuration. I’ll also discuss scenarios which cause the value to change, and why and how you would change it manually.</p>
<h2 id="what-is-the-ca-renewal-master">What is the CA renewal master?</h2>
<p>The CA renewal master configuration controls which CA replica is responsible for renewing some important certificate used within a FreeIPA deployment. I will call these <em>system certificates</em>.</p>
<p>Unlike service certificates (e.g. for HTTP and LDAP) which have different keypairs and subject names on different servers, FreeIPA system certificates, and their keys, are shared by all CA replicas. These include the IPA CA certificate, OCSP certificate, Dogtag subsystem certificates, Dogtag audit signing certificate, IPA RA agent certificate and KRA transport and storage certificates.</p>
<p>The current CA renewal master configuration can be viewed via <code>ipa config-show</code>:</p>
<pre><code>[f28-1] ftweedal% ipa config-show | grep &#39;CA renewal master&#39;
  IPA CA renewal master: f28-1.ipa.local</code></pre>
<p>Under the hood, this configuration is a <em>server role attribute</em>. The CA renewal master is indicated by the presence of an <code>(ipaConfigString=caRenewalMaster)</code> attribute value on an IPA server’s CA role object. You can determine the renewal master via a plain LDAP search:</p>
<pre><code>[f28-1] ftweedal% ldapsearch -LLL \
      -D &quot;cn=Directory Manager&quot; \
      &quot;(ipaConfigString=carenewalmaster)&quot;
dn: cn=CA,cn=f28-1.ipa.local,cn=masters,cn=ipa,cn=etc,dc=ipa,dc=local
objectClass: nsContainer
objectClass: ipaConfigObject
objectClass: top
cn: CA
ipaConfigString: startOrder 50
ipaConfigString: caRenewalMaster
ipaConfigString: enabledService</code></pre>
<p>The configuration is automatically set to the first master in the topology on which the CA role was installed. Unless you installed without a CA, this is the original master set up via <code>ipa-server-install</code>.</p>
<h2 id="what-problem-is-solved-by-having-a-ca-renewal-master">What problem is solved by having a CA renewal master?</h2>
<p>All CA replicas have tracking requests for all system certificates. But if all CA replicas renewed system certificates independently, they would end up with different certificates. This is especially a problem for the CA certificate, and the subsystem and IPA RA certificates which get stored in LDAP for authentication purposes. The certificates must match exactly, otherwise there will be authentication failures between the FreeIPA framework and Dogtag, and between Dogtag and LDAP.</p>
<p>Appointing one CA replica as the renewal master allows the system certificates to be renewed exactly once, when required.</p>
<h3 id="how-do-other-replicas-acquire-the-updated-certificates">How do other replicas acquire the updated certificates?</h3>
<p>The Certmonger tracking requests on all CA replicas use the <code>dogtag-ipa-ca-renew-agent</code> renewal helper. This program reads the CA renewal master configuration. If the current host is the renewal master, it performs the renewal, and stores the certificate in LDAP under <code>cn=&lt;nickname&gt;,cn=ca_renewal,cn=ipa,cn=etc,{basedn}</code>. Additionally, if the certificate is the IPA RA or the Dogtag CA subsystem certificate, the new certificate gets added to the <code>userCertificate</code> attribute of the corresponding LDAP user entry</p>
<p>If the renewal master is a different host, the latest certificate is retrieved from the <code>ca_renewal</code> LDAP entry and returned to Certmonger. Due to non-determinism in exactly when Certmonger renewal attempts will occur, the non-renewal helper could attempt to “renew” the certificate before the renewal master has actually renewed the certificate. So it is <em>not an error</em> for the renewal helper to return the old (soon to expire) certificate. Certmonger will keep attempting to renew the certificate (with some delay between attempts) until it can retrieve the updated certificate (which will not expire soon).</p>
<h2 id="what-can-go-wrong">What can go wrong?</h2>
<p>If it wasn’t clear already, a (CA-ful) FreeIPA deployment must at all times have exactly one CA replica configured as the renewal master. That server must be online, operating normally, and replicating properly with other servers. Let’s look at what happens if these conditions are not met.</p>
<p>If the CA renewal master configuration refers to a server that has been decommissioned, or is offline, then no server will actually renew the certificates. All the non-renewal master servers will happily reinstall the current certificate, until they expire, and things will break. The troublesome thing about certificates is even one expired certificate can cause renewal failures for other certificates. The problems cascade and eventually the whole deployment is busted.</p>
<p>FreeIPA has a simple protection in place to ensure the renewal master configuration stays valid. Servers can be deleted from the topology via the <code>ipa server-del</code>, <code>ipa-replica-manage del</code>, <code>ipa-csreplica-manage del</code> or <code>ipa-server-install --uninstall</code> command. In these commands, if the server being deleted is the current CA renewal master, a different CA replica is elected as the new CA renewal master.</p>
<p>These protections only go so far. If the renewal master is still part of the topology but is offline for an extended duration it may miss a renewal window, causing expired certificates. If there are replication problems between the renewal master and other CA replicas, renewal might succeed, but the other CA replicas might not be able to retrieve the updated certificates before they expire. All of these problems (and more) have been seen in the wild.</p>
<p>I have seen cases where a CA renewal master was simply decommissioned without formally removing it from the FreeIPA topology. I have also seen cases where there was no CA renewal master configured (I do not know how this situation arose). Both of these scenarios have similar consequences to the “offline for extended duration” scenario.</p>
<p>What would happen if you had two (or more) CA replicas with <code>(ipaConfigString=caRenewalMaster)</code>? I haven’t seen this one in the wild, but I would not be surprised if one day I did see it. In this case, multiple CA replicas will perform renewals. Will clobber each others’ certificates, and will result in some replicas having RA Agent or Dogtag subsystem certificates out of sync with the corresponding user entries in LDAP. This is a less catastrophic consequence than the aforementioned scenarios, but still serious. It will result in Dogtag or IPA RA authentication failures on some (or most) CA replicas.</p>
<h2 id="why-and-how-to-change-the-ca-renewal-master">Why and how to change the CA renewal master</h2>
<p>Why would you need to change the renewal master configuration? Assuming the existing configuration is valid, the main reason you would need to change it is in anticipation of the decommissioning of the existing CA renewal master. You may wish to appoint a particular server as the new renewal master. As discussed above, the commands that remove servers from the topology will do this automatically, but <em>which server</em> will be chosen is out of your hands. So you can get one step ahead and change the renewal master yourself.</p>
<p>In my test setup there are two CA replicas:</p>
<pre><code>[f28-1] ftweedal% ipa server-role-find --role &#39;CA server&#39;
----------------------
2 server roles matched
----------------------
  Server name: f28-0.ipa.local
  Role name: CA server
  Role status: enabled

  Server name: f28-1.ipa.local
  Role name: CA server
  Role status: enabled
----------------------------
Number of entries returned 2
----------------------------</code></pre>
<p>The current renewal master is <code>f28-1.ipa.local</code>:</p>
<pre><code>[f28-1] ftweedal% ipa config-show | grep &#39;CA renewal master&#39;
  IPA CA renewal master: f28-1.ipa.local</code></pre>
<p>The preferred way to change the renewal master configuration is via the <code>ipa config-mod</code> command:</p>
<pre><code>[f28-1] ftweedal% ipa config-mod \
      --ca-renewal-master-server f28-0.ipa.local \
      | grep &#39;CA renewal master&#39;
  IPA CA renewal master: f28-0.ipa.local</code></pre>
<p>You can also use the <code>ipa-csreplica-manage</code> command. This requires the <code>Directory Manager</code> passphrase:</p>
<pre><code>[f28-1] ftweedal% ipa-csreplica-manage \
                    set-renewal-master f28-1.ipa.local
Directory Manager password: XXXXXXXX

f28-1.ipa.local is now the renewal master</code></pre>
<p>If for whatever reason the current renewal master configuration is invalid, you can use these same commands to reset it. As a last resort, you can modify the LDAP objects directly to ensure that exactly one CA role object has <code>(ipaConfigString=caRenewalMaster)</code>. Note that both the attribute name (<code>ipaConfigString</code>) and value (<code>caRenewalMaster</code>) are case-<em>insensitive</em>.</p>
<p>Finally, let’s observe what happens when we remove a server from the topology. I’ll remove <code>f28-1.ipa.local</code> (the current renewal master) using the <code>ipa-server-install --uninstall</code> command. After this operation, the CA renewal master configuration should point to <code>f28-0.ipa.local</code> (the only other CA replica in the topology).</p>
<pre><code>[f28-1:~] ftweedal% sudo ipa-server-install --uninstall

This is a NON REVERSIBLE operation and will delete all data
and configuration!
It is highly recommended to take a backup of existing data
and configuration using ipa-backup utility before proceeding.

Are you sure you want to continue with the uninstall procedure? [no]: yes
Forcing removal of f28-1.ipa.local
Failed to cleanup f28-1.ipa.local DNS entries: DNS is not configured
You may need to manually remove them from the tree
------------------------------------
Deleted IPA server &quot;f28-1.ipa.local&quot;
------------------------------------
Shutting down all IPA services
Unconfiguring CA
... (snip!)
Client uninstall complete.
The ipa-client-install command was successful
The ipa-server-install command was successful</code></pre>
<p>Jumping across to <code>f28-0.ipa.local</code>, let’s check the CA renewal master configuration:</p>
<pre><code>[f28-0] ftweedal% ipa config-show |grep &#39;CA renewal master&#39;
  IPA CA renewal master: f28-0.ipa.local</code></pre>
<p>As expected, the <code>f28-0.ipa.local</code> has become the renewal master.</p>
<h2 id="explicit-ca-certificate-renewal">Explicit CA certificate renewal</h2>
<p>There is one more scenario that can cause the CA renewal master to be changed. When the IPA CA certificate is explicitly renewed via the <code>ipa-cacert-manage renew</code> command the server on which the operation is performed becomes the CA renewal master. This is to cause the CA replica that <em>was</em> the renewal master to retrieve the new CA certificate from LDAP instead of renewing it.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post I explained what the CA renewal master configuration is for and what it looks like under the hood. For FreeIPA/Dogtag system certificates, the CA renewal master configuration controls which CA replica actually performs renewal. The CA renewal master stores the renewed certificates in LDAP, and all other CA replicas look for them there. The <code>dogtag-ipa-ca-renew-agent</code> Certmonger renewal helper implements both of these behaviours, using the CA renewal master configuration to decide which behaviour to execute.</p>
<p>There must be exactly one CA renewal master in a topology and it must be operational. I discussed the consequences of various configuration or operational problems. I also explained why you might want to change the CA renewal master, and how to do it.</p>
<p>The CA renewal master is a critical configuration and incorrect renewal master configuration is often a factor in complex customer cases involving FreeIPA’s PKI. Commands that remove servers from the topology <em>should</em> elect a new CA renewal master when necessary. But misconfigurations do arise (if only we could know all the ways how!)</p>
<p>The upcoming FreeIPA <a href="https://www.freeipa.org/page/V4/Healthcheck">Healthcheck</a> feature will, among other checks, confirm that the CA renewal master configuration is sane. It will not (in the beginning at least) be able to diagnose availability or connectivity issues. But it should catch some misconfigurations before they lead to catastrophic failure of the deployment.</p>]]></summary>
</entry>
<entry>
    <title>Should FreeIPA ship a subordinate CA profile?</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2018-10-19-ipa-sub-ca-profile.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2018-10-19-ipa-sub-ca-profile.html</id>
    <published>2018-10-19T00:00:00Z</published>
    <updated>2018-10-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="should-freeipa-ship-a-subordinate-ca-profile">Should FreeIPA ship a subordinate CA profile?</h1>
<p>In my <a href="2018-08-21-ipa-subordinate-ca.html">previous post</a> I discussed how to issue subordinate CA (sub-CA) certificates from FreeIPA. In brief, the administrator must create and import a profile configuration for issuing certificates with the needed characteristics. The profile must add a <em>Basic Constraints</em> extension asserting that the subject is a CA.</p>
<p>After publishing that post, it formed the basis of an official <a href="https://access.redhat.com/solutions/3572691">Red Hat solution</a> (Red Hat subscription required to view). Subsequently, an <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1639441">RFE was filed</a> requesting a sub-CA profile to be included by default in FreeIPA. In this short post I’ll outline the reasons why this might not be a good idea, and what the profile might look like if we did ship one.</p>
<h2 id="the-case-against">The case against</h2>
<p>The most important reason not to include a sub-CA profile is that it will not be appropriate for many use cases. Important attributes of a sub-CA certificate include:</p>
<ul>
<li>validity period (how long will the certificate be valid for?)</li>
<li>key usage and extended key usage (what can the certificate be used for?)</li>
<li>path length constraint (how many further subordinate CAs may be issued below this CA?)</li>
<li>name constraints (what namespaces can this CA issue certificates for?)</li>
</ul>
<p>If we ship a default sub-CA profile in FreeIPA, all of these attributes will be determined ahead of time and fixed. There is a good chance the values will not be appropriate, and the administrator must create a custom profile configuration anyway. Worse, there is a risk that the profile will be used without due consideration of its appropriateness.</p>
<p>If we do nothing, we still have the blog post and official solution to guide administrators through the process. The administrator has the opportunity to alter the profile configuration according to their security or operational requirements.</p>
<h2 id="the-case-for">The case for</h2>
<p>The RFE description states:</p>
<blockquote>
<p>Signing a subordinate CA’s CSR in IdM is difficult and requires tinkering. This functionality should be built in and present with the product. Please bundle a subordinate CA profile like the one described in the [blog post].</p>
</blockquote>
<p>I agree that Dogtag profile configuration is difficult, even obtuse. It is not well documented and there is limited sanity checking. There is no <em>“one size fits all”</em> when it comes to sub-CA profiles, but can there be a <em>“one size fits most”</em>? Such a profile might have:</p>
<ul>
<li>path length constraint of zero (the CA can only issue leaf certificates)</li>
<li>name constraints limiting DNS names to the FreeIPA domain (and subdomains)</li>
<li>a validity period of two years</li>
</ul>
<p>In terms of security these are conservative attributes but they still admit the most common use case. Two years may or may not be a reasonable lifetime for the subordinate CA, but we have to choose <em>some</em> fixed value. The downside is that customers could use this profile without being aware of its limitations (path length, name constraints). The resulting issues will frustrate the customer and probably result in some support cases too.</p>
<h2 id="alternatives-and-conclusion">Alternatives and conclusion</h2>
<p>There is a middle road: instead of shipping the profile, we ship a “profile assistant” tool that asks some questions and builds the profile configuration. Questions would include the desired validity period, whether it’s for a CA (and if so the path length constraint), name constraints (if any), and so on. Then it imports the configuration.</p>
<p>There may be merit to this option, but none of the machinery exists. The effort and lead time are high. The other options: <em>do-nothing</em> (really <em>improve and maintain documentation</em>), or shipping a default sub-CA profile—are low effort and lead time.</p>
<p>In conclusion, I am open to either leaving sub-CA profiles as a documentation concern, or including a conservative default profile. But because there is no <em>one size fits all</em>, I prefer to leave sub-CA profile creation as a documented process that administrators can perform themselves—and tweak as they see fit.</p>]]></summary>
</entry>
<entry>
    <title>Issuing subordinate CA certificates from FreeIPA</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2018-08-21-ipa-subordinate-ca.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2018-08-21-ipa-subordinate-ca.html</id>
    <published>2018-08-21T00:00:00Z</published>
    <updated>2018-08-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="issuing-subordinate-ca-certificates-from-freeipa">Issuing subordinate CA certificates from FreeIPA</h1>
<p>FreeIPA, since version 4.4, has supported creating subordinate CAs within the deployment’s Dogtag CA instance. This feature is called <a href="2016-07-25-freeipa-subcas.html">lightweight sub-CAs</a>. But what about when you need to issue a subordinate CA certificate to an external entity? One use case would be chaining a FreeIPA deployment up to some existing FreeIPA deployment. This is similar to what many customers do with Active Directory. In this post I’ll show how you can issue subordinate CA certificates from FreeIPA.</p>
<h2 id="scenario-description">Scenario description</h2>
<p>The existing FreeIPA deployment has the realm <code>IPA.LOCAL</code> and domain <code>ipa.local</code>. Its CA’s <em>Subject Distinguished Name (Subject DN)</em> is <code>CN=Certificate Authority,O=IPA.LOCAL 201808022359</code>. The master’s hostname is <code>f28-0.ipa.local</code>. I will refer to this deployment as the <em>existing</em> or <em>primary deployment</em>.</p>
<p>I will install a new FreeIPA deployment on the host <code>f28-1.ipa.local</code>, with realm <code>SUB.IPA.LOCAL</code> and domain <code>sub.ipa.local</code>. This will be called the <em>secondary deployment</em>. Its CA will be signed by the CA of the primary deployment.</p>
<h2 id="choice-of-subject-principal-and-subject-dn">Choice of subject principal and Subject DN</h2>
<p>All certificate issuance via FreeIPA (with some limited exceptions) requires a nominated <em>subject principal</em>. Subject names in the CSR (Subject DN and <em>Subject Alternative Names</em>) are validated against the subject principal. We must create a subject principal in the primary deployment to represent the CA of the secondary deployment.</p>
<p>When validating CSRs, the <em>Common Name (CN)</em> of the Subject DN is checked against the subject principal, in the following ways:</p>
<ul>
<li>for <em>user</em> principals, the CN must match the UID</li>
<li>for <em>host</em> principals, the CN must match the hostname (case-insensitive)</li>
<li>for <em>service</em> principals, the CN must match the hostname (case-insensitive); only principal aliases with the same service type as the canonical principal are checked</li>
</ul>
<p>This validation regime imposes a restriction on what the CN of the subordinate CA can be. In particular:</p>
<ul>
<li>the Subject DN must contain a CN attribute</li>
<li>the CN value can be a hostname (host or service principal), or a UID (user principal)</li>
</ul>
<p>For this scenario, I chose to create a host principal for the domain of the secondary deployment:</p>
<pre><code>[f28-0]% ipa host-add --force sub.ipa.local
--------------------------
Added host &quot;sub.ipa.local&quot;
--------------------------
  Host name: sub.ipa.local
  Principal name: host/sub.ipa.local@IPA.LOCAL
  Principal alias: host/sub.ipa.local@IPA.LOCAL
  Password: False
  Keytab: False
  Managed by: sub.ipa.local</code></pre>
<h2 id="creating-a-certificate-profile-for-sub-cas">Creating a certificate profile for sub-CAs</h2>
<p>We will tweak the <code>caIPAserviceCert</code> profile configuration to create a new profile for subordinate CAs. Export the profile configuration:</p>
<pre><code>[f28-0]% ipa certprofile-show caIPAserviceCert --out SubCA.cfg
------------------------------------------------
Profile configuration stored in file &#39;SubCA.cfg&#39;
------------------------------------------------
  Profile ID: caIPAserviceCert
  Profile description: Standard profile for network services
  Store issued certificates: TRUE</code></pre>
<p>Perform the following edits to <code>SubCA.cfg</code>:</p>
<ol>
<li>Replace <code>profileId=caIPAserviceCert</code> with <code>profileId=SubCA</code>.</li>
<li><p>Replace the <code>subjectNameDefaultImpl</code> component with the <code>userSubjectNameDefaultImpl</code> component. This will use the Subject DN from the CSR <em>as is</em>, without restriction:</p>
<pre><code>policyset.serverCertSet.1.constraint.class_id=noConstraintImpl
policyset.serverCertSet.1.constraint.name=No Constraint
policyset.serverCertSet.1.default.class_id=userSubjectNameDefaultImpl
policyset.serverCertSet.1.default.name=Subject Name Default</code></pre></li>
<li>Edit the <code>keyUsageExtDefaultImpl</code> and <code>keyUsageExtConstraintImpl</code> configurations. They should have the following settings:
<ul>
<li><code>keyUsageCrlSign=true</code></li>
<li><code>keyUsageDataEncipherment=false</code></li>
<li><code>keyUsageDecipherOnly=false</code></li>
<li><code>keyUsageDigitalSignature=true</code></li>
<li><code>keyUsageEncipherOnly=false</code></li>
<li><code>keyUsageKeyAgreement=false</code></li>
<li><code>keyUsageKeyCertSign=true</code></li>
<li><code>keyUsageKeyEncipherment=false</code></li>
<li><code>keyUsageNonRepudiation=true</code></li>
</ul></li>
<li><p>Add the <em>Basic Constraints</em> extension configuration:</p>
<pre><code>policyset.serverCertSet.15.constraint.class_id=basicConstraintsExtConstraintImpl
policyset.serverCertSet.15.constraint.name=Basic Constraint Extension Constraint
policyset.serverCertSet.15.constraint.params.basicConstraintsCritical=true
policyset.serverCertSet.15.constraint.params.basicConstraintsIsCA=true
policyset.serverCertSet.15.constraint.params.basicConstraintsMinPathLen=0
policyset.serverCertSet.15.constraint.params.basicConstraintsMaxPathLen=0
policyset.serverCertSet.15.default.class_id=basicConstraintsExtDefaultImpl
policyset.serverCertSet.15.default.name=Basic Constraints Extension Default
policyset.serverCertSet.15.default.params.basicConstraintsCritical=true
policyset.serverCertSet.15.default.params.basicConstraintsIsCA=true
policyset.serverCertSet.15.default.params.basicConstraintsPathLen=0</code></pre>
<p>Add the new components’ index to the component list, to ensure they get processed:</p>
<pre><code>policyset.serverCertSet.list=1,2,3,4,5,6,7,8,9,10,11,12,15</code></pre></li>
<li><p>Remove the <code>commonNameToSANDefaultImpl</code> and <em>Extended Key Usage</em> related components. This can be accomplished by removing the relevant indices (in my case, <code>7</code> and <code>12</code>) from the component list:</p>
<pre><code>policyset.serverCertSet.list=1,2,3,4,5,6,8,9,10,11,15</code></pre></li>
<li>(<em>Optional</em>) edit the validity period in the <code>validityDefaultImpl</code> and <code>validityConstraintImpl</code> components. The default is 731 days. I did not change it.</li>
</ol>
<p>For the avoidance of doubt, the diff between the <code>caIPAserviceCert</code> profile configuration and <code>SubCA</code> is:</p>
<pre><code>--- caIPAserviceCert.cfg        2018-08-21 12:44:01.748884778 +1000
+++ SubCA.cfg   2018-08-21 14:05:53.484698688 +1000
@@ -13,5 +13,3 @@
-policyset.serverCertSet.1.constraint.class_id=subjectNameConstraintImpl
-policyset.serverCertSet.1.constraint.name=Subject Name Constraint
-policyset.serverCertSet.1.constraint.params.accept=true
-policyset.serverCertSet.1.constraint.params.pattern=CN=[^,]+,.+
-policyset.serverCertSet.1.default.class_id=subjectNameDefaultImpl
+policyset.serverCertSet.1.constraint.class_id=noConstraintImpl
+policyset.serverCertSet.1.constraint.name=No Constraint
+policyset.serverCertSet.1.default.class_id=userSubjectNameDefaultImpl
@@ -19 +16,0 @@
-policyset.serverCertSet.1.default.params.name=CN=$request.req_subject_name.cn$, o=IPA.LOCAL 201808022359
@@ -66,2 +63,2 @@
-policyset.serverCertSet.6.constraint.params.keyUsageCrlSign=false
-policyset.serverCertSet.6.constraint.params.keyUsageDataEncipherment=true
+policyset.serverCertSet.6.constraint.params.keyUsageCrlSign=true
+policyset.serverCertSet.6.constraint.params.keyUsageDataEncipherment=false
@@ -72,2 +69,2 @@
-policyset.serverCertSet.6.constraint.params.keyUsageKeyCertSign=false
-policyset.serverCertSet.6.constraint.params.keyUsageKeyEncipherment=true
+policyset.serverCertSet.6.constraint.params.keyUsageKeyCertSign=true
+policyset.serverCertSet.6.constraint.params.keyUsageKeyEncipherment=false
@@ -78,2 +75,2 @@
-policyset.serverCertSet.6.default.params.keyUsageCrlSign=false
-policyset.serverCertSet.6.default.params.keyUsageDataEncipherment=true
+policyset.serverCertSet.6.default.params.keyUsageCrlSign=true
+policyset.serverCertSet.6.default.params.keyUsageDataEncipherment=false
@@ -84,2 +81,2 @@
-policyset.serverCertSet.6.default.params.keyUsageKeyCertSign=false
-policyset.serverCertSet.6.default.params.keyUsageKeyEncipherment=true
+policyset.serverCertSet.6.default.params.keyUsageKeyCertSign=true
+policyset.serverCertSet.6.default.params.keyUsageKeyEncipherment=false
@@ -111,2 +108,13 @@
-policyset.serverCertSet.list=1,2,3,4,5,6,7,8,9,10,11,12
-profileId=caIPAserviceCert
+policyset.serverCertSet.15.constraint.class_id=basicConstraintsExtConstraintImpl
+policyset.serverCertSet.15.constraint.name=Basic Constraint Extension Constraint
+policyset.serverCertSet.15.constraint.params.basicConstraintsCritical=true
+policyset.serverCertSet.15.constraint.params.basicConstraintsIsCA=true
+policyset.serverCertSet.15.constraint.params.basicConstraintsMinPathLen=0
+policyset.serverCertSet.15.constraint.params.basicConstraintsMaxPathLen=0
+policyset.serverCertSet.15.default.class_id=basicConstraintsExtDefaultImpl
+policyset.serverCertSet.15.default.name=Basic Constraints Extension Default
+policyset.serverCertSet.15.default.params.basicConstraintsCritical=true
+policyset.serverCertSet.15.default.params.basicConstraintsIsCA=true
+policyset.serverCertSet.15.default.params.basicConstraintsPathLen=0
+policyset.serverCertSet.list=1,2,3,4,5,6,8,9,10,11,15
+profileId=SubCA</code></pre>
<p>Now import the profile:</p>
<pre><code>[f28-0]% ipa certprofile-import SubCA \
            --desc &quot;Subordinate CA&quot; \
            --file SubCA.cfg \
            --store=1
------------------------
Imported profile &quot;SubCA&quot;
------------------------
  Profile ID: SubCA
  Profile description: Subordinate CA
  Store issued certificates: TRUE</code></pre>
<h2 id="creating-the-ca-acl">Creating the CA ACL</h2>
<p>Before issuing a certificate, <em>CA ACLs</em> are checked to determine if the combination of CA, profile and subject principal is acceptable. We must create a CA ACL that permits use of the <code>SubCA</code> profile to issue certificate to our subject principal:</p>
<pre><code>[f28-0]% ipa caacl-add SubCA
--------------------
Added CA ACL &quot;SubCA&quot;
--------------------
  ACL name: SubCA
  Enabled: TRUE

[f28-0]% ipa caacl-add-profile SubCA --certprofile SubCA
  ACL name: SubCA
  Enabled: TRUE
  Profiles: SubCA
-------------------------
Number of members added 1
-------------------------

[f28-0]% ipa caacl-add-ca SubCA --ca ipa
  ACL name: SubCA
  Enabled: TRUE
  CAs: ipa
  Profiles: SubCA
-------------------------
Number of members added 1
-------------------------

[f28-0]% ipa caacl-add-host SubCA --hosts sub.ipa.local
  ACL name: SubCA
  Enabled: TRUE
  CAs: ipa
  Profiles: SubCA
  Hosts: sub.ipa.local
-------------------------
Number of members added 1
-------------------------</code></pre>
<h2 id="installing-the-secondary-freeipa-deployment">Installing the secondary FreeIPA deployment</h2>
<p>We are finally ready to run <code>ipa-server-install</code> to set up the secondary deployment. We need to use the <code>--ca-subject</code> option to override the default Subject DN that will be included in the CSR, providing a valid DN according to the rules discussed above.</p>
<pre><code>[root@f28-1]# ipa-server-install \
    --realm SUB.IPA.LOCAL \
    --domain sub.ipa.local \
    --external-ca \
    --ca-subject &#39;CN=SUB.IPA.LOCAL,O=Red Hat&#39;

...

The IPA Master Server will be configured with:
Hostname:       f28-1.ipa.local
IP address(es): 192.168.124.142
Domain name:    sub.ipa.local
Realm name:     SUB.IPA.LOCAL

The CA will be configured with:
Subject DN:   CN=SUB.IPA.LOCAL,O=Red Hat
Subject base: O=SUB.IPA.LOCAL
Chaining:     externally signed (two-step installation)

Continue to configure the system with these values? [no]: yes

...

Configuring certificate server (pki-tomcatd). Estimated time: 3 minutes
  [1/8]: configuring certificate server instance

The next step is to get /root/ipa.csr signed by your CA and re-run
/usr/sbin/ipa-server-install as:
/usr/sbin/ipa-server-install
  --external-cert-file=/path/to/signed_certificate
  --external-cert-file=/path/to/external_ca_certificate
The ipa-server-install command was successful</code></pre>
<p>Let’s inspect <code>/root/ipa.csr</code>:</p>
<pre><code>[root@f28-1]# openssl req -text &lt; /root/ipa.csr |grep Subject:
        Subject: O = Red Hat, CN = SUB.IPA.LOCAL</code></pre>
<p>The desired Subject DN appears in the CSR (note that <code>openssl</code> shows DN components in the opposite order from FreeIPA). After copying the CSR to <code>f28-0.ipa.local</code> we can request the certificate:</p>
<pre><code>[f28-0]% ipa cert-request ~/ipa.csr \
            --principal host/sub.ipa.local \
            --profile SubCA \
            --certificate-out ipa.pem
  Issuing CA: ipa
  Certificate: MIIEAzCCAuugAwIBAgIBFTANBgkqhkiG9w0BAQsF...
  Subject: CN=SUB.IPA.LOCAL,O=Red Hat
  Issuer: CN=Certificate Authority,O=IPA.LOCAL 201808022359
  Not Before: Tue Aug 21 04:16:24 2018 UTC
  Not After: Fri Aug 21 04:16:24 2020 UTC
  Serial number: 21
  Serial number (hex): 0x15</code></pre>
<p>The certificate was saved in the file <code>ipa.pem</code>. We can see from the command output that the Subject DN in the certificate is exactly what was in the CSR. Further inspecting the certificate, observe that the Basic Constraints extension is present and the Key Usage extension contains the appropriate assertions:</p>
<pre><code>[f28-0]% openssl x509 -text &lt; ipa.pem
...
      X509v3 extensions:
          ...
          X509v3 Key Usage: critical
              Digital Signature, Non Repudiation, Certificate Sign, CRL Sign
          ...
          X509v3 Basic Constraints: critical
              CA:TRUE, pathlen:0
          ...</code></pre>
<p>Now, after copying the just-issued subordinate CA certificate and the primary CA certificate (<code>/etc/ipa/ca.crt</code>) over to <code>f28-1.ipa.local</code>, we can continue the installation:</p>
<pre><code>[root@f28-1]# ipa-server-install \
                --external-cert-file ca.crt \
                --external-cert-file ipa.pem

The log file for this installation can be found in /var/log/ipaserver-install.log
Directory Manager password: XXXXXXXX

...

Adding [192.168.124.142 f28-1.ipa.local] to your /etc/hosts file
Configuring ipa-custodia
  [1/5]: Making sure custodia container exists
...
The ipa-server-install command was successful</code></pre>
<p>And we’re done.</p>
<h2 id="discussion">Discussion</h2>
<p>I’ve shown how to create a profile for issuing subordinate CA certificates in FreeIPA. Because of the way FreeIPA validates certificate requests—always against a subject principal—there are restrictions on the what the subject DN of the subordinate CA can be. The Subject DN must contain a CN attribute matching either the hostname of a host or service principal, or the UID of a user principal.</p>
<p>If you want to avoid these Subject DN restrictions, right now there is no choice but to use the Dogtag CA directly, instead of via the FreeIPA commands. If such a requirement emerges it might make sense to implement some “special handling” for issuing sub-CA certificates (similar to what we currently do for the KDC certificate). But the certificate request logic is already complicated; I am hesitant to complicate it even more.</p>
<p>Currently there is no sub-CA profile included in FreeIPA by default. It might make sense to include it, or at least to produce an official solution document describing the procedure outlined in this post.</p>]]></summary>
</entry>
<entry>
    <title>Replacing a lost or broken CA in FreeIPA</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2018-05-31-replacing-lost-ca.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2018-05-31-replacing-lost-ca.html</id>
    <published>2018-05-31T00:00:00Z</published>
    <updated>2018-05-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="replacing-a-lost-or-broken-ca-in-freeipa">Replacing a lost or broken CA in FreeIPA</h1>
<p><em>This is a</em> <strong><em>long post</em></strong><em>. If you just want some steps to follow feel free to <a href="#recovery-procedure-summarised">skip ahead</a>.</em></p>
<p>Every now and then we have a customer case or a question on the <code>freeipa-users</code> mailing list about replacing a lost CA. Usually the scenario goes something like this:</p>
<ul>
<li>FreeIPA was installed (with a CA)</li>
<li>Replicas were created, but without the CA role</li>
<li>The original CA master was decommissioned or failed</li>
</ul>
<p>A variation on this is the removal of the Dogtag instance on the only CA master in a deployment. This is less common, because it’s a deliberate act rather than an oversight. This action might be performed to clean up a partially-completed but failed execution of <code>ipa-ca-install</code>, leaving the deployment in an inconsistent state.</p>
<p>In either case, the deployment is left without a CA. There might be a backup of the original CA keys can can be used to restore a CA, or there might not.</p>
<p>In this post I will focus on the total loss of a CA. What is required to bring up a new CA in an existing IPA deployment, after the original CA is destroyed? I’m going to break a test installation as described above, then work out how to fix it. The goal is to produce a recovery procedure for administrators in this situation.</p>
<h2 id="prevention-is-better-than-cure">Prevention is better than cure</h2>
<p>Before I go ahead and delete the CA from a deployment, let’s talk about prevention. Losing your CA is a Big Deal. Therefore it’s essential not to leave your deployment with only one CA master. In earlier times, FreeIPA did not do anything to detect that there was only one CA master and make a fuss about it. This was poor UX that left many users and customers in a precarious situation, and ultimately to higher support costs for Red Hat.</p>
<p>Today we have some safeguards in place. In the topology Web UI we detect a single-CA topology and warn about it. <code>ipa-replica-install</code> alerts the administrator if there is only one CA in the topology and suggests to install the CA role on the new replica. <code>ipa-server-install --uninstall</code> warns when you are uninstalling the last instance of a some server role; this check includes the CA role. Eventually, FreeIPA will have some health check tools that will check for many kinds of problems, including this one.</p>
<h2 id="assumptions-and-starting-environment">Assumptions and starting environment</h2>
<p>I’ve made some assumptions that reduce the number of steps or remove potential pitfalls:</p>
<ul>
<li>The Subject DN of the replacement CA will be different from the original CA. The key will be different, so this will avoid problems with programs that can’t handle a <em>same subject, different key</em> scenario. It also avoids the need to force the new CA to start issuing certificates from some serial number higher than any that were previously issued.</li>
<li>We’ll use self-signed CAs. I can’t think of any problems that would arise doing this with an externally-signed CA. But there will be fewer steps and it will keep the post focused. The recovery procedure will not be substantially different for externally-signed CAs.</li>
</ul>
<p>For the environment, I’m using builds of the FreeIPA <code>master</code> branch, somewhere around the <code>v4.7</code> pre-release. Master and replica machines are both running Fedora 28.</p>
<p>There are two servers in the topology. <code>f28-1.ipa.local</code> was the original server and is the only server with the CA role. The replica <code>f28-0.ipa.local</code> was created from <code>f28-1</code>, without a CA. The CA subject DN is <code>CN=Certificate Authority,O=IPA.LOCAL 201805171453</code>. The Kerberos realm name is <code>IPA.LOCAL</code>.</p>
<h2 id="success-criteria">Success criteria</h2>
<p>How do we know when the deployment is repaired? I will use the following success criteria:</p>
<ol>
<li>The CA role is installed on a server (in our case, <code>f28-0</code>). That server is configured as the CA renewal master.</li>
<li>The new CA certificate is present in the LDAP trust store.</li>
<li>The old certificate remains in the LDAP trust store, so that certificates issued by the old CA are still trusted.</li>
<li>Certificates can be issued via <code>ipa cert-request</code>.</li>
<li>Existing HTTP and LDAP certificates, issued by the old CA, can be successfully renewed by Certmonger using the new CA.</li>
<li>A CA replica can be created.</li>
</ol>
<h2 id="deleting-the-ca">Deleting the CA</h2>
<p>Now I will remove <code>f28-1</code> from the topology. Recent versions of FreeIPA are aware of which roles (e.g. CA, DNS, etc) are installed on which servers. In this case, the program correctly detects that this server contains the only CA instance, and aborts:</p>
<pre><code># ipa-server-install --uninstall

This is a NON REVERSIBLE operation and will delete all data and configuration!
It is highly recommended to take a backup of existing data and configuration
  using ipa-backup utility before proceeding.

Are you sure you want to continue with the uninstall procedure? [no]: y
ipapython.admintool: ERROR    Server removal aborted:
  Deleting this server is not allowed as it would leave your
  installation without a CA.
ipapython.admintool: ERROR    The ipa-server-install command failed.
  See /var/log/ipaserver-uninstall.log for more information</code></pre>
<p>The <code>--ignore-last-of-role</code> option suppresses this check. When we add that option, the deletion of the server succeeds:</p>
<pre><code># ipa-server-install --uninstall --ignore-last-of-role

This is a NON REVERSIBLE operation and will delete all data and configuration!
It is highly recommended to take a backup of existing data and configuration
  using ipa-backup utility before proceeding.

Are you sure you want to continue with the uninstall procedure? [no]: y
------------------------------------
Deleted IPA server &quot;f28-1.ipa.local&quot;
------------------------------------
Shutting down all IPA services
Configuring certmonger to stop tracking system certificates for KRA
Configuring certmonger to stop tracking system certificates for CA
Unconfiguring CA
Unconfiguring web server
Unconfiguring krb5kdc
Unconfiguring kadmin
Unconfiguring directory server
Unconfiguring ipa-custodia
Unconfiguring ipa-otpd
Removing IPA client configuration
Removing Kerberos service principals from /etc/krb5.keytab
Disabling client Kerberos and LDAP configurations
Redundant SSSD configuration file /etc/sssd/sssd.conf was moved to /etc/sssd/sssd.conf.deleted
Restoring client configuration files
Unconfiguring the NIS domain.
nscd daemon is not installed, skip configuration
nslcd daemon is not installed, skip configuration
Systemwide CA database updated.
Client uninstall complete.
The ipa-client-install command was successful</code></pre>
<p>Switching back to <code>f28-0</code> (the CA-less replica), we can see that the <code>f28-1</code> is gone for good, and there is no server with the <code>CA server</code> role installed:</p>
<pre><code>% ipa server-find
--------------------
1 IPA server matched
--------------------
  Server name: f28-0.ipa.local
  Min domain level: 0
  Max domain level: 1
----------------------------
Number of entries returned 1
----------------------------

% ipa server-role-find --role &quot;CA server&quot;
---------------------
1 server role matched
---------------------
  Server name: f28-0.ipa.local
  Role name: CA server
  Role status: absent
----------------------------
Number of entries returned 1
----------------------------</code></pre>
<p>And because of this, we cannot issue certificates:</p>
<pre><code>% ipa cert-request --principal alice alice.csr
ipa: ERROR: CA is not configured</code></pre>
<p>OK, time to fix the deployment!</p>
<h2 id="fixing-the-deployment">Fixing the deployment</h2>
<p>The first thing we’ll try is just running <code>ipa-ca-install</code>. This command installs the CA role on an existing server. I expect it to fail, but it might hint at some of the repairs that need to be performed.</p>
<pre><code># ipa-ca-install --subject-base &quot;O=IPA.LOCAL NEW CA&quot;
Directory Manager (existing master) password: XXXXXXXX

Your system may be partly configured.
Run /usr/sbin/ipa-server-install --uninstall to clean up.

Certificate with nickname IPA.LOCAL IPA CA is present in
/etc/dirsrv/slapd-IPA-LOCAL/, cannot continue.</code></pre>
<p>We will not follow the advice about uninstalling the server. But the second message tell us something useful: we need to rename the CA certificate in <code>/etc/dirsrv/slapd-IPA-LOCAL</code>.</p>
<p>In fact, there are lots of places we need to rename the old CA certificate, including the LDAP certificate store. I’ll actually start there.</p>
<h3 id="ldap-certificate-store">LDAP certificate store</h3>
<p>FreeIPA has an LDAP-based store of trusted CA certificates used by clients and servers. The <code>ipa-certupdate</code> command reads certificates from this trust store and adds them to system trust stores and server certificate databases.</p>
<p>CA certificates are stored under <code>cn=certificates,cn=ipa,cn=etc,{basedn}</code>. The <code>cn</code> of each certificate entry is based on the Subject DN. The FreeIPA CA is the one exception: its <code>cn</code> is always <code>{REALM} IPA CA</code>. What are the current contents of the LDAP trust store?</p>
<pre><code>% ldapsearch -LLL -D &quot;cn=Directory Manager&quot; -wXXXXXXXX \
    -b &quot;cn=certificates,cn=ipa,cn=etc,dc=ipa,dc=local&quot; \
    -s one ipaCertIssuerSerial cn
dn: cn=IPA.LOCAL IPA CA,cn=certificates,cn=ipa,cn=etc,dc=ipa,dc=local
ipaCertIssuerSerial: CN=Certificate Authority,O=IPA.LOCAL 201805171453;1
cn: IPA.LOCAL IPA CA</code></pre>
<p>We see only the FreeIPA CA certificate, as expected. We must move this entry aside. We do still want to keep it in the trust stores so certificates that were issued by this CA will still be trusted. I used the <code>ldapmodrdn</code> command to rename this entry, with the new <code>cn</code> based on the Subject DN of the old CA.</p>
<pre><code>% ldapmodrdn -D &quot;cn=Directory Manager&quot; -wXXXXXXXX -r \
    &quot;cn=IPA.LOCAL IPA CA,cn=certificates,cn=ipa,cn=etc,dc=ipa,dc=local&quot; \
    &quot;cn=CN\=Certificate Authority\,O\=IPA.LOCAL 201805171453&quot;

% ldapsearch -LLL -D &quot;cn=Directory Manager&quot; -wXXXXXXXX \
    -b &quot;cn=certificates,cn=ipa,cn=etc,dc=ipa,dc=local&quot; \
    -s one ipaCertIssuerSerial cn
dn: cn=CN\3DCertificate Authority\2CO\3DIPA.LOCAL 201805171453,cn=certificates,cn=
 ipa,cn=etc,dc=ipa,dc=local
ipaCertIssuerSerial: CN=Certificate Authority,O=IPA.LOCAL 201805171453;1
cn: CN=Certificate Authority,O=IPA.LOCAL 201805171453</code></pre>
<p>For the <code>ldapmodrdn</code> command, note the escaping of the <code>=</code> and <code>,</code> characters in the DN. This is important.</p>
<h3 id="removing-ca-entries">Removing CA entries</h3>
<p>There are a bunch of CA entries in the FreeIPA directory. The <code>cn=ipa</code> is the main IPA CA. In additional, there can be zero or more <em>lightweight sub-CAs</em> in a FreeIPA deployment.</p>
<pre><code># ipa ca-find
-------------
2 CAs matched
-------------
  Name: ipa
  Description: IPA CA
  Authority ID: a0e7a855-aac2-40fc-8e86-cf1a7429f28c
  Subject DN: CN=Certificate Authority,O=IPA.LOCAL 201805171453
  Issuer DN: CN=Certificate Authority,O=IPA.LOCAL 201805171453

  Name: test1
  Authority ID: ac7e6def-acd8-4d19-ab3e-60067c17ba81
  Subject DN: CN=test1
  Issuer DN: CN=Certificate Authority,O=IPA.LOCAL 201805171453
----------------------------
Number of entries returned 2
----------------------------</code></pre>
<p>These entries will all need to be removed:</p>
<pre><code># ipa ca-find --pkey-only --all \
    | grep dn: \
    | awk &#39;{print $2}&#39; \
    | xargs ldapdelete -D &quot;cn=Directory Manager&quot; -wXXXXXXXX

# ipa ca-find
-------------
0 CAs matched
-------------
----------------------------
Number of entries returned 0
----------------------------</code></pre>
<h3 id="ds-nssdb">DS NSSDB</h3>
<p><code>ipa-ca-install</code> complained about the presense of a certificate with nickname <code>IPA.LOCAL IPA CA</code> in the <code>/etc/dirsrv/slapd-IPA-LOCAL</code> NSS certificate database (NSSDB). What are the current contents of this NSSDB?</p>
<pre><code># certutil -d /etc/dirsrv/slapd-IPA-LOCAL -L

Certificate Nickname                 Trust Attributes
                                     SSL,S/MIME,JAR/XPI

IPA.LOCAL IPA CA                     CT,C,C
Server-Cert                          u,u,u</code></pre>
<p>There are two certificates: the old CA certificate and the server certificate.</p>
<p>With the CA certificate having been renamed in the LDAP trust store, I’ll now run <code>ipa-certupdate</code> and see what happens in the NSSDB.</p>
<pre><code># ipa-certupdate
trying https://f28-0.ipa.local/ipa/session/json
[try 1]: Forwarding &#39;ca_is_enabled/1&#39; to json server
&#39;https://f28-0.ipa.local/ipa/session/json&#39;
Systemwide CA database updated.
Systemwide CA database updated.
The ipa-certupdate command was successful</code></pre>
<p>Nothing failed! That is encouraging. But <code>certutil</code> still shows the same output as above. So we must find another way to change the nickname in the NSSDB. Lucky for us, <code>certutil</code> has a <code>rename</code> option:</p>
<pre><code># certutil --rename --help
--rename        Change the database nickname of a certificate
   -n cert-name      The old nickname of the cert to rename
   --new-n new-name  The new nickname of the cert to rename
   -d certdir        Cert database directory (default is ~/.netscape)
   -P dbprefix       Cert &amp; Key database prefix

# certutil -d /etc/dirsrv/slapd-IPA-LOCAL --rename \
    -n &#39;IPA.LOCAL IPA CA&#39; --new-n &#39;OLD IPA CA&#39;

# certutil -d /etc/dirsrv/slapd-IPA-LOCAL -L

Certificate Nickname                 Trust Attributes
                                     SSL,S/MIME,JAR/XPI

OLD IPA CA                           CT,C,C
Server-Cert                          u,u,u</code></pre>
<p>I also performed this rename in <code>/etc/ipa/nssdb</code>. On Fedora 28, Apache uses OpenSSL instead of NSS. But on older versions there is also an Apache NSSDB at <code>/etc/httpd/alias</code>; the rename will need to be performed there, too.</p>
<h3 id="ipa-ca-install-attempt-2"><code>ipa-ca-install</code>, attempt 2</h3>
<p>Now that the certificates have been renamed in the LDAP trust store and NSSDBs, let’s try <code>ipa-ca-install</code> again:</p>
<pre><code># ipa-ca-install --ca-subject &#39;CN=IPA.LOCAL NEW CA&#39;
Directory Manager (existing master) password: XXXXXXXX

The CA will be configured with:
Subject DN:   CN=IPA.LOCAL NEW CA
Subject base: O=IPA.LOCAL
Chaining:     self-signed

Continue to configure the CA with these values? [no]: y
Configuring certificate server (pki-tomcatd). Estimated time: 3 minutes
  [1/28]: configuring certificate server instance
  [2/28]: exporting Dogtag certificate store pin
  [3/28]: stopping certificate server instance to update CS.cfg
  [4/28]: backing up CS.cfg
  [5/28]: disabling nonces
  [6/28]: set up CRL publishing
  [7/28]: enable PKIX certificate path discovery and validation
  [8/28]: starting certificate server instance
  [9/28]: configure certmonger for renewals
  [10/28]: requesting RA certificate from CA
  [error] DBusException: org.fedorahosted.certmonger.duplicate:
          Certificate at same location is already used by request
          with nickname &quot;20180530050017&quot;.</code></pre>
<p>Well, we have made progress. Installation got a fair way along, but failed because there was already a Certmonger tracking request for the IPA RA certificate.</p>
<h3 id="certmonger-tracking-requests">Certmonger tracking requests</h3>
<p>We have to clean up the Certmonger tracking request for the <code>IPA RA</code> certificate. The <code>ipa-ca-install</code> failure helpfully told us the ID of the problematic request. But if we wanted to nail it on the first try we’d have to look it up. We can ask Certmonger to show the tracking request for the certificate file at <code>/var/lib/ipa/ra-agent.pem</code>, where the <code>IPA RA</code> certificate is stored:</p>
<pre><code># getcert list -f /var/lib/ipa/ra-agent.pem
Number of certificates and requests being tracked: 4.
Request ID &#39;20180530050017&#39;:
        status: MONITORING
        stuck: no
        key pair storage: type=FILE,location=&#39;/var/lib/ipa/ra-agent.key&#39;
        certificate: type=FILE,location=&#39;/var/lib/ipa/ra-agent.pem&#39;
        CA: dogtag-ipa-ca-renew-agent
        issuer: CN=Certificate Authority,O=IPA.LOCAL 201805171453
        subject: CN=IPA RA,O=IPA.LOCAL 201805171453
        expires: 2020-05-06 14:55:30 AEST
        key usage: digitalSignature,keyEncipherment,dataEncipherment
        eku: id-kp-serverAuth,id-kp-clientAuth
        pre-save command: /usr/libexec/ipa/certmonger/renew_ra_cert_pre
        post-save command: /usr/libexec/ipa/certmonger/renew_ra_cert
        track: yes
        auto-renew: yes</code></pre>
<p>Then we can stop tracking it:</p>
<pre><code># getcert stop-tracking -i 20180530050017
Request &quot;20180530050017&quot; removed.</code></pre>
<p>Now, before we can run <code>ipa-ca-install</code> again, we have an unwanted <code>pki-tomcat</code> instance sitting around. We need to explicitly remove it using <code>pkidestroy</code>:</p>
<pre><code># pkidestroy -s CA -i pki-tomcat
Log file: /var/log/pki/pki-ca-destroy.20180530165156.log
Loading deployment configuration from /var/lib/pki/pki-tomcat/ca/registry/ca/deployment.cfg.
Uninstalling CA from /var/lib/pki/pki-tomcat.
pkidestroy  : WARNING  ....... this &#39;CA&#39; entry will NOT be deleted from security domain &#39;IPA&#39;!
pkidestroy  : WARNING  ....... security domain &#39;IPA&#39; may be offline or unreachable!
pkidestroy  : ERROR    ....... subprocess.CalledProcessError:  Command &#39;[&#39;/usr/bin/sslget&#39;, &#39;-n&#39;, &#39;subsystemCert cert-pki-ca&#39;, &#39;-p&#39;, &#39;7Zc^NEd1%~@rGO%d{)%K:$S5L[^1F1K.!@5oWgZ]e&#39;, &#39;-d&#39;, &#39;/etc/pki/pki-tomcat/alias&#39;, &#39;-e&#39;, &#39;name=&quot;/var/lib/pki/pki-tomcat&quot;&amp;type=CA&amp;list=caList&amp;host=f28-0.ipa.local&amp;sport=443&amp;ncsport=443&amp;adminsport=443&amp;agentsport=443&amp;operation=remove&#39;, &#39;-v&#39;, &#39;-r&#39;, &#39;/ca/agent/ca/updateDomainXML&#39;, &#39;f28-0.ipa.local:443&#39;]&#39; returned non-zero exit status 3.!
pkidestroy  : WARNING  ....... Directory &#39;/etc/pki/pki-tomcat/alias&#39; is either missing or is NOT a directory!

Uninstallation complete.</code></pre>
<h3 id="ipa-ca-install-attempt-3"><code>ipa-ca-install</code>, attempt 3</h3>
<p>Here we go again!</p>
<pre><code># ipa-ca-install --ca-subject &#39;CN=IPA.LOCAL NEW CA&#39;
...
  [10/28]: requesting RA certificate from CA
  [11/28]: setting audit signing renewal to 2 years
  [12/28]: restarting certificate server
  [13/28]: publishing the CA certificate
  [14/28]: adding RA agent as a trusted user
  [15/28]: authorizing RA to modify profiles
  [16/28]: authorizing RA to manage lightweight CAs
  [17/28]: Ensure lightweight CAs container exists
  [18/28]: configure certificate renewals
  [19/28]: configure Server-Cert certificate renewal
  [20/28]: Configure HTTP to proxy connections
  [21/28]: restarting certificate server
  [22/28]: updating IPA configuration
  [23/28]: enabling CA instance
  [24/28]: migrating certificate profiles to LDAP
  [error] RemoteRetrieveError: Failed to authenticate to CA REST API

Your system may be partly configured.
Run /usr/sbin/ipa-server-install --uninstall to clean up.

Unexpected error - see /var/log/ipareplica-ca-install.log for details:
RemoteRetrieveError: Failed to authenticate to CA REST API</code></pre>
<p>Dang! This time the installation failed due to an authentication failure between the IPA framework and Dogtag. This authentication uses the IPA RA certificate. It turns out that Certmonger did not request a new RA certificate. Instead, it tracked the preexisting RA certificate issued by the old CA:</p>
<pre><code># openssl x509 -text &lt; /var/lib/ipa/ra-agent.pem |grep Issuer
      Issuer: O = IPA.LOCAL 201805171453, CN = Certificate Authority</code></pre>
<p>The IPA framework presents the old RA certificate when authenticating to the new CA. The new CA does not recognise it, so authentication fails. Therefore we need to remove the IPA RA certificate and key before installing a new CA:</p>
<pre><code># rm -fv /var/lib/ipa/ra-agent.*
removed &#39;/var/lib/ipa/ra-agent.key&#39;
removed &#39;/var/lib/ipa/ra-agent.pem&#39;</code></pre>
<p>Because installation got a fair way along before failing, we also need to:</p>
<ul>
<li><code>pkidestroy</code> the Dogtag instance (as before)</li>
<li>remove Certmonger tracking requests for the RA certificate (as before)</li>
<li>remove Certmonger tracking requests for Dogtag system certificates</li>
<li>run <code>ipa-certupdate</code> to remove the new CA certificate from trust stores</li>
</ul>
<p>Also, the deployment now believes that the CA role has been installed on <code>f28-0</code>:</p>
<pre><code># ipa server-role-find --role &#39;CA server&#39;
---------------------
1 server role matched
---------------------
  Server name: f28-0.ipa.local
  Role name: CA server
  Role status: enabled
----------------------------
Number of entries returned 1
----------------------------</code></pre>
<p>Note <code>Role status: enabled</code> above. We need to remove this record that the CA role is installed on <code>f28-0</code>. Like so:</p>
<pre><code># ldapdelete -D &quot;cn=Directory Manager&quot; -wXXXXXXXX \
    cn=CA,cn=f28-0.ipa.local,cn=masters,cn=ipa,cn=etc,dc=ipa,dc=local

# ipa server-role-find --role &#39;CA server&#39;
---------------------
1 server role matched
---------------------
  Server name: f28-0.ipa.local
  Role name: CA server
  Role status: absent
----------------------------
Number of entries returned 1
----------------------------</code></pre>
<p>Having performed these cleanup tasks, we will try again to install the CA.</p>
<h3 id="ipa-ca-install-attempt-4"><code>ipa-ca-install</code>, attempt 4</h3>
<pre><code># ipa-ca-install --ca-subject &#39;CN=IPA.LOCAL NEW CA&#39;
...
  [24/28]: migrating certificate profiles to LDAP
  [25/28]: importing IPA certificate profiles
  [26/28]: adding default CA ACL
  [27/28]: adding &#39;ipa&#39; CA entry
  [28/28]: configuring certmonger renewal for lightweight CAs
Done configuring certificate server (pki-tomcatd).</code></pre>
<p>Hooray! We made it.</p>
<h2 id="results">Results</h2>
<p>Let’s revisit each of the success criteria and see whether the goal has been achieved.</p>
<h3 id="ca-role-installed-and-configured-as-renewal-master">1. CA role installed and configured as renewal master</h3>
<pre><code># ipa server-role-find --role &#39;CA server&#39;
---------------------
1 server role matched
---------------------
  Server name: f28-0.ipa.local
  Role name: CA server
  Role status: enabled
----------------------------
Number of entries returned 1
----------------------------

# ipa config-show |grep CA
  Certificate Subject base: O=IPA.LOCAL
  IPA CA servers: f28-0.ipa.local
  IPA CA renewal master: f28-0.ipa.local</code></pre>
<p>Looks like this criterion has been met.</p>
<h3 id="ldap-trust-store">2 &amp; 3. LDAP trust store</h3>
<pre><code># ldapsearch -LLL -D cn=&quot;Directory manager&quot; -wXXXXXXXX \
    -b &quot;cn=certificates,cn=ipa,cn=etc,dc=ipa,dc=local&quot; \
    -s one ipaCertIssuerSerial cn
dn: cn=CN\3DCertificate Authority\2CO\3DIPA.LOCAL 201805171453,cn=certificates
 ,cn=ipa,cn=etc,dc=ipa,dc=local
ipaCertIssuerSerial: CN=Certificate Authority,O=IPA.LOCAL 201805171453;1
cn: CN=Certificate Authority,O=IPA.LOCAL 201805171453

dn: cn=IPA.LOCAL IPA CA,cn=certificates,cn=ipa,cn=etc,dc=ipa,dc=local
ipaCertIssuerSerial: CN=IPA.LOCAL NEW CA;1
cn: IPA.LOCAL IPA CA</code></pre>
<p>The old and new CA certificates are present in the LDAP trust store. The new CA certificate has the appropriate <code>cn</code> value. These criteria have been met.</p>
<h3 id="ca-can-issue-certificates">4. CA can issue certificates</h3>
<pre><code># ipa cert-request --principal alice alice.csr
  Issuing CA: ipa
  Certificate: MIIC0zCCAbugAwIBAgIBCDAN...
  Subject: CN=alice,OU=pki-ipa,O=IPA
  Issuer: CN=IPA.LOCAL NEW CA
  Not Before: Thu May 31 05:14:42 2018 UTC
  Not After: Sun May 31 05:14:42 2020 UTC
  Serial number: 8
  Serial number (hex): 0x8</code></pre>
<p>The certificate was issued by the new CA. Success.</p>
<h3 id="can-renew-http-and-ldap-certificates">5. Can renew HTTP and LDAP certificates</h3>
<p>Because we are still trusting the old CA, there is no immediate need to renew the HTTP and LDAP certificate. But they will eventually expire, so we need to ensure that renewal works. <code>getcert resubmit</code> is used to initiate a renewal:</p>
<pre><code># getcert resubmit -i 20180530045952
Resubmitting &quot;20180530045952&quot; to &quot;IPA&quot;.

# sleep 10

# getcert list -i 20180530045952
Number of certificates and requests being tracked: 9.
Request ID &#39;20180530045952&#39;:
        status: MONITORING
        stuck: no
        key pair storage: type=FILE,location=&#39;/var/lib/ipa/private/httpd.key&#39;,pinfile=&#39;/var/lib/ipa/passwds/f28-0.ipa.local-443-RSA&#39;
        certificate: type=FILE,location=&#39;/var/lib/ipa/certs/httpd.crt&#39;
        CA: IPA
        issuer: CN=IPA.LOCAL NEW CA
        subject: CN=f28-0.ipa.local,OU=pki-ipa,O=IPA
        expires: 2020-05-31 15:24:05 AEST
        key usage: digitalSignature,nonRepudiation,keyEncipherment,dataEncipherment
        eku: id-kp-serverAuth,id-kp-clientAuth
        pre-save command: 
        post-save command: /usr/libexec/ipa/certmonger/restart_httpd
        track: yes
        auto-renew: yes</code></pre>
<p>The renewal succeeded. Using <code>openssl s_client</code> we can see that the HTTP server is now presenting a certificate chain ending with the new CA certificate:</p>
<pre><code># echo | openssl s_client -showcerts \
    -connect f28-0.ipa.local:443 -servername f28-0.ipa.local \
    | grep s:
depth=1 CN = IPA.LOCAL NEW CA
verify return:1
depth=0 O = IPA, OU = pki-ipa, CN = f28-0.ipa.local
verify return:1
 0 s:/O=IPA/OU=pki-ipa/CN=f28-0.ipa.local
 1 s:/CN=IPA.LOCAL NEW CA</code></pre>
<p>So we are looking good against this criterion too.</p>
<h3 id="a-ca-replica-can-be-created">6. A CA replica can be created</h3>
<p><code>f28-1</code> was removed from the deployment at the beginning. To test CA replica installation, I enrolled it again using <code>ipa-client-install</code>, then executed <code>ipa-replica-install --setup-ca</code>. Installation completed successfully:</p>
<pre><code># ipa-replica-install --setup-ca
Password for admin@IPA.LOCAL:
Run connection check to master
Connection check OK
Configuring directory server (dirsrv). Estimated time: 30 seconds
  [1/41]: creating directory server instance
  ...
  [26/26]: configuring certmonger renewal for lightweight CAs
Done configuring certificate server (pki-tomcatd).
Configuring Kerberos KDC (krb5kdc)
  [1/1]: installing X509 Certificate for PKINIT
Full PKINIT configuration did not succeed
The setup will only install bits essential to the server functionality
You can enable PKINIT after the setup completed using &#39;ipa-pkinit-manage&#39;
Done configuring Kerberos KDC (krb5kdc).
Applying LDAP updates
Upgrading IPA:. Estimated time: 1 minute 30 seconds
  [1/9]: stopping directory server
  [2/9]: saving configuration
  [3/9]: disabling listeners
  [4/9]: enabling DS global lock
  [5/9]: starting directory server
  [6/9]: upgrading server
  [7/9]: stopping directory server
  [8/9]: restoring configuration
  [9/9]: starting directory server
Done.
Restarting the KDC</code></pre>
<p>We have a clean sweep of the success criteria. <strong>Mission accomplished.</strong></p>
<h2 id="recovery-procedure-summarised">Recovery procedure, summarised</h2>
<p>Distilling the trial-and-error exploration above down to the essential steps, we end up with the following procedure. Not every step is necessary in every case, and most steps do not necessarily have to be performed in the order shown here.</p>
<ol>
<li><p>Delete CA entries:</p>
<pre><code># ipa ca-find --pkey-only --all \
    | grep dn: \
    | awk &#39;{print $2}&#39; \
    | xargs ldapdelete -D &quot;cn=Directory Manager&quot; -wXXXXXXXX</code></pre></li>
<li><p>Destroy the existing Dogtag instance, if present:</p>
<pre><code># pkidestroy -s CA -i pki-tomcat</code></pre></li>
<li><p>Delete the CA server role entry for the current host, if present. For example:</p>
<pre><code># ldapdelete -D &quot;cn=Directory Manager&quot; -wXXXXXXXX
    cn=CA,cn=f28-0.ipa.local,cn=masters,cn=ipa,cn=etc,dc=ipa,dc=local</code></pre></li>
<li><p>Move aside the old IPA CA certificate in the LDAP certificate store. By convention, the new RDN should be based on the subject DN. For example:</p>
<pre><code>% ldapmodrdn -D &quot;cn=Directory Manager&quot; -wXXXXXXXX -r \
    &quot;cn=IPA.LOCAL IPA CA,cn=certificates,cn=ipa,cn=etc,dc=ipa,dc=local&quot; \
    &quot;cn=CN\=Certificate Authority\,O\=IPA.LOCAL 201805171453&quot;</code></pre></li>
<li><p>Rename the IPA CA certificate nickname in the NSSDBs at <code>/etc/dirsrv/slapd-{REALM}</code>, <code>/etc/ipa/nssdb</code> and, if relevant, <code>/etc/httpd/alias</code>. Example command:</p>
<pre><code># certutil -d /etc/dirsrv/slapd-IPA-LOCAL --rename \
    -n &#39;IPA.LOCAL IPA CA&#39; --new-n &#39;OLD IPA CA&#39;</code></pre></li>
<li><p>Remove Certmonger tracking requests for all Dogtag system certificates, and remove the tracking request for the IPA RA certificate:</p>
<pre><code># for ID in ... ; \
    do certmonger stop-tracking -i $ID ; \
    done</code></pre></li>
<li><p>Delete the IPA RA certificate and key:</p>
<pre><code># rm -fv /var/lib/ipa/ra-agent.*
removed &#39;/var/lib/ipa/ra-agent.key&#39;
removed &#39;/var/lib/ipa/ra-agent.pem&#39;</code></pre></li>
<li>Run <code>ipa-certupdate</code>.</li>
<li>Run <code>ipa-ca-install</code>.</li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>The procedure developed in this post should cover most cases of CA installation failure or loss of the only CA master in a deployment. Inevitably the differences between versions of FreeIPA mean that the procedure may vary, depending on which version(s) you are using.</p>
<p>In this procedure, the new CA is installed with a different Subject DN. Conceptually, this is not essential. But reusing the same subject DN could cause problems for some programs. I <a href="2017-11-20-changing-ca-subject-dn-part-i.html">wrote about this in an earlier post</a>. Furthermore, to keep the CA subject DN the same would involve extra steps to ensure that serial numbers were not re-used. I am not interested in investigating how to pull this off. Just choose a new DN!</p>
<p>One feature request we sometimes receive is a CA uninstaller. The steps outlined in this post would suffice to uninstall a CA and erase knowledge of it from a deployment (apart from the CA certificate itself, which you would probably want to keep).</p>
<p>Looking ahead, I (or maybe someone else) could gather the cleanup steps into an easy to use script. Administrators or support personnel who have run into problems can execute the script to quickly restore their server to a state where the CA can (hopefully) successfully be installed.</p>]]></summary>
</entry>
<entry>
    <title>Certificate renewal and revocation in FreeIPA</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2018-05-11-renewal-and-revocation.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2018-05-11-renewal-and-revocation.html</id>
    <published>2018-05-11T00:00:00Z</published>
    <updated>2018-05-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="certificate-renewal-and-revocation-in-freeipa">Certificate renewal and revocation in FreeIPA</h1>
<p>A <a href="https://pagure.io/freeipa/issue/7482">recent FreeIPA ticket</a> has prompted a discussion about what revocation behaviour should occur upon certificate renewal. The ticket reported a regression: when renewing a certificate, <code>ipa cert-request</code> was no longer revoking the old certificate. But is revoking the certificate the correct behaviour in the first place?</p>
<p>This post discusses the motivations and benefits of automatically revoking a principal’s certificates when a new certificate is issued. It is assumed that subjects of certificates are FreeIPA principals. Conclusions do not necessarily apply to other environments or use cases.</p>
<h2 id="description-of-current-behaviour">Description of current behaviour</h2>
<p>Notwithstanding the purported regression mentioned above, the current behaviour of FreeIPA is:</p>
<ul>
<li>for host and service principals: when a new certificate is issued, revoke previous certificate(s)</li>
<li>for user principals: <em>never</em> automatically revoke certificates</li>
</ul>
<p>The revocation behaviour that occurs during <code>ipa cert-request</code> is actually defined in <code>ipa {host,service}-mod</code>. That is, when a <code>userCertificate</code> attribute value is removed, the removed certificates get revoked.</p>
<h2 id="one-certificate-per-service-a-bad-assumption">One certificate per service: a bad assumption?</h2>
<p>The automatic revocation regime makes a big assumption. Host or service principals are assumed to need only one certificate. This is usually the case. But it is not inconceivable that a service may need multiple certificates for different purposes. The current (intended) behaviour prevents a service from possessing multiple valid (non-revoked) certificates concurrently.</p>
<h2 id="certificate-issuance-scenarios">Certificate issuance scenarios</h2>
<p>Let us abandon the assumption that a host or service only needs one certificate at a time. There are three basic scenarios where <code>cert-request</code> would be revoked to issue a certificate to a particular principal. In each scenario, there are different motivations and consequences related to revocation. We will discuss each scenario in turn.</p>
<h3 id="certificate-for-new-purpose-non-renewal">Certificate for new purpose (non-renewal)</h3>
<p>A certificate is being requested for some new purpose. The subject may already have certs issued to it for other purposes. Existing certificates <em>should not be revoked</em>. FreeIPA’s revocation behaviour excludes this use case for host and service certificates.</p>
<h3 id="renewal-due-to-impending-expiry">Renewal due to impending expiry</h3>
<p>A certificate may be requested to renew an existing certificate. After the new certificate is issued, it does no harm to revoke the old certificate. But it is <em>not necessary to revoke</em> it; it will expire soon.</p>
<h3 id="renewal-for-other-reasons">Renewal for other reasons</h3>
<p>A certificate could be renewed in advance of its expiration time for any reasons (e.g. re-key due to compromise, add a Subject Alternative Name, etc.) Conservatively, we’ll lump all the possible reasons together and say that it is <em>necessary to revoke</em> the certificate that is being replaced.</p>
<p>What if the subject possesses multiple certificates for different purposes? Right now, for host and service principals we revoke them all.</p>
<h2 id="proposed-changes">Proposed changes</h2>
<p>A common theme is emerging. When we request a certificate, we want to revoke <em>at most one</em> certificate, i.e. the certificate being renewed (if any). This suggestion is applicable to service/host certificates as well as user certificates. It would admit the <em>multiple certificates for different purposes</em> use case for all principal types.</p>
<p>How do we get there from where we are now?</p>
<p>Observe that the <code>ipa cert-request</code> currently does not know (a) whether the request is a renewal or (b) what certificate is being renewed. Could we make <code>cert-request</code> smart enough to guess what it should do? Fuzzy heuristics that could be employed to make a guess, e.g. by examining certificate attributes, validity period, the subject public key, the profile and CA that were used, and so on. The guessing logic would be complex, and could not guarantee a correct answer. It is not the right approach.</p>
<p>Perhaps we could remove all revocation behaviour from <code>ipa cert-request</code>. This would actually be a matter of <em>suppressing</em> the revocation behaviour of <code>ipa {host,service}-mod</code>. Revocation has always been available via the <code>ipa cert-revoke</code> command. This approach makes revocation a separate, explicit step.</p>
<p>Note that renewals via <em>Certmonger</em> could perform revocation via <code>ipa cert-revoke</code> in the renewal helper. If you had to re-key or reissue a certificate via <code>getcert resubmit</code>, it could revoke the old certificate automatically. The nice thing here is that there is no guesswork involved. Certmonger <em>knows what cert it is tracking</em> so it can nominate the certificate to revoke and leave the subject’s other certificates alone.</p>
<p>A nice middle ground might be to add a new option to <code>ipa cert-request</code> to specify the certificate that is being renewed/replaced, so that <code>cert-request</code> can revoke just that certificate, and remove it from the subject principal’s LDAP entry. The command might look something like:</p>
<pre><code>% ipa cert-request /path/to/req.csr \
    --principal HTTP/www.example.com \
    --replace &quot;CN=Certificate Authority,O=EXAMPLE.COM;42&quot;</code></pre>
<p>The <code>replace</code> option specifies the issuer and serial number of the certificate being replaced. After the new certificate is issued, <code>ipa cert-request</code> would attempt to revoke the specified certificate, and remove it from the principal’s <code>userCertificate</code> attribute. Certmonger would be able to supply the <code>replace</code> option (or whatever we call it).</p>
<p>For any of the above suggestions it would be necessary to prominently and clearly outline the changes in release notes. The change in revocation behaviour could catch users off guard. It is important not to rush any changes through. We’ll need to engage with our user base to explain the changes, and outline steps to preserve the existing revocation behaviour if so desired.</p>
<h3 id="ipa-hostservice-mod-changes"><code>ipa {host,service}-mod</code> changes</h3>
<p>Another (independent) enhancement to consider is an option to suppress the revocation behaviour of <code>ipa {host,service}-mod</code>, so that certificates could be removed from host/service entries without revoking them. A simple <code>--no-revoke</code> flag would suffice.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post I discussed how the current revocation behaviour of FreeIPA prevents hosts and services from using multiple certificates for different purposes. This is not the majority use case but I feel that we should support the use case. And we can, with a refinement of <code>ipa cert-request</code> behaviour.</p>
<p>We ought to make it possible to revoke <em>only the certificate being renewed</em>. We can do this by preventing <code>ipa cert-request</code> from revoking certs and requiring a separate call to <code>ipa cert-revoke</code>. behaviour of <code>cert-request</code> Alternatively, we can add an option to <code>ipa cert-request</code> for explicitly specifying the certificate(s) to revoke. In either case, the Certmonger renewal helpers can be changed to ensure that renewals via Certmonger revoke the old certificate (while leaving the subject’s other certificates alone!)</p>
<p>What do you think of the changes I’ve suggested? You can contribute to the <a href="https://lists.fedoraproject.org/archives/list/freeipa-devel@lists.fedorahosted.org/thread/G2BXRJNU5ATVXRNUPGE2Y4V3YJVXR7EC/">discussion on the <em>freeipa-devel</em> mailing list</a>.</p>]]></summary>
</entry>
<entry>
    <title>Can we teach an old Dogtag new tricks?</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2018-03-26-old-dogtag-new-tricks.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2018-03-26-old-dogtag-new-tricks.html</id>
    <published>2018-03-26T00:00:00Z</published>
    <updated>2018-03-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="can-we-teach-an-old-dogtag-new-tricks">Can we teach an old Dogtag new tricks?</h1>
<p>Dogtag is a very old program. It started at <em>Netscape</em>. It is old enough to vote. Most of it was written in the early days of Java, long before generics or first-class functions. A lot of it has hardly been touched since it was first written.</p>
<p>Old code often follows old practices that are no longer reasonable. This is not an indictment on the original programmers! The capabilities of our tools usually improve over time (certainly true for Java). The way we solve problems often improves over time too, through better libraries and APIs. And back in the ’90s sites like Stack Overflow didn’t exist and there wasn’t as much free software to learn from. Also, observe that Dogtag is still here, 20 years on, used by customers and being actively developed. This is a <em>huge credit</em> to the original developers and everyone who worked on Dogtag in the meantime.</p>
<p>But we cannot deny that today we have a lot of very old Java code that follows outdated practices and is difficult to reason about and maintain. And maintain it we must. Bugs must be fixed, and new features will be developed. Can Dogtag’s code be modernised? <em>Should it</em> be modernised?</p>
<h2 id="costs-of-change-costs-of-avoiding-change">Costs of change, costs of avoiding change</h2>
<p>One option is to accept and embrace the status quo. Touch the old code as little as possible. Make essential fixes only. Do not refactor classes or interfaces. When writing new code, use the existing interfaces, even if they allow (or demand) unsafe use.</p>
<p>There is something to be said for this approach. Dogtag has bugs, but it is “battle hardened”. It is used by large organisations in security-critical infrastructure. Changing things introduces a risk of breaking things. The bigger the change, the bigger the risk. And Dogtag users are some of the biggest, most security-conscious and risk-conscious organisations out there.</p>
<p>On the other hand, persisting with the old code has some drawbacks too. First, there are certainly undiscovered bugs. Avoiding change except when there is a known defect means those bugs will stay hidden—until they manifest themselves in an unpleasant way! Second, old interfaces that require, for example, unsafe mutation of objects, can lead to new bugs when we do fix bugs or implement new features. Finally, existing code that is difficult to reason about, and interfaces that are difficult to use, slow down fixes and new development.</p>
<h2 id="case-study-acls">Case study: ACLs</h2>
<p>Dogtag uses <em>access control lists (ACLs)</em> to govern what users can do in the system. The text representation of an ACL (with wrapping and indication for presentation only) looks like:</p>
<pre><code>certServer.ca.authorities
  :create,modify
  :allow (list,read) user=&quot;anybody&quot;
    ;allow (create,modify,delete) group=&quot;Administrators&quot;
  :Administrators may create and modify lightweight authorities</code></pre>
<p>The fields are:</p>
<ol style="list-style-type: decimal">
<li>Name of the ACL</li>
<li>List of permissions covered by the ACLs</li>
<li>List of ACL entries. Each entry either grants or denies the listed permissions to users matching an expression</li>
<li>Comment</li>
</ol>
<p>The above ACL grants lightweight CA read permission to all users, while only members of the <code>Administrators</code> group can create, modify or delete them. A typical Dogtag CA subsystem might have around 60 such ACLs. The <em>authorisation subsystem</em> is responsible for loading and enforcing ACLs.</p>
<p>I have touched the ACL machinery a few times in the last couple of years. Most of the changes were bug fixes but I also implemented a small enhancement for merging ACLs with the same name. These were tiny changes; most ACL code is unchanged from prehistoric (pre-Git repo) times. The implementation has several significant issues. Let’s look at a few aspects.</p>
<h3 id="broken-parsing">Broken parsing</h3>
<p>The <code>ACL.parseACL</code> method (<a href="https://github.com/dogtagpki/pki/blob/223e6980c3f3f7a075890897bbb74140cb95279a/base/common/src/com/netscape/certsrv/acls/ACL.java#L191-L289">source</a>) converts the textual representation of an ACL into an internal representation. It’s about 100 lines of Java. Internally it calls <code>ACLEntry.parseACLEntry</code> which is another 40 lines.</p>
<p>The implementation is ad-hoc and inflexible. Fields are found by scanning for delimiters, and their contents are handled in a variety of ways. For fields that can have multiple values, <code>StringTokenizer</code> is used, as in the following (simplified) example:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="bu">StringTokenizer</span> st = <span class="kw">new</span> <span class="bu">StringTokenizer</span>(entriesString, <span class="st">&quot;;&quot;</span>);
<span class="kw">while</span> (st.<span class="fu">hasMoreTokens</span>()) {
    <span class="bu">String</span> entryString = st.<span class="fu">nextToken</span>();
    ACLEntry entry = ACLEntry.<span class="fu">parseACLEntry</span>(acl, entryString);
    <span class="kw">if</span> (entry == <span class="kw">null</span>)
        <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">EACLsException</span>(<span class="st">&quot;failed to parse ACL entries&quot;</span>);
    entry.<span class="fu">setACLEntryString</span>(entryString);
    acl.<span class="fu">entries</span>.<span class="fu">add</span>(entry);
}</code></pre></div>
<p>So what happens if you have an ACL like the following? Note the semicolon in the group name.</p>
<pre><code>certificate:issue:allow (read) group=&quot;sysadmin;pki&quot;
  :PKI sysadmins can read certificates</code></pre>
<p>The current parser will either fail, or succeed but yield an ACL that makes no sense (I’m not quite sure which). I found a similar issue in real world use where group names contained a colon. The parser was scanning forward for a colon to determine the end of the ACL entries field:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">int</span> finalDelimIdx = unparsedInput.<span class="fu">indexOf</span>(<span class="st">&quot;:&quot;</span>);
<span class="bu">String</span> entriesString = unparsedInput.<span class="fu">substring</span>(<span class="dv">0</span>, finalDelimIdx);</code></pre></div>
<p>This was fixed by scanning backwards from the end of the string for the final colon:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">int</span> finalDelimIdx = unparsedInput.<span class="fu">lastIndexOf</span>(<span class="st">&quot;:&quot;</span>);
<span class="bu">String</span> entriesString = unparsedInput.<span class="fu">substring</span>(<span class="dv">0</span>, finalDelimIdx);</code></pre></div>
<p>Now colons in group names work as expected. But it is broken in a different way: if the comment contains a colon, parsing will fail. These kinds of defects are symptomatic of the ad-hoc, brittle parser implementation.</p>
<h3 id="incomplete-parsing">Incomplete parsing</h3>
<p><code>ACLEntry.parseACLEntry</code> method does not actually parse the access expressions. An ACL expression can look like:</p>
<pre><code>user=&quot;caadmin&quot; || group=&quot;Administrators&quot;</code></pre>
<p>The expression is saved in the <code>ACLEntry</code> as-is, i.e. as a string. Parsing is deferred to ACL evaluation. Parsing work is repeated every time the entry is evaluated. The deferral also means that invalid expressions are silently allowed and can only be noticed when they are evaluated. The effect of an invalid expression depends on the kind of syntax error, and the behaviour of the access evaluator.</p>
<h3 id="access-evaluator-expressions">Access evaluator expressions</h3>
<p>The code that parses access evaluator expressions (e.g. <code>user=&quot;bob&quot;</code>) will accept any of <code>=</code>, <code>!=</code>, <code>&gt;</code> or <code>&lt;</code>, even when the nominated access evaluator does not handle the given operator. For example, <code>user&gt;&quot;bob&quot;</code> will be accepted, but the <code>user</code> access evaluator only handles <code>=</code> and <code>!=</code>. It is up to each access evaluator to handle invalid operators appropriately. This is a burden on the programmer. It’s also confusing for users in that semantically invalid expressions like <code>user&gt;&quot;bob&quot;</code> do not result in an error.</p>
<p>Furthermore, the set of access evaluator operators is not extensible. Dogtag administrators can write their own access evaluators and configure Dogtag to use them. But these can only use the <code>=</code>, <code>!=</code>, <code>&gt;</code> or <code>&lt;</code> operators. If you need more than four operators, need non-binary operators, or would prefer different operator symbols, too bad.</p>
<h3 id="acl-evaluation">ACL evaluation</h3>
<p>The <code>AAclAuthz</code> class (<a href="https://github.com/dogtagpki/pki/blob/223e6980c3f3f7a075890897bbb74140cb95279a/base/server/cms/src/com/netscape/cms/authorization/AAclAuthz.java">source</a>) contains around 400 lines of code for evaluating an ACLs for a given user and permissions. (This includes the expression parsing discussed above). In addition, the typical access evaluator class (<code>UserAccessEvaluator</code>, <code>GroupAccessEvaluator</code>, etc.) has about 20 to 40 lines of code dealing with evaluation. The logic is not straightforward to follow.</p>
<p>There is at least one major bug in this code. There is a global configuration that controls whether an ACL’s <em>allow</em> rules or <em>deny</em> rules are processed first. The default is <em>deny,allow</em>, but if you change it to <em>allow,deny</em>, then a matching <em>allow</em> rule will cause denial! Observe (example simplified and commentary added by me):</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">if</span> (order.<span class="fu">equals</span>(<span class="st">&quot;deny&quot;</span>)) {
    <span class="co">// deny,allow, the default</span>
    entries = <span class="fu">getDenyEntries</span>(nodes, perm);
} <span class="kw">else</span> {
    <span class="co">// allow,deny</span>
    entries = <span class="fu">getAllowEntries</span>(nodes, perm);
}

<span class="kw">while</span> (entries.<span class="fu">hasMoreElements</span>()) {
    ACLEntry entry = entries.<span class="fu">nextElement</span>();
    <span class="kw">if</span> (<span class="fu">evaluateExpressions</span>(
            authToken,
            entry.<span class="fu">getAttributeExpressions</span>())) {
        <span class="co">// if we are in allow,deny mode, we just hit</span>
        <span class="co">// a matching *allow* rule, and deny access</span>
        <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">EACLsException</span>(<span class="st">&quot;permission denied&quot;</span>);
    }
}</code></pre></div>
<p>The next step of this routine is to process the next set of rules. Like above, if we are in <em>allow,deny</em> mode and encounter a matching <em>deny</em> rule, access will be granted.</p>
<p>This is a serious bug! It completely reverses the meaning of ACLs. In most cases the environment will be completely broken. It also poses a security issue. Because of how broken this setting is, the Dogtag team thinks that it’s unlikely that anyone is running in <em>allow,deny</em> mode. But we can’t be sure, so the bug was assigned <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1556657">CVE-2018-1080</a>.</p>
<p>This defect is present in the initial commit in the Dogtag Git repository (2008). It might have been present in the original implementation. But whenever it was introduced, the problem was not noticed. Several developers who made small changes over the years to the ACL code (logging, formatting, etc) did not notice it. Including me, until very recently.</p>
<p>How has this bug existed for so long? There are several possible factors:</p>
<ul>
<li>Lack of tests, or at least lack of testing in <em>allow,deny</em> mode</li>
<li>Verbose, hard to read code makes it hard to notice a bug that might be more obvious in “pseudo-code”.</li>
<li><a href="https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/">Boolean blindness</a>. A boolean is just a bit, divorced from the context that constructed it. This can lead to misinterpretation. In this case, the boolean result of <code>evaluateExpressions</code> was misinterpreted as <em>allow|deny</em>; the correct interpretation is <em>match|no-match</em>.</li>
<li>Lack of code review. Perhaps peer code review was not practiced when the original implementation was written. Today all patches are reviewed by another Dogtag developer before being merged (we use <a href="https://www.gerritcodereview.com/">Gerrit</a> for that). There is a chance (but not a guarantee) we might have noticed that bug. Maybe a systematic review of old code is warranted.</li>
</ul>
<h2 id="a-better-way">A better way?</h2>
<p>So, looking at one small but important part of Dogtag, we see an old, broken implementation. Some of these problems can be fixed easily (the <em>allow,deny</em> bug). Others require more work (fixing the parsing, extensible access evaluator operators).</p>
<p>Is it worth fixing the non-critical issues? Taking Java as an assumption, it is debatable. The implementation could be cleaned up, type safety improved, bugs fixed. But Java being what it is, even if a lot of the parsing complexity was handled by libraries, the result would still be fairly verbose. Readability and maintainability would still be limited, because of the limitations of Java itself.</p>
<p>So let’s refine our assumption. Instead of <em>Java</em>, we will assume <em>JVM</em>. This opens up to us a bunch of languages that target the JVM, and libraries written using those languages. Dogtag will probably never leave the JVM, for various reasons. But there’s no technical reason we can’t replace old, worn out parts made of Java with new implementations written using languages that have more to offer in terms of correctness, readability and maintainability.</p>
<p>There are <a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">many languages</a> that target the JVM and interoperate with Java. One such language is <a href="https://www.haskell.org/">Haskell</a>, an advanced, pure functional programming (FP) language. JVM support for Haskell comes in the guise of <a href="https://eta-lang.org/">Eta</a>. Eta is a fork of GHC (the most popular Haskell compiler) version 7.10, so any pure Haskell code that worked with GHC 7.10 will work with Eta. I won’t belabour any more gory details of the toolchain right now. Instead, we can dive right into a prototype of ACLs written in Haskell/Eta.</p>
<h2 id="i-haskell-an-acl">I Haskell an ACL</h2>
<p>I assembled a Haskell prototype (<a href="https://github.com/frasertweedale/notes-redhat/tree/master/fp-examples/acl">source code</a>) of the ACL machinery in one day. Much of this time was spent reading the Java implementation so I could preserve its semantics.</p>
<p>The prototype is not complete. It does not support serialisation of ACLs or the heirarchical nature of ACL evaluation (i.e. checking an authorisation on resource <code>foo.bar.baz</code> would check ACLs named <code>foo.bar.baz</code>, <code>foo.bar</code> and <code>foo</code>). It does support parsing and evaluation. We shall see that it resolves the problems in the Java implementation discussed above.</p>
<p>The implementation is about 250 lines of code, roughly ⅓ the size of the Java implementation. It is much easier to read and reason about. Let’s look at a few highlights.</p>
<p>The definitions of the <code>ACL</code> data type, and its constituents, are straightforward:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Permission</span> <span class="fu">=</span> <span class="dt">Text</span>  <span class="co">-- type synonym, for convenience</span>

<span class="kw">data</span> <span class="dt">ACLRuleType</span> <span class="fu">=</span> <span class="dt">Allow</span> <span class="fu">|</span> <span class="dt">Deny</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>) <span class="co">-- auto-derive an equality</span>
                <span class="co">-- test (==) for this type</span>

<span class="co">-- a record type with 3 fields</span>
<span class="kw">data</span> <span class="dt">ACLRule</span> <span class="fu">=</span> <span class="dt">ACLRule</span>
  {<span class="ot"> aclRuleType ::</span> <span class="dt">ACLRuleType</span>
  ,<span class="ot"> aclRulePermissions ::</span> [<span class="dt">Permission</span>]
  ,<span class="ot"> aclRuleExpression ::</span> <span class="dt">ACLExpression</span>
  }

<span class="kw">data</span> <span class="dt">ACL</span> <span class="fu">=</span> <span class="dt">ACL</span>
  {<span class="ot"> aclName ::</span> <span class="dt">Text</span>
  ,<span class="ot"> aclPermissions ::</span> [<span class="dt">Permission</span>]
  ,<span class="ot"> aclRules ::</span> [<span class="dt">ACLRule</span>]
  ,<span class="ot"> aclDescription ::</span> <span class="dt">Text</span>
  }</code></pre></div>
<p>The definition of the ACL parser follows the structure of the data type. This aids readability and assists reasoning about correctness:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">acl ::</span> [<span class="dt">Parser</span> <span class="dt">AccessEvaluator</span>] <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">ACL</span>
acl ps <span class="fu">=</span> <span class="dt">ACL</span>
  <span class="fu">&lt;$&gt;</span> takeWhile1 (<span class="fu">/=</span> <span class="ch">&#39;:&#39;</span>) <span class="fu">&lt;*</span> char <span class="ch">&#39;:&#39;</span>
  <span class="fu">&lt;*&gt;</span> (permission <span class="ot">`sepBy1`</span> char <span class="ch">&#39;,&#39;</span>) <span class="fu">&lt;*</span> char <span class="ch">&#39;:&#39;</span>
  <span class="fu">&lt;*&gt;</span> (rule ps <span class="ot">`sepBy1`</span> spaced (char <span class="ch">&#39;;&#39;</span>)) <span class="fu">&lt;*</span> char <span class="ch">&#39;:&#39;</span>
  <span class="fu">&lt;*&gt;</span> takeText</code></pre></div>
<p>Each line is a parser for one of the fields of the <code>ACL</code> data type. The <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> <em>infix</em> functions combine these smaller parsers into a parser for the whole <code>ACL</code> type. <code>permission</code> and <code>rule</code> are parsers for the <code>Permission</code> and <code>ACLRule</code> data types, respectively. The <code>sepBy1</code> combinator turns a parser for a single thing into a parser for a list of things.</p>
<p>Note that several of these <em>combinators</em> are not specific to parsers but are derived from, or part of, a common abstraction that parsers happen to inhabit. The actual parser library used is incidental. A simple parser type and all the combinators used in this ACL implementation, written from scratch, would take all of 50 lines.</p>
<p>The <code>[Parser AccessEvaluator]</code> argument (named <code>ps</code>) is a list of parsers for <code>AccessEvaluator</code>. This provides the access evaluator extensibility we desire while ensuring that invalid expressions are rejected. The details are down inside the implementation of <code>rule</code> and are not discussed here.</p>
<p>Next we’ll look at how ACLs are evaluated:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ACLRuleOrder</span> <span class="fu">=</span> <span class="dt">AllowDeny</span> <span class="fu">|</span> <span class="dt">DenyAllow</span>

<span class="kw">data</span> <span class="dt">ACLResult</span> <span class="fu">=</span> <span class="dt">Allowed</span> <span class="fu">|</span> <span class="dt">Denied</span>

evaluateACL
<span class="ot">  ::</span> <span class="dt">ACLRuleOrder</span>
  <span class="ot">-&gt;</span> <span class="dt">AuthenticationToken</span>
  <span class="ot">-&gt;</span> <span class="dt">Permission</span>
  <span class="ot">-&gt;</span> <span class="dt">ACL</span>
  <span class="ot">-&gt;</span> <span class="dt">ACLResult</span>
evaluateACL order tok perm (<span class="dt">ACL</span> _ _ rules _ ) <span class="fu">=</span>
  fromMaybe <span class="dt">Denied</span> result  <span class="co">-- deny if no rules matched</span>
  <span class="kw">where</span>
    permRules <span class="fu">=</span>
      filter (elem perm <span class="fu">.</span> aclRulePermissions) rules

    orderedRules <span class="fu">=</span> <span class="kw">case</span> order <span class="kw">of</span>
      <span class="dt">DenyAllow</span> <span class="ot">-&gt;</span> denyRules <span class="fu">&lt;&gt;</span> allowRules
      <span class="dt">AllowDeny</span> <span class="ot">-&gt;</span> allowRules <span class="fu">&lt;&gt;</span> denyRules
    denyRules <span class="fu">=</span>
      filter ((<span class="fu">==</span> <span class="dt">Deny</span>) <span class="fu">.</span> aclRuleType) permRules
    allowRules <span class="fu">=</span>
      filter ((<span class="fu">==</span> <span class="dt">Allow</span>) <span class="fu">.</span> aclRuleType) permRules

    <span class="co">-- the first matching rule wins</span>
    result <span class="fu">=</span> getFirst
      (foldMap (<span class="dt">First</span> <span class="fu">.</span> evaluateRule tok) orderedRules)</code></pre></div>
<p>Given an <code>ACLRuleOrder</code>, an <code>AuthenticationToken</code> bearing user data, a <code>Permission</code> on the resource being accessed and an <code>ACL</code> for that resource, <code>evaluateACL</code> returns an <code>ACLResult</code> (either <code>Allowed</code> or <code>Denied</code>. The implementation filters rules for the given permission, orders the rules according to the <code>ACLRuleOrder</code>, and returns the result of the first matching rule, or <code>Denied</code> if no rules were matched.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">evaluateRule
<span class="ot">  ::</span> <span class="dt">AuthenticationToken</span>
  <span class="ot">-&gt;</span> <span class="dt">ACLRule</span>
  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">ACLResult</span>
evaluateRule tok (<span class="dt">ACLRule</span> ruleType _ expr) <span class="fu">=</span>
  <span class="kw">if</span> evaluateExpression tok expr
    <span class="kw">then</span> <span class="dt">Just</span> (result ruleType)
    <span class="kw">else</span> <span class="dt">Nothing</span>
  <span class="kw">where</span>
    result <span class="dt">Deny</span> <span class="fu">=</span> <span class="dt">Denied</span>
    result <span class="dt">Allow</span> <span class="fu">=</span> <span class="dt">Allowed</span></code></pre></div>
<p>Could the <em>allow,deny</em> bug from the Java implementation occur here? It cannot. Instead of the rule evaluator returning a <code>boolean</code> as in the Java implementation, <code>evaluateRule</code> returns a <code>Maybe ACLResult</code>. If a rule does not match, its result is <code>Nothing</code>. If it does match, the result is <code>Just Denied</code> for <code>Deny</code> rules, or <code>Just Allowed</code> for <code>Allow</code> rules. The first <code>Just</code> result encountered is used directly. It’s still possible to mess up the implementation, for example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">result <span class="dt">Deny</span> <span class="fu">=</span> <span class="dt">Allowed</span>
result <span class="dt">Allow</span> <span class="fu">=</span> <span class="dt">Deny</span></code></pre></div>
<p>But this kind of error is less likely to occur and more likely to be noticed. Boolean blindness is not a factor.</p>
<h2 id="benefits-of-fp-for-prototyping">Benefits of FP for prototyping</h2>
<p>There are benefits to using functional programming for prototyping or re-implementing parts of a system written in less expressive langauges.</p>
<p>First, a tool like Haskell lets you express the nature of a problem succinctly, and leverage the type system as a design tool as you work towards a solution. The solution can then be translated into Java (or Python, or whatever). Because of the less powerful (or nonexistent) type system, there will be a trade-off. You will either have to throw away some of the type safety, or incur additional complexity to keep it (how much complexity depends on the target language). It would be better if we didn’t have to make this trade-off (e.g. by using Eta). But the need to make the trade-off does not diminish the usefulness of FP as a design tool.</p>
<p>It’s also a great way of learning about an existing part of Dogtag, and checking assumptions. And for finding bugs, and opportunities for improving type safety, APIs or performance. I learned a lot about Dogtag’s ACL implementation by reading the code to understand the problem, then solving the problem using FP. Later, I was able to translate some aspects of the Haskell implementation (e.g. using sum types to represent ACL rule types and the evaluation order setting) back into the Java implementation (as <code>enum</code> types). This improved type safety and readability.</p>
<p>Going forward, for significant new code and for fixes or refactorings in isolated parts of Dogtag’s implementation, I will spend some time representing the problems and designing solutions in Haskell. The resulting programs will be useful artifacts in their own right; a kind of documentation.</p>
<h2 id="where-to-from-here">Where to from here?</h2>
<p>I’ve demonstrated some of the benefits of the Haskell implementation of ACLs. If the Dogtag development team were to agree that we should begin using FP in Dogtag itself, what would the next steps be?</p>
<p>Eta is not yet packaged for Fedora, let alone RHEL. So as a first step we would have to talk to product managers and release engineers about bringing Eta into RHEL. This is probably the biggest hurdle. One team asking for a large and rather green toolchain that’s not used anywhere else (yet) to be brought into RHEL, where it will have to be supported forever, is going to raise eyebrows.</p>
<p>If we clear that hurdle, then comes the work of packaging Eta. Someone (me) will have to become the package mantainer. And by the way, Eta is written in (GHC) Haskell, so we’ll also need to package GHC for RHEL (or RHEL-extras). Fortunately, GHC <em>is</em> packaged for Fedora, so there is less to do there.</p>
<p>The final stage would be integrating Eta into Dogtag. The build system will need to be updated, and we’ll need to work out how we want to use Eta-based functions and objects from Java (and vice-versa). For the ACLs system, we might want to make the old and new implementations available side by side, for a while. We could even run both implementations simultaneously in a <em>sanity check</em> mode, checking that results are consistent and emitting a warning when they diverge.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This post started with a discussion of the costs and risks of making (or avoiding) significant changes in a legacy system. We then looked in detail at the ACLs implementation in Dogtag, noting some of its problems.</p>
<p>We examined a prototype (re)implementation of ACLs in <em>Haskell</em>, noting several advantages over the legacy implementation. FP’s usefulness as a design tool was discussed. Then we discussed the possibility of using FP in Dogtag itself. What would it take to start using Haskell in Dogtag, via the <em>Eta</em> compiler which targets the JVM? There are several hurdles, technical and non-technical.</p>
<p>Is it worth all this effort, just to be in a position where we can (re)write even a small component of Dogtag in a language other than Java? A language that assists the programmer in writing correct, readable and maintainable software? In answering this question, the costs and risks of persisting with legacy languages and APIs must be considered. I believe the answer is “yes”.</p>]]></summary>
</entry>
<entry>
    <title>DN attribute value encoding in X.509</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2018-03-15-x509-dn-attribute-encoding.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2018-03-15-x509-dn-attribute-encoding.html</id>
    <published>2018-03-15T00:00:00Z</published>
    <updated>2018-03-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="dn-attribute-value-encoding-in-x.509">DN attribute value encoding in X.509</h1>
<p>X.509 certificates use the X.500 <em>Distinguished Name (DN)</em> data type to represent issuer and subject names. X.500 names may contain a variety of fields including <em>CommonName</em>, <em>OrganizationName</em>, <em>Country</em> and so on. This post discusses how these values are encoded and compared, and problematic circumstances that can arise.</p>
<h2 id="asn.1-string-types-and-encodings">ASN.1 string types and encodings</h2>
<p>ASN.1 offers a large number of string types, including:</p>
<ul>
<li><code>NumericString</code></li>
<li><code>PrintableString</code></li>
<li><code>IA5String</code></li>
<li><code>UTF8String</code></li>
<li><code>BMPString</code></li>
<li>…several others</li>
</ul>
<p>When serialising an ASN.1 object, each of these string types has a different tag. Some of the types have a shared representation for serialisation but differ in which characters they allow. For example, <code>NumericString</code> and <code>PrintableString</code> are both represented in DER using one byte per character. But <code>NumericString</code> only allows digits (<code>0</code>–<code>9</code>) and <code>SPACE</code>, whereas <code>PrintableString</code> admits the full set of ASCII printable characters. In contrast, <code>BMPString</code> uses two bytes to represent each character; it is equivalent to UTF-16BE. <code>UTF8String</code>, unsurprisingly, uses UTF-8.</p>
<h2 id="asn.1-string-types-for-x.509-name-attributes">ASN.1 string types for X.509 name attributes</h2>
<p>Each of the various X.509 name attribute types uses a specific ASN.1 string type. Some types have a size constraint. For example:</p>
<pre><code>X520countryName      ::= PrintableString (SIZE (2))
DomainComponent      ::= IA5String
X520CommonName       ::= DirectoryName (SIZE (1..64))
X520OrganizationName ::= DirectoryName (SIZE (1..64))</code></pre>
<p>Hold on, what is <code>DirectoryName</code>? It is not a universal ASN.1 type; it is specified as a sum of string types:</p>
<pre><code>DirectoryName ::= CHOICE {
    teletexString     TeletexString,
    printableString   PrintableString,
    universalString   UniversalString,
    utf8String        UTF8String,
    bmpString         BMPString }</code></pre>
<p>Note that a size constraint on <code>DirectoryName</code> propagates to each of the cases. The constraint gives a maximum length in <em>characters</em>, not bytes.</p>
<p>Most X.509 attribute types use <code>DirectoryName</code>, including <em>common name (CN)</em>, <em>organization name (O)</em>, <em>organizational unit (OU)</em>, <em>locality (L)</em>, <em>state or province name (ST)</em>. For these attribute types, which encoding should be used? <a href="">RFC 5280 §4.1.2.6</a> provides some guidance:</p>
<pre><code>The DirectoryString type is defined as a choice of PrintableString,
TeletexString, BMPString, UTF8String, and UniversalString.  CAs
conforming to this profile MUST use either the PrintableString or
UTF8String encoding of DirectoryString, with two exceptions.</code></pre>
<p>The current version of X.509 only allows <code>PrintableString</code> and <code>UTF8String</code>. Earlier versions allowed any of the types in <code>DirectoryString</code>. The <em>exceptions</em> mentioned are grandfather clauses that permit the use of the now-prohibited types in environments that were already using them.</p>
<p>So for strings containing non-ASCII code points <code>UTF8String</code> is the only type you can use. But for ASCII-only strings, there is still a choice, and the RFC does not make a recommendation on which to use. Both are common in practice.</p>
<p>This poses an interesting question. Suppose two encoded DNs have the same attributes in the same order, but differ in the string encodings used. Are they the same DN?</p>
<h2 id="comparing-dns">Comparing DNs</h2>
<p><a href="https://tools.ietf.org/html/rfc5280#section-7.1">RFC 5280 §7.1</a> outlines the procedure for comparing DNs. To compare strings you must convert them to Unicode, translate or drop some special-purpose characters, and perform case folding and normalisation. The resulting strings are then compared case-insensitively. According to this rule, DNs that use different string encodings but are otherwise the same are <strong>equal</strong>.</p>
<p>But the situation is more complex in practice. Earlier versions of X.509 required only binary comparison of DNs. For example, <a href="https://tools.ietf.org/html/rfc3280">RFC 3280</a> states:</p>
<pre><code>Conforming implementations are REQUIRED to implement the following
name comparison rules:

   (a)  attribute values encoded in different types (e.g.,
   PrintableString and BMPString) MAY be assumed to represent
   different strings;

   (b) attribute values in types other than PrintableString are case
   sensitive (this permits matching of attribute values as binary
   objects);

   (c)  attribute values in PrintableString are not case sensitive
   (e.g., &quot;Marianne Swanson&quot; is the same as &quot;MARIANNE SWANSON&quot;); and

   (d)  attribute values in PrintableString are compared after
   removing leading and trailing white space and converting internal
   substrings of one or more consecutive white space characters to a
   single space.</code></pre>
<p>Futhermore, RFC 5280 and earlier versions of X.509 state:</p>
<pre><code>The X.500 series of specifications defines rules for comparing
distinguished names that require comparison of strings without regard
to case, character set, multi-character white space substring, or
leading and trailing white space.  This specification relaxes these
requirements, requiring support for binary comparison at a minimum.</code></pre>
<p>This is a contradiction. The above states that binary comparison of DNs is acceptable, but other sections require a more sophisticated comparison algorithm. The combination of this contradiction, historical considerations and (no doubt) programmer laziness means that many X.509 implementations only perform <strong>binary comparison</strong> of DNs.</p>
<h2 id="how-cas-should-handle-dn-attribute-encoding">How CAs should handle DN attribute encoding</h2>
<p>To ease certification path construction with clients that only perform binary matching of DNs, RFC 5280 states the following requirement:</p>
<pre><code>When the subject of the certificate is a CA, the subject
field MUST be encoded in the same way as it is encoded in the
issuer field (Section 4.1.2.4) in all certificates issued by
the subject CA.  Thus, if the subject CA encodes attributes
in the issuer fields of certificates that it issues using the
TeletexString, BMPString, or UniversalString encodings, then
the subject field of certificates issued to that CA MUST use
the same encoding.</code></pre>
<p>This is confusing wording, but in practical terms there are two requirements:</p>
<ol style="list-style-type: decimal">
<li>The Issuer DN on a certificate must be byte-identical to the Subject DN of the CA that issued it.</li>
<li>The attribute encodings in a CA’s Subject DN must not change (e.g. when the CA certificate gets renewed).</li>
</ol>
<p>If a CA violates either of these requirements breakage will ensue. Programs that do binary DN comparison will be unable to construct a certification path to the CA.</p>
<p>For <em>end-entity</em> (or <em>leaf</em>) certificates, the subject DN is not use in any links of the certification path. Changing the subject attribute encoding when renewing an end-entity certificate will not break validation. But it could still confuse some programs that only do binary comparison of DNs (e.g. they might display two distinct subjects).</p>
<h2 id="processing-certificate-requests">Processing certificate requests</h2>
<p>What about when processing certificate requests—should CAs respect the attribute encodings in the CSR? In my experience, CA programs are prone to issuing certificates with the subject encoded differently from how it was encoded in the CSR. CAs may do various kinds of validation, substitution or addition of subject name attributes. Or they may enforce the use of a particular encoding regardless of the encoding in the CSR.</p>
<p>Is this a problem? It depends on the client program. In my experience most programs can handle this situation. Problems mainly arise when the issuer or subject encoding changes <em>upon renewal</em> (for the reasons discussed above).</p>
<p>If a CSR-versus-certificate encoding mismatch does cause a problem for you, you may have to create a new CSR with the attributes encoding you expect the CA to use for the certificate. In many programs this is not straightforward, if it is possible at all. If you control the CA you might be able to configure it to use particular encodings for string attributes, or to respect the encodings in the CSR. The options available and how to configure them vary among CA programs.</p>
<h2 id="recap">Recap</h2>
<p>X.509 requires the use of either <code>PrintableString</code> or <code>UTF8String</code> for most DN attribute types. Strings consisting of printable 7-bit ASCII characters can be represented using either encoding. This ambiguity can lead to problems in certification path construction.</p>
<p>Formally, two DNs that have the same attributes and values are the same DN, regardless of the string encodings used. But there are many programs that only perform binary matching of DNs. To avoid causing problems for such programs a CA:</p>
<ul>
<li><em>must</em> ensure that the Issuer DN field on all certificates it issues is identical to its own Subject DN;</li>
<li><em>must</em> ensure that Subject DN attribute encodings on CA certificates it issues to a given subject do not change upon renewal;</li>
<li><em>should</em> ensure that Subject DN attribute encodings on end-entity certificates it issues to a given subject do not change upon renewal.</li>
</ul>
<p>CAs will often issue certificates with values encoded differently from how they were presented in the CSR. This usually does not cause problems. But if it does cause problems, you might be able to configure the client program to produce a CSR with different attribute encodings. If you control the CA you may be able to configure it to have a different treatment for attribute encodings. How to do these things was beyond the scope of this article.</p>]]></summary>
</entry>
<entry>
    <title>Changing a CA’s Subject DN; Part II: FreeIPA</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2017-11-22-changing-ca-subject-dn-part-ii-freeipa.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2017-11-22-changing-ca-subject-dn-part-ii-freeipa.html</id>
    <published>2017-11-22T00:00:00Z</published>
    <updated>2017-11-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="changing-a-cas-subject-dn-part-ii-freeipa">Changing a CA’s Subject DN; Part II: FreeIPA</h1>
<p>In the <a href="2017-11-20-changing-ca-subject-dn-part-i.html">previous post</a> I explained how the CA Subject DN is an integral part of X.509 any why you should not change it. Doing so can break path validation, CRLs and OCSP, and many programs will not copye with the change. I proposed some alternative approaches that avoid these problems: re-chaining the CA, and creating subordinate CAs.</p>
<p>If you were thinking of changing your CA’s Subject DN, I hope that I dissuaded you. But if I failed, or you absolutely do need to change the Subject DN of your CA, where there’s a will there’s way. The purpose of this post is to explore how to do this in FreeIPA, and discuss the implications.</p>
<p>This is a <strong>long post</strong>. If you are really changing the CA subject DN, don’t skip anything. Otherwise don’t feel bad about skimming or jumping straight to the <a href="#discussion">discussion</a>. Even skimming the article will give you an idea of the steps involved, and how to repair the ensuing breakage.</p>
<h2 id="changing-the-freeipa-cas-subject-dn">Changing the FreeIPA CA’s Subject DN</h2>
<p>Before writing this post, I had never even attempted to do this. I am unaware of anyone else trying or whether they were successful. But the question of how to do it has come up several times, so I decided to investigate. The format of this post follows my exploration of the topic as I poked and prodded a FreeIPA deployment, working towards the goal.</p>
<p>What was the goal? Let me state the goal, and some assumptions:</p>
<ul>
<li>The goal is to give the FreeIPA CA a new Subject DN. The deployment should look and behave as though it were originally installed with the new Subject.</li>
<li>We want to keep the old CA certificate in the relevant certificate stores and databases, alongside the new certificate.</li>
<li>The CA is not being re-keyed (I will deal with re-keying in a future article).</li>
<li>We want to be able to do this with both self-signed and externally-signed CAs. It’s okay if the process differs.</li>
<li>It’s okay to have manual steps that the administrator must perform.</li>
</ul>
<p>Let’s begin on the deployment’s <em>CA renewal master</em>.</p>
<h3 id="certmonger-first-attempt">Certmonger (first attempt)</h3>
<p>There is a Certmonger tracking request for the FreeIPA CA, which uses the <code>dogtag-ipa-ca-renew-agent</code> CA helper. The <code>getcert resubmit</code> command lets you change the Subject DN when you resubmit a request, via the <code>-N</code> option. I know the internals of the CA helper and I can see that there will be problems <em>after</em> renewing the certificate this way. Storing the certificate in the <code>ca_renewal</code> LDAP container will fail. But the renewal itself <em>might</em> succeed so I’ll try it and see what happens:</p>
<pre><code>[root@f27-2 ~]# getcert resubmit -i 20171106062742 \
  -N &#39;CN=IPA.LOCAL CA 2017.11.09&#39;
Resubmitting &quot;20171106062742&quot; to &quot;dogtag-ipa-ca-renew-agent&quot;.</code></pre>
<p>After waiting about 10 seconds for Certmonger to do its thing, I check the state of the tracking request:</p>
<pre><code>[root@f27-2 ~]# getcert list -i 20171106062742
Request ID &#39;20171106062742&#39;:
  status: MONITORING
  CA: dogtag-ipa-ca-renew-agent
  issuer: CN=Certificate Authority,O=IPA.LOCAL 201711061603
  subject: CN=Certificate Authority,O=IPA.LOCAL 201711061603
  expires: 2037-11-06 17:26:21 AEDT
  ... (various fields omitted)</code></pre>
<p>The <code>status</code> and <code>expires</code> fields show that renewal succeeded, but the certificate still has the old Subject DN. This happened because the <code>dogtag-ipa-ca-renew-agent</code> helper doesn’t think it is renewing the CA certificate (which is true!)</p>
<h3 id="modifying-the-ipa-ca-entry">Modifying the IPA CA entry</h3>
<p>So let’s trick the Certmonger renewal helper. <code>dogtag-ipa-ca-renew-agent</code> looks up the CA Subject DN in the <code>ipaCaSubjectDn</code> attribute of the <code>ipa</code> CA entry (<code>cn=ipa,cn=cas,cn=ca,{basedn}</code>). This attribute is not writeable via the IPA framework but you can change it using regular LDAP tools (details out of scope). If the certificate is self-signed you should also change the <code>ipaCaIssuerDn</code> attribute. After modifying the entry run <code>ipa ca-show</code> to verify that these attributes have the desired values:</p>
<pre><code>[root@f27-2 ~]# ipa ca-show ipa
  Name: ipa
  Description: IPA CA
  Authority ID: cdbfeb5a-64d2-4141-98d2-98c005802fc1
  Subject DN: CN=IPA.LOCAL CA 2017.11.09
  Issuer DN: CN=IPA.LOCAL CA 2017.11.09
  Certificate: MIIDnzCCAoegAwIBAgIBCTANBgkqhkiG9w0...</code></pre>
<h3 id="certmonger-second-attempt">Certmonger (second attempt)</h3>
<p>Now let’s try and renew the CA certificate via Certmonger again:</p>
<pre><code>[root@f27-2 ~]# getcert resubmit -i 20171106062742 \
  -N &#39;CN=IPA.LOCAL CA 2017.11.09&#39;
Resubmitting &quot;20171106062742&quot; to &quot;dogtag-ipa-ca-renew-agent&quot;.</code></pre>
<p>Checking the <code>getcert list</code> output after a short wait:</p>
<pre><code>[root@f27-2 ~]# getcert list -i 20171106062742
Request ID &#39;20171106062742&#39;:
  status: MONITORING
  CA: dogtag-ipa-ca-renew-agent
  issuer: CN=Certificate Authority,O=IPA.LOCAL 201711061603
  subject: CN=IPA.LOCAL CA 2017.11.09
  expires: 2037-11-09 16:11:12 AEDT
  ... (various fields omitted)</code></pre>
<p>Progress! We now have a CA certificate with the desired Subject DN. The new certificate has the old (current) issuer DN. We’ll ignore that for now.</p>
<h3 id="checking-server-health">Checking server health</h3>
<p>Now I need to check the state of the deployment. Did anything go wrong during renewal? Is everything working?</p>
<p>First, I checked the Certmonger journal output to see if there were any problems. The journal contained the following messages (some fields omitted for brevity):</p>
<pre><code>16:11:17 /dogtag-ipa-ca-renew-agent-submit[1662]: Forwarding request to dogtag-ipa-renew-agent
16:11:17 /dogtag-ipa-ca-renew-agent-submit[1662]: dogtag-ipa-renew-agent returned 0
16:11:19 /stop_pkicad[1673]: Stopping pki_tomcatd
16:11:20 /stop_pkicad[1673]: Stopped pki_tomcatd
16:11:22 /renew_ca_cert[1710]: Updating CS.cfg
16:11:22 /renew_ca_cert[1710]: Updating CA certificate failed: no matching entry found
16:11:22 /renew_ca_cert[1710]: Starting pki_tomcatd
16:11:34 /renew_ca_cert[1710]: Started pki_tomcatd
16:11:34 certmonger[2013]: Certificate named &quot;caSigningCert cert-pki-ca&quot; in token &quot;NSS Certificate DB&quot; in database &quot;/etc/pki/pki-tomcat/alias&quot; issued by CA and saved.</code></pre>
<p>We can see that the renewal succeeded and Certmonger saved the new certificate in the NSSDB. Unfortunately there was an error in the <code>renew_ca_cert</code> post-save hook: it failed to store the new certificate in the LDAP certstore. That should be easy to resolve. I’ll make a note of that and continue checking deployment health.</p>
<p>Next, I checked whether Dogtag was functioning. <code>systemctl status pki-tomcatd@pki-tomcat</code> and the CA debug log (<code>/var/log/pki/pki-tomcat/ca/debug</code>) indicated that Dogtag started cleanly. Even better, the Dogtag NSSDB has the new CA certificate with the correct nickname:</p>
<pre><code>[root@f27-2 ~]# certutil -d /etc/pki/pki-tomcat/alias \
  -L -n &#39;caSigningCert cert-pki-ca&#39;
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 11 (0xb)
        Signature Algorithm: PKCS #1 SHA-256 With RSA Encryption
        Issuer: &quot;CN=Certificate Authority,O=IPA.LOCAL 201711061603&quot;
        Validity:
            Not Before: Thu Nov 09 05:11:12 2017
            Not After : Mon Nov 09 05:11:12 2037
        Subject: &quot;CN=IPA.LOCAL CA 2017.11.09&quot;
  ... (remaining lines omitted)</code></pre>
<p>We have not yet confirmed that the Dogtag uses the new CA Subject DN as the Issuer DN on new certificates (we’ll check this later).</p>
<p>Now let’s check the state of IPA itself. There is a problem in communication between the IPA framework and Dogtag:</p>
<pre><code>[root@f27-2 ~]# ipa ca-show ipa
ipa: ERROR: Request failed with status 500: Non-2xx response from CA REST API: 500.</code></pre>
<p>A quick look in <code>/var/log/httpd/access_log</code> showed that it was not a general problem but only occurred when accessing a particular resource:</p>
<pre><code>[09/Nov/2017:17:15:09 +1100] &quot;GET https://f27-2.ipa.local:443/ca/rest/authorities/cdbfeb5a-64d2-4141-98d2-98c005802fc1/cert HTTP/1.1&quot; 500 6201</code></pre>
<p>That is a Dogtag <em>lightweight authority</em> resource for the CA identified by <code>cdbfeb5a-64d2-4141-98d2-98c005802fc1</code>. That is the <em>CA ID</em> recorded in the FreeIPA <code>ipa</code> CA entry. This gives a hint about where the problem lies. An <code>ldapsearch</code> reveals more:</p>
<pre><code>[f27-2:~] ftweedal% ldapsearch -LLL \
    -D &#39;cn=directory manager&#39; -w DM_PASSWORD \
    -b &#39;ou=authorities,ou=ca,o=ipaca&#39; -s one
dn: cn=cdbfeb5a-64d2-4141-98d2-98c005802fc1,ou=authorities,ou=ca,o=ipaca
authoritySerial: 9
objectClass: authority
objectClass: top
cn: cdbfeb5a-64d2-4141-98d2-98c005802fc1
authorityID: cdbfeb5a-64d2-4141-98d2-98c005802fc1
authorityKeyNickname: caSigningCert cert-pki-ca
authorityEnabled: TRUE
authorityDN: CN=Certificate Authority,O=IPA.LOCAL 201711061603
description: Host authority

dn: cn=008a4ded-fd4b-46fe-8614-68518123c95f,ou=authorities,ou=ca,o=ipaca
objectClass: authority
objectClass: top
cn: 008a4ded-fd4b-46fe-8614-68518123c95f
authorityID: 008a4ded-fd4b-46fe-8614-68518123c95f
authorityKeyNickname: caSigningCert cert-pki-ca
authorityEnabled: TRUE
authorityDN: CN=IPA.LOCAL CA 2017.11.09
description: Host authority</code></pre>
<p>There are now two authority entries when there should be one. During startup, Dogtag makes sure it has an authority entry for the main (“host”) CA. It compares the Subject DN from the signing certificate in its NSSDB to the authority entries. If it doesn’t find a match it creates a new entry, and that’s what happened here.</p>
<p>The resolution is straightforward:</p>
<ol style="list-style-type: decimal">
<li>Stop Dogtag</li>
<li>Update the <code>authorityDN</code> and <code>authoritySerial</code> attributes of the <em>original</em> host authority entry.</li>
<li>Delete the <em>new</em> host authority entry.</li>
<li>Restart Dogtag.</li>
</ol>
<p>Now the previous <code>ldapsearch</code> returns one entry, with the original authority ID and correct attribute values:</p>
<pre><code>[f27-2:~] ftweedal% ldapsearch -LLL \
    -D &#39;cn=directory manager&#39; -w DM_PASSWORD \
    -b &#39;ou=authorities,ou=ca,o=ipaca&#39; -s one
dn: cn=cdbfeb5a-64d2-4141-98d2-98c005802fc1,ou=authorities,ou=ca,o=ipaca
authoritySerial: 11
authorityDN: CN=IPA.LOCAL CA 2017.11.09
objectClass: authority
objectClass: top
cn: cdbfeb5a-64d2-4141-98d2-98c005802fc1
authorityID: cdbfeb5a-64d2-4141-98d2-98c005802fc1
authorityKeyNickname: caSigningCert cert-pki-ca
authorityEnabled: TRUE
description: Host authority</code></pre>
<p>And the operations that were failing before (e.g. <code>ipa ca-show ipa</code>) now succeed. So we’ve confirmed, or restored, the basic functionality on this server.</p>
<h3 id="ldap-certificate-stores">LDAP certificate stores</h3>
<p>There are two LDAP certificate stores in FreeIPA. The first is <code>cn=ca_renewal,cn=ipa,cn=etc,{basedn}</code>. It is only used for replicating Dogtag CA and system certificates from the CA renewal master to CA replicas. The <code>dogtag-ipa-ca-renew-agent</code> Certmonger helper should update the <code>cn=caSigningCert cert-pki-ca,cn=ca_renewal,cn=ipa,cn=etc,{basedn}</code> entry after renewing the CA certificate. A quick <code>ldapsearch</code> shows that this succeeded, so there is nothing else to do here.</p>
<p>The other certificate store is <code>cn=certificates,cn=ipa,cn=etc,{basedn}</code>. This store contains trusted CA certificates. FreeIPA clients and servers retrieve certificates from this directory when updating their certificate trust stores. Certificates are stored in this container with a <code>cn</code> based on the Subject DN, except for the IPA CA which is stored with <code>cn={REALM-NAME} IPA CA</code>. (In my case, this is <code>cn=IPA.LOCAL IPA CA</code>.)</p>
<p>We discovered the failure to update this certificate store earlier (in the Certmonger journal). Now we must fix it up. We still want to trust certificates with the old Issuer DN, otherwise we would have to reissue <em>all of them</em>. So we need to keep the old CA certificate in the store, alongside the new.</p>
<p>The process to fix up the certificate store is:</p>
<ol style="list-style-type: decimal">
<li><p>Export the new CA certificate from the Dogtag NSSDB to a file:</p>
<pre><code>[root@f27-2 ~]# certutil -d /etc/pki/pki-tomcat/alias \
   -L -a -n &#39;caSigningCert cert-pki-ca&#39; &gt; new-ca.crt</code></pre></li>
<li><p>Add the new CA certificate to the certificate store:</p>
<pre><code>[root@f27-2 ~]# ipa-cacert-manage install new-ca.crt
Installing CA certificate, please wait
CA certificate successfully installed
The ipa-cacert-manage command was successful</code></pre></li>
<li>Rename (<code>modrdn</code>) the existing <code>cn={REALM-NAME} IPA CA</code> entry. The new <code>cn</code> RDN is based on the old CA Subject DN.</li>
<li>Rename the new CA certificate entry. The current <code>cn</code> is the new Subject DN. Rename it to <code>cn={REALM-NAME} IPA CA</code>. I encountered a 389DS attribute uniqueness error when I attempted to do this as a <code>modrdn</code> operation. I’m not sure why it happened. To work around the problem I deleted the entry and added it back with the new <code>cn</code>.</li>
</ol>
<p>At the end of this procedure the certificate store is as it should be. The CA certificate with new Subject DN is installed as <code>{REALM-NAME} IPA CA</code> and the old CA certificate has been preserved under a different RDN.</p>
<h3 id="updating-certificate-databases">Updating certificate databases</h3>
<p>The LDAP certificate stores have the new CA certificate. Now we need to update the other certificate databases so that the programs that use them will trust certificates with the new Issuer DN. These databases include:</p>
<dl>
<dt><code>/etc/ipa/ca.crt</code></dt>
<dd><p>CA trust store used by the IPA framework</p>
</dd>
<dt><code>/etc/ipa/nssdb</code></dt>
<dd><p>An NSSDB used by FreeIPA</p>
</dd>
<dt><code>/etc/dirsrv/slapd-{REALM-NAME}</code></dt>
<dd><p>NSSDB used by 389DS</p>
</dd>
<dt><code>/etc/httpd/alias</code></dt>
<dd><p>NSSDB used by Apache HTTPD</p>
</dd>
<dt><code>/etc/pki/ca-trust/source/ipa.p11-kit</code></dt>
<dd><p>Adds FreeIPA CA certificates to the system-wide trust store</p>
</dd>
</dl>
<p>Run <code>ipa-certupdate</code> to update these databases with the CA certificates from the LDAP CA certificate store:</p>
<pre><code>[root@f27-2 ~]# ipa-certupdate
trying https://f27-2.ipa.local/ipa/json
[try 1]: Forwarding &#39;schema&#39; to json server &#39;https://f27-2.ipa.local/ipa/json&#39;
trying https://f27-2.ipa.local/ipa/session/json
[try 1]: Forwarding &#39;ca_is_enabled/1&#39; to json server &#39;https://f27-2.ipa.local/ipa/session/json&#39;
[try 1]: Forwarding &#39;ca_find/1&#39; to json server &#39;https://f27-2.ipa.local/ipa/session/json&#39;
failed to update IPA.LOCAL IPA CA in /etc/dirsrv/slapd-IPA-LOCAL: Command &#39;/usr/bin/certutil -d /etc/dirsrv/slapd-IPA-LOCAL -A -n IPA.LOCAL IPA CA -t C,, -a -f /etc/dirsrv/slapd-IPA-LOCAL/pwdfile.txt&#39; returned non-zero exit status 255.
failed to update IPA.LOCAL IPA CA in /etc/httpd/alias: Command &#39;/usr/bin/certutil -d /etc/httpd/alias -A -n IPA.LOCAL IPA CA -t C,, -a -f /etc/httpd/alias/pwdfile.txt&#39; returned non-zero exit status 255.
failed to update IPA.LOCAL IPA CA in /etc/ipa/nssdb: Command &#39;/usr/bin/certutil -d /etc/ipa/nssdb -A -n IPA.LOCAL IPA CA -t C,, -a -f /etc/ipa/nssdb/pwdfile.txt&#39; returned non-zero exit status 255.
Systemwide CA database updated.
Systemwide CA database updated.
The ipa-certupdate command was successful
[root@f27-2 ~]# echo $?
0</code></pre>
<p><code>ipa-certupdate</code> reported that it was successful and it exited cleanly. But a glance at the output shows that not all went well. There were failures added the new CA certificate to several NSSDBs. Running one of the commands manually to see the command output doesn’t give us much more information:</p>
<pre><code>[root@f27-2 ~]# certutil -d /etc/ipa/nssdb -f /etc/ipa/nssdb/pwdfile.txt \
    -A -n &#39;IPA.LOCAL IPA CA&#39; -t C,, -a &lt; ~/new-ca.crt
certutil: could not add certificate to token or database: SEC_ERROR_ADDING_CERT: Error adding certificate to database.
[root@f27-2 ~]# echo $?
255</code></pre>
<p>At this point I guessed that because there is already a certificate stored with the nickname <code>IPA.LOCAL IPA CA</code>, NSS refuses to add a certificate with a different Subject DN under the same nickname. So I will delete the certificates with this nickname from each of the NSSDBs, then try again. For some reason the nickname appeared twice in each NSSDB:</p>
<pre><code>[root@f27-2 ~]# certutil -d /etc/dirsrv/slapd-IPA-LOCAL -L

Certificate Nickname                                         Trust Attributes
                                                             SSL,S/MIME,JAR/XPI

CN=alt-f27-2.ipa.local,O=Example Organization                u,u,u
CN=CA,O=Example Organization                                 C,,
IPA.LOCAL IPA CA                                             CT,C,C
IPA.LOCAL IPA CA                                             CT,C,C</code></pre>
<p>So for each NSSDB, to delete the certificate I had to execute the <code>certutil</code> command twice. For the 389DS NSSDB, the command was:</p>
<pre><code>[root@f27-2 ~]# certutil -d /etc/httpd/alias -D -n &quot;IPA.LOCAL IPA CA&quot;</code></pre>
<p>The commands for the other NSSDBs were similar. With the problematic certificates removed, I tried running <code>ipa-certupdate</code> again:</p>
<pre><code>[root@f27-2 ~]# ipa-certupdate
trying https://f27-2.ipa.local/ipa/session/json
[try 1]: Forwarding &#39;ca_is_enabled/1&#39; to json server &#39;https://f27-2.ipa.local/ipa/session/json&#39;
[try 1]: Forwarding &#39;ca_find/1&#39; to json server &#39;https://f27-2.ipa.local/ipa/session/json&#39;
Systemwide CA database updated.
Systemwide CA database updated.
The ipa-certupdate command was successful
[root@f27-2 ~]# echo $?
0</code></pre>
<p>This time there were no errors. <code>certutil</code> shows an <code>IPA.LOCAL IPA CA</code> certificate in the database, and it’s the right certificate:</p>
<pre><code>[root@f27-2 ~]# certutil -d /etc/dirsrv/slapd-IPA-LOCAL -L

Certificate Nickname                                         Trust Attributes
                                                             SSL,S/MIME,JAR/XPI

CN=alt-f27-2.ipa.local,O=Example Organization                u,u,u
CN=CA,O=Example Organization                                 C,,
CN=Certificate Authority,O=IPA.LOCAL 201711061603            CT,C,C
CN=Certificate Authority,O=IPA.LOCAL 201711061603            CT,C,C
IPA.LOCAL IPA CA                                             C,,
[root@f27-2 ~]# certutil -d /etc/dirsrv/slapd-IPA-LOCAL -L -n &#39;IPA.LOCAL IPA CA&#39;
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 11 (0xb)
        Signature Algorithm: PKCS #1 SHA-256 With RSA Encryption
        Issuer: &quot;CN=Certificate Authority,O=IPA.LOCAL 201711061603&quot;
        Validity:
            Not Before: Thu Nov 09 05:11:12 2017
            Not After : Mon Nov 09 05:11:12 2037
        Subject: &quot;CN=IPA.LOCAL CA 2017.11.09&quot;
        ...</code></pre>
<p>I also confirmed that the old and new CA certificates are present in the <code>/etc/ipa/ca.crt</code> and <code>/etc/pki/ca-trust/source/ipa.p11-kit</code> files. So all the certificate databases now include the new CA certificate.</p>
<h3 id="renewing-the-ca-certificate-again">Renewing the CA certificate (again)</h3>
<p>Observe that (in the self-signed FreeIPA CA case) the Issuer DN of the new CA certificate is the Subject DN of the old CA certificate. So we have not quite reached out goal. The original CA certificate was self-signed, so we want a self-signed certificate with the new Subject.</p>
<p>Renewing the CA certificate one more time should result in a self-signed certificate. The current situation is not likely to result in operational issues. So you can consider this an optional step. Anyhow, let’s give it a go:</p>
<pre><code>[root@f27-2 ~]# getcert list -i 20171106062742 | egrep &#39;status|issuer|subject&#39;
        status: MONITORING
        issuer: CN=Certificate Authority,O=IPA.LOCAL 201711061603
        subject: CN=IPA.LOCAL CA 2017.11.09
[root@f27-2 ~]# getcert resubmit -i 20171106062742
Resubmitting &quot;20171106062742&quot; to &quot;dogtag-ipa-ca-renew-agent&quot;.
[root@f27-2 ~]# sleep 5
[root@f27-2 ~]# getcert list -i 20171106062742 | egrep &#39;status|issuer|subject&#39;
        status: MONITORING
        issuer: CN=IPA.LOCAL CA 2017.11.09
        subject: CN=IPA.LOCAL CA 2017.11.09</code></pre>
<p>Now we have a self-signed CA cert with the new Subject DN. This step has also confirmed that that the certificate issuance is working fine with the new CA subject.</p>
<h3 id="renewing-freeipa-service-certificates">Renewing FreeIPA service certificates</h3>
<p>This is another optional step, because we have kept the old CA certificate in the trust store. I want to check that certificate renewals via the FreeIPA framework are working, and this is a fine way to do that.</p>
<p>I’ll renew the HTTP service certificate. This deployment is using an externally-signed HTTP certificate so first I had to track it:</p>
<pre><code>[root@f27-2 ~]# getcert start-tracking \
  -d /etc/httpd/alias -p /etc/httpd/alias/pwdfile.txt \
  -n &#39;CN=alt-f27-2.ipa.local,O=Example Organization&#39; \
  -c IPA -D &#39;f27-2.ipa.local&#39; -K &#39;HTTP/f27-2.ipa.local@IPA.LOCAL&#39;
New tracking request &quot;20171121071700&quot; added.</code></pre>
<p>Then I resubmitted the tracking request. I had to include the <code>-N &lt;SUBJECT&gt;</code> option because the current Subject DN would be rejected by FreeIPA. I also had to include the <code>-K &lt;PRINC_NAME&gt;</code> option due to <a href="https://pagure.io/certmonger/issue/85">a bug in Certmonger</a>.</p>
<pre><code>[root@f27-2 ~]# getcert resubmit -i 20171121073608 \
  -N &#39;CN=f27-2.ipa.local&#39; \
  -K &#39;HTTP/f27-2.ipa.local@IPA.LOCAL&#39;
Resubmitting &quot;20171121073608&quot; to &quot;IPA&quot;.
[root@f27-2 ~]# sleep 5
[root@f27-2 ~]# getcert list -i 20171121073608 \
  | egrep &#39;status|error|issuer|subject&#39;
      status: MONITORING
      issuer: CN=IPA.LOCAL CA 2017.11.09
      subject: CN=f27-2.ipa.local,O=IPA.LOCAL 201711061603</code></pre>
<p>The renewal succeeded, proving that certificate issuance via the FreeIPA framework is working.</p>
<h2 id="checking-replica-health">Checking replica health</h2>
<p>At this point, I’m happy with the state of the FreeIPA server. But so far I have only dealt with one server in the topology (the renewal master, whose hostname is <code>f27-2.ipa.local</code>). What about other CA replicas?</p>
<p>I log onto <code>f27-1.ipa.local</code> (a CA replica). As a first step I execute <code>ipa-certupdate</code>. This failed in the same was as on the renewal master, and the steps to resolve were the same.</p>
<p>Next I tell Certmonger to renew the CA certificate. This should not renew the CA certificate, only retrieve the certificate from the LDAP certificate store:</p>
<pre><code>[root@f27-1 ~]# getcert list -i 20171106064548 \
  | egrep &#39;status|error|issuer|subject&#39;
        status: MONITORING
        issuer: CN=Certificate Authority,O=IPA.LOCAL 201711061603
        subject: CN=Certificate Authority,O=IPA.LOCAL 201711061603
[root@f27-1 ~]# getcert resubmit -i 20171106064548
Resubmitting &quot;20171106064548&quot; to &quot;dogtag-ipa-ca-renew-agent&quot;.
[root@f27-1 ~]# sleep 30
[root@f27-1 ~]# getcert list -i 20171106064548 | egrep &#39;status|error|issuer|subject&#39;
        status: MONITORING
        issuer: CN=Certificate Authority,O=IPA.LOCAL 201711061603
        subject: CN=Certificate Authority,O=IPA.LOCAL 201711061603</code></pre>
<p>Well, that did not work. Instead of retrieving the new CA certificate from LDAP, the CA replica issued a new certificate:</p>
<pre><code>[root@f27-1 ~]# certutil -d /etc/pki/pki-tomcat/alias -L \
    -n &#39;caSigningCert cert-pki-ca&#39;
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 268369927 (0xfff0007)
        Signature Algorithm: PKCS #1 SHA-256 With RSA Encryption
        Issuer: &quot;CN=Certificate Authority,O=IPA.LOCAL 201711061603&quot;
        Validity:
            Not Before: Tue Nov 21 08:18:09 2017
            Not After : Fri Nov 06 06:26:21 2037
        Subject: &quot;CN=Certificate Authority,O=IPA.LOCAL 201711061603&quot;
        ...</code></pre>
<p>This was caused by the first problem we faced when renewing the CA certificate with a new Subject DN. Once again, a mismatch between the Subject DN in the CSR and the FreeIPA CA’s Subject DN has confused the renewal helper.</p>
<p>The resolution in this case is to delete all the certificates with nickname <code>caSigningCert cert-pki-ca</code> or <code>IPA.LOCAl IPA CA</code> from Dogtag’s NSSDB then add the new CA certificate to the NSSDB. Then run <code>ipa-certupdate</code> again. Dogtag must not be running during this process:</p>
<pre><code>[root@f27-1 ~]# systemctl stop pki-tomcatd@pki-tomcat
[root@f27-1 ~]# cd /etc/pki/pki-tomcat/alias
[root@f27-1 ~]# certutil -d . -D -n &#39;caSigningCert cert-pki-ca&#39;
[root@f27-1 ~]# certutil -d . -D -n &#39;caSigningCert cert-pki-ca&#39;
[root@f27-1 ~]# certutil -d . -D -n &#39;caSigningCert cert-pki-ca&#39;
[root@f27-1 ~]# certutil -d . -D -n &#39;caSigningCert cert-pki-ca&#39;
certutil: could not find certificate named &quot;caSigningCert cert-pki-ca&quot;: SEC_ERROR_BAD_DATABASE: security library: bad database.
[root@f27-1 ~]# certutil -d . -D -n &#39;IPA.LOCAL IPA CA&#39;
[root@f27-1 ~]# certutil -d . -D -n &#39;IPA.LOCAL IPA CA&#39;
[root@f27-1 ~]# certutil -d . -D -n &#39;IPA.LOCAL IPA CA&#39;
certutil: could not find certificate named &quot;IPA.LOCAL IPA CA&quot;: SEC_ERROR_BAD_DATABASE: security library: bad database.
[root@f27-1 ~]# certutil -d . -A \
    -n &#39;caSigningCert cert-pki-ca&#39; -t &#39;CT,C,C&#39; &lt; /root/ipa-ca.pem
[root@f27-1 ~]# ipa-certupdate
trying https://f27-1.ipa.local/ipa/json
[try 1]: Forwarding &#39;ca_is_enabled&#39; to json server &#39;https://f27-1.ipa.local/ipa/json&#39;
[try 1]: Forwarding &#39;ca_find/1&#39; to json server &#39;https://f27-1.ipa.local/ipa/json&#39;
Systemwide CA database updated.
Systemwide CA database updated.
The ipa-certupdate command was successful
[root@f27-1 ~]# systemctl start pki-tomcatd@pki-tomcat</code></pre>
<p>Dogtag started without issue and I was able to issue a certificate via the <code>ipa cert-request</code> command on this replica.</p>
<h2 id="discussion">Discussion</h2>
<p>It took a while and required a lot of manual effort, but I reached the goal of changing the CA Subject DN. The deployment seems to be operational, although my testing was not exhaustive and there may be breakage that I did not find.</p>
<p>One of the goals was to define the process for both self-signed and externally-signed CAs. I did not deal with the externally-signed CA case. This article (and the process of writing it) was long enough without it! But much of the process, and problems encountered, will be the same.</p>
<p>There are some important concerns and caveats to be aware of.</p>
<p>First, CRLs generated after the Subject DN change may be bogus. They will be issued by the new CA but will contain serial numbers of revoked certificates that were issued by the old CA. Such assertions are invalid but not harmful in practice because those serial numbers will never be reused with the new CA. This is an implementation detail of Dogtag and not true in general.</p>
<p>But there is a bigger problem related to CRLs. After the CA name change, the old CA will never issue another CRL. This means that revoked certificates with the old Issuer DN will never again appear on a CRL issued by the old CA. Worse, the Dogtag OCSP responder errors when you query the status of a certificate with the old Issuer DN. In sum, this means that there is no way for Dogtag to revoke a certificate with the old Issuer DN. Because many systems <em>“fail open”</em> in the event of missing or invalid CRLs or OCSP errors, this is a potentially <strong>severe security issue</strong>.</p>
<p>Changing a FreeIPA installation’s CA Subject DN, whether by the procedure outlined in this post or by any other, is <strong>unsupported</strong>. If you try to do it and break your installation, we (the FreeIPA team) may try to help you recover, to a point. But we can’t guarantee anything. <em>Here be dragons</em> and all that.</p>
<p>If you think you need to change your CA Subject DN and have not read the <a href="2017-11-20-changing-ca-subject-dn-part-i.html">previous post</a> on this topic, please go and read it. It proposes some alternatives that, if applicable, avoid the messy process and security issues detailed here. Despite showing you how to change a FreeIPA installation’s CA Subject DN, my advice remains: <strong>don’t do it</strong>. I hope you will heed it.</p>]]></summary>
</entry>
<entry>
    <title>Changing a CA’s Subject DN; Part I: Don’t Do That</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2017-11-20-changing-ca-subject-dn-part-i.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2017-11-20-changing-ca-subject-dn-part-i.html</id>
    <published>2017-11-20T00:00:00Z</published>
    <updated>2017-11-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="changing-a-cas-subject-dn-part-i-dont-do-that">Changing a CA’s Subject DN; Part I: Don’t Do That</h1>
<p>When you deploy an X.509 certificate authority (CA), you choose a <em>Subject Distinguished Name</em> for that CA. It is sometimes abbreviated as <em>Subject DN</em>, <em>Subject Name</em>, <em>SDN</em> or just <em>Subject</em>.</p>
<p>The Subject DN cannot be changed; it is “for life”. But sometimes someone wants to change it anyway. In this article I’ll speculate why someone might want to change a CA’s Subject DN, discuss why it is problematic to do so, and propose some alternative approaches.</p>
<h2 id="what-is-the-subject-dn">What is the Subject DN?</h2>
<p>A distinguished name (DN) is a sequence of sets of name attribute types and values. Common attribute types include <em>Common Name (CN)</em>, <em>Organisation (O)</em>, <em>Organisational Unit (OU)</em>, <em>Country (C)</em> and so on. DNs are encoded in ASN.1, but have a well defined string representation. Here’s an example CA subject DN:</p>
<pre><code>CN=DigiCert Global Root CA,OU=www.digicert.com,O=DigiCert Inc,C=US</code></pre>
<p>All X.509 certificates contain an <em>Issuer DN</em> field and a <em>Subject DN</em> field. If the same value is used for both issuer and subject, it is a <em>self-signed certificate</em>. When a CA issues a certificate, the <em>Issuer DN</em> on the issued certificate shall be the <em>Subject DN</em> of the CA certificate. This relationship is a “link” in the chain of signatures from some <em>root CA</em> to <em>end entity</em> (or <em>leaf</em>) certificate.</p>
<p>The Subject DN uniquely identifies a CA. <strong>It is the CA</strong>. A CA can have multiple concurrent certificates, possibly with different public keys and key types. But if the Subject DN is the same, they are just different certificates for a single CA. Corollary: if the Subject DN differs, it is a different CA <em>even if the key is the same</em>.</p>
<h2 id="ca-subject-dn-in-freeipa">CA Subject DN in FreeIPA</h2>
<p>A standard installation of FreeIPA includes a CA. It can be a root CA or it can be signed by some other CA (e.g. the Active Directory CA of the organisation). As of FreeIPA v4.5 you can specify any CA Subject DN. Earlier versions required the subject to start with <code>CN=Certificate Authority</code>.</p>
<p>If you don’t explicitly specify the subject during installation, it defaults to <code>CN=Certificate Authority, O=EXAMPLE.COM</code> (replace <code>EXAMPLE.COM</code> with the actual realm name).</p>
<h2 id="why-change-the-ca-subject-dn">Why change the CA Subject DN?</h2>
<p>Why would someone want to change a CA’s Subject DN? Usually it is because there is some organisational or regulatory requirement for the Subject DN to have a particular form. For whatever reason the Subject DN doesn’t comply, and now they want to bring it into compliance. In the FreeIPA case, we often see that the default CA Subject DN was accepted, only to later realise that a different name is needed.</p>
<p>To be fair, the FreeIPA installer does not prompt for a CA Subject DN but rather uses the default form unless explicitly told otherwise via options. Furthermore, the CA Subject DN is not mentioned in the summary of the installation parameters prior to confirming and proceeding with the installation. And there are the aforementioned restrictions in FreeIPA &lt; v4.5. So in most cases where a FreeIPA administrator wants to change the CA Subject DN, it is not because <em>they chose</em> the wrong one, rather they were <em>not given an opportunity</em> to choose the right one.</p>
<h2 id="implications-of-changing-the-ca-subject-dn">Implications of changing the CA Subject DN</h2>
<p>In the X.509 data model the Subject DN is the essence of a CA. So what happens if we do change it? There are several areas of concern, and we will look at each in turn.</p>
<h3 id="certification-paths">Certification paths</h3>
<p>Normally when you renew a CA certificate, you don’t need to keep the old CA certificates around in your trust stores. If the new CA certificate is within its validity period you can just replace the old certificate, and everything will keep working.</p>
<p>But if you change the Subject DN, you need to keep the old certificate around, because previously issued certificates will bear the <em>old</em> Issuer DN. Conceptually this is not a problem, but many programs and libraries cannot cope with multiple subjects using the same key. In this case the only workaround is to reissue every certificate, with the new Issuer DN. This is a nightmare.</p>
<h3 id="crls">CRLs</h3>
<p>A <em>certificate revocation list</em> is a signed list of non-expired certificates that have been revoked. A CRL issuer is either the CA itself, or a trusted delegate. A CRL signing delegate has its own signing key and an X.509 certificate issued by the CA, which asserts that the subject is a CRL issuer. Like certificates, CRLs have an Issuer DN field.</p>
<p>So if the CA’s Subject DN changes, then CRLs issued by that CA must use the new name in the Issuer field. But recall that certificates are uniquely identified by the Issuer DN and Serial (think of this as a composite primary key). So if the CRL issuer changes (or the issuer of the CRL issuer), all the old revocation information is invalid. Now you must maintain two CRLs:</p>
<ul>
<li>One for the old CA Subject. Even after the name change, this CRL may grow as certificates that were issued using the old CA subject are revoked.</li>
<li>One for the new CA Subject. It will start off empty.</li>
</ul>
<p>If a CRL signing delegate is used, there is further complexity. You need two separate CRL signing certificates (one with the old Issuer DN, one with the new), and must</p>
<p>Suffice to say, a lot of CA programs do not handle these scenarios nicely or at all.</p>
<h3 id="ocsp">OCSP</h3>
<p>The <em>Online Certificate Status Protocol</em> is a protocol for checking the revocation status of a single certificate. Like CRLs, OCSP responses may be signed by the issuing CA itself, or a delegate.</p>
<p>As in the CRL delegation case, different OCSP delegates must be used depending on which DN was the Issuer of the certificate whose status is being checked. If performing direct OCSP signing, if identifying the Responder ID by name, then the old or new name would be included depending on the Issuer of the certificate.</p>
<h3 id="performing-the-change">Performing the change</h3>
<p>Most CA programs do not offer a way to change the Subject DN. This is not surprising, given that the operation just doesn’t fit into X.509 at all, to say nothing of the implementation considerations that arise.</p>
<p>It may be possible to change the CA Subject DN with some manual effort. In a follow-up post I’ll demonstrate how to change the CA Subject DN in a FreeIPA deployment.</p>
<h2 id="alternative-approaches">Alternative approaches</h2>
<p>I have outlined reasons why renaming a CA is a Bad Idea. So what other options are there?</p>
<p>Whether any of the follow options are viable depends on the use case or requirements. They might not be viable. If you have any other ideas about this I would love to have your feedback! So, let’s look at a couple of options.</p>
<h3 id="do-nothing">Do nothing</h3>
<p>If you only want to change the CA Subject DN for cosmetic reasons, don’t. Unless there is a clear business or organisational imperative, just accept the way things are. Your efforts would be better spent somewhere else, I promise!</p>
<h3 id="re-chaining-your-ca">Re-chaining your CA</h3>
<p>If there is a requirement for your <strong>root</strong> CA to have a Subject DN of a particular form, you could create a CA that satisfies the requirement somewhere else (e.g. a separate instance of Dogtag or even a standalone OpenSSL CA). Then you can <em>re-chain</em> your FreeIPA CA up to this new external CA. That is, you renew the CA certificate, but the issuer of the new IPA CA certificate is the new external CA.</p>
<p>The new external CA becomes a trusted root CA, and your FreeIPA infrastructure and clients continue to function as normal. The FreeIPA CA is now an <em>intermediate</em> CA. No certificates need to be reissued, although some server configurations may need to be updated to include the new FreeIPA CA in their certificate chains.</p>
<h3 id="subordinate-ca">Subordinate CA</h3>
<p>If certain end-entity certificates have to be issued by a CA whose Subject DN meets certain requirements, you could create a <em>subordinate CA</em> (or <em>sub-CA</em> for short) with a compliant name. That is, the FreeIPA CA issues an intermediate CA certificate with the desired Subject DN, and that CA issues the leaf certificates.</p>
<p>FreeIPA support Dogtag <em>lightweight sub-CAs</em> as of v4.4 and there are no restrictions on the Subject DN (except uniqueness). Dogtag lightweight CAs live within the same Dogtag instance as the main FreeIPA CA. See <code>ipa help ca</code> for plugin documentation. One major caveat is that CRLs are not yet supported for lightweight CAs (there is an <a href="https://pagure.io/dogtagpki/issue/1627">open ticket</a>).</p>
<p>You could also use the FreeIPA CA to issue a CA certificate for some other CA program (possible another deployment of Dogtag or FreeIPA).</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post I explained what a CA’s Subject DN is, and how it is an integral part of how X.509 works. We discussed some of the conceptual and practical issues that arise when you change a CA’s Subject DN. In particular, path validation, CRLs and OCSP are affected, and a lot of software will break when encountering a “same key, different subject” scenario.</p>
<p>The general recommendation for changing a CA’s subject DN is <strong>don’t</strong>. But if there is a real business reason why the current subject is unsuitable, we looked at a couple of alternative approaches that could help: re-chaining the CA, and creating sub-CAs.</p>
<p>In my next post we will have an in-depth look how to change a FreeIPA CA’s Subject DN: how to do it, and how to deal with the inevitable breakage.</p>]]></summary>
</entry>
<entry>
    <title>Changing the X.509 signature algorithm in FreeIPA</title>
    <link href="https://frasertweedale.github.io/blog-redhat/posts/2017-11-10-freeipa-changing-signature-algorithm.html" />
    <id>https://frasertweedale.github.io/blog-redhat/posts/2017-11-10-freeipa-changing-signature-algorithm.html</id>
    <published>2017-11-10T00:00:00Z</published>
    <updated>2017-11-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="changing-the-x.509-signature-algorithm-in-freeipa">Changing the X.509 signature algorithm in FreeIPA</h1>
<p>X.509 certificates are an application of <em>digital signatures</em> for identity verification. TLS uses X.509 to create a <em>chain of trust</em> from a trusted CA to a service certificate. An X.509 certificate binds a public key to a <em>subject</em> by way of a secure and verifiable <em>signature</em> made by a <em>certificate authority (CA)</em>.</p>
<p>A signature algorithm has two parts: a public key signing algorithm (determined by the type of the CA’s signing key) and a <em>collision-resistant</em> hash function. The hash function <em>digests</em> the certified data into a small value that is hard to find collision for, which gets signed.</p>
<p>Computers keep getting faster and attacks on cryptography always get better. So over time older algorithms need to be deprecated, and newer algorithms adopted for use with X.509. In the past the MD5 and SHA-1 digests were often used with X.509, but today SHA-256 (a variant of SHA-2) is the most used algorithm. SHA-256 is also the weakest digest accepted by many programs (e.g. web browsers). Stronger variants of SHA-2 are widely supported.</p>
<p>FreeIPA currently uses the <code>sha256WithRSAEncryption</code> signature algorithm by default. Sometimes we get asked about how to use a stronger digest algorithm. In this article I’ll explain how to do that and discuss the motivations and implications.</p>
<h2 id="implications-of-changing-the-digest-algorithm">Implications of changing the digest algorithm</h2>
<p>Unlike re-keying or changing the CA’s Subject DN, re-issuing a certificate signed by the same key, but using a different digest, should Just Work. As long as a client knows about the digest algorithm used, it will be able to verify the signature. It’s fine to have a chain of trust that uses a variety of signature algorithms.</p>
<h2 id="configuring-the-signature-algorithm-in-freeipa">Configuring the signature algorithm in FreeIPA</h2>
<p>The signature algorithm is configured in each Dogtag certificate profile. Different profiles can use different signature algorithms. The public key signing algorithm depends on the CA’s key type (e.g. RSA) so you can’t change it; you can only change the digest used.</p>
<h3 id="modifying-certificate-profiles">Modifying certificate profiles</h3>
<p>Before FreeIPA 4.2 (RHEL 7.2), Dogtag stored certificate profile configurations as flat files. Dogtag 9 stores them in <code>/var/lib/pki-ca/profiles/ca</code> and Dogtag &gt;= 10 stores them in <code>/var/lib/pki/pki-tomcat/ca/profiles/ca</code>. When Dogtag is using file-based profile storage you must modify profiles on all CA replicas for consistent behaviour. After modifying a profile, Dogtag requires a restart to pick up the changes.</p>
<p>As of FreeIPA 4.2, Dogtag uses LDAP-based profile storage. Changes to profiles get replicated among the CA replicas, so you only need to make the change once. Restart is not required. The <code>ipa certprofile</code> plugin provides commands for importing, exporting and modifying certificate profiles.</p>
<p>Because of the variation among versions, I won’t detail the process of modifying profiles. We’ll look at what modifications to make, but skip over how to apply them.</p>
<h3 id="profile-configuration-changes">Profile configuration changes</h3>
<p>For service certificates, the profile to modify is <code>caIPAserviceCert</code>. If you want to renew the CA signing cert with a different algorithm, modify the <code>caCACert</code> profile. The relevant profile policy components are <code>signingAlgConstraintImpl</code> and <code>signingAlgDefaultImpl</code>. Look for these components in the profile configuration:</p>
<pre><code>policyset.serverCertSet.8.constraint.class_id=signingAlgConstraintImpl
policyset.serverCertSet.8.constraint.name=No Constraint
policyset.serverCertSet.8.constraint.params.signingAlgsAllowed=SHA1withRSA,SHA256withRSA,SHA512withRSA,MD5withRSA,MD2withRSA,SHA1withDSA,SHA1withEC,SHA256withEC,SHA384withEC,SHA512withEC
policyset.serverCertSet.8.default.class_id=signingAlgDefaultImpl
policyset.serverCertSet.8.default.name=Signing Alg
policyset.serverCertSet.8.default.params.signingAlg=-</code></pre>
<p>Update the <code>policyset.&lt;name&gt;.&lt;n&gt;.default.params.signingAlg</code> parameter; replace the <code>-</code> with the desired signing algorithm. (I set it to <code>SHA512withRSA</code>.) Ensure that the algorithm appears in the <code>policyset.&lt;name&gt;.&lt;n&gt;.constraint.params.signingAlgsAllowed</code> parameter (if not, add it).</p>
<p>After applying this change, certificates issued using the modified profile will use the specified algorithm.</p>
<h2 id="results">Results</h2>
<p>After modifying the <code>caIPAserviceCert</code> profile, we can renew the HTTP certificate and see that the new certificate uses <code>SHA512withRSA</code>. Use <code>getcert list</code> to find the Certmonger tracking request ID for this certificate. We find the tracking request in the output:</p>
<pre><code>...
Request ID &#39;20171109075803&#39;:
  status: MONITORING
  stuck: no
  key pair storage: type=NSSDB,location=&#39;/etc/httpd/alias&#39;,nickname=&#39;Server-Cert&#39;,token=&#39;NSS Certificate DB&#39;,pinfile=&#39;/etc/httpd/alias/pwdfile.txt&#39;
  certificate: type=NSSDB,location=&#39;/etc/httpd/alias&#39;,nickname=&#39;Server-Cert&#39;,token=&#39;NSS Certificate DB&#39;
  CA: IPA
  issuer: CN=Certificate Authority,O=IPA.LOCAL
  subject: CN=rhel69-0.ipa.local,O=IPA.LOCAL
  expires: 2019-11-10 07:53:11 UTC
  ...
...</code></pre>
<p>So the tracking request ID is <code>20171109075803</code>. Now resubmit the request:</p>
<pre><code>[root@rhel69-0 ca]# getcert resubmit -i 20171109075803
Resubmitting &quot;20171109075803&quot; to &quot;IPA&quot;.</code></pre>
<p>After a few moments, check the status of the request:</p>
<pre><code>[root@rhel69-0 ca]# getcert list -i 20171109075803
Number of certificates and requests being tracked: 8.
Request ID &#39;20171109075803&#39;:
  status: MONITORING
  stuck: no
  key pair storage: type=NSSDB,location=&#39;/etc/httpd/alias&#39;,nickname=&#39;Server-Cert&#39;,token=&#39;NSS Certificate DB&#39;,pinfile=&#39;/etc/httpd/alias/pwdfile.txt&#39;
  certificate: type=NSSDB,location=&#39;/etc/httpd/alias&#39;,nickname=&#39;Server-Cert&#39;,token=&#39;NSS Certificate DB&#39;
  CA: IPA
  issuer: CN=Certificate Authority,O=IPA.LOCAL
  subject: CN=rhel69-0.ipa.local,O=IPA.LOCAL
  expires: 2019-11-11 00:02:56 UTC
  ...</code></pre>
<p>We can see by the <code>expires</code> field that renewal succeeded. Pretty-printing the certificate shows that it is using the new signature algorithm:</p>
<pre><code>[root@rhel69-0 ca]# certutil -d /etc/httpd/alias -L -n &#39;Server-Cert&#39;
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 12 (0xc)
        Signature Algorithm: PKCS #1 SHA-512 With RSA Encryption
        Issuer: &quot;CN=Certificate Authority,O=IPA.LOCAL&quot;
        Validity:
            Not Before: Fri Nov 10 00:02:56 2017
            Not After : Mon Nov 11 00:02:56 2019
        Subject: &quot;CN=rhel69-0.ipa.local,O=IPA.LOCAL&quot;</code></pre>
<p>It is using SHA-512/RSA. Mission accomplished.</p>
<h2 id="discussion">Discussion</h2>
<p>In this article I showed how to configure the signing algorithm in a Dogtag certificate profile. Details about how to modify profiles in particular versions of FreeIPA was out of scope.</p>
<p>In the example I modified the default service certificate profile <code>caIPAserviceCert</code> to use <code>SHA512withRSA</code>. Then I renewed the HTTP TLS certificate to confirm that the configuration change had the intended effect. To change the signature algorithm on the FreeIPA CA certificate, you would modify the <code>caCACert</code> profile then renew the CA certificate. This would only work if the FreeIPA CA is <em>self-signed</em>. If it is externally-signed, it is up to the external CA what digest to use.</p>
<p>In FreeIPA version 4.2 and later, we support the addition of custom certificate profiles. If you want to use a different signature algorithm for a specific use case, instead of modifying the default profile (<code>caIPAserviceCert</code>) you might add a new profile.</p>
<p>The default signature digest algorithm in Dogtag is currently SHA-256. This is appropriate for the present time. There are few reasons why you would need to use something else. Usually it is because of an arbitrary security decision imposed on FreeIPA administrators. There are currently no plans to make the default signature algorithm configurable. But you can control the signature algorithm for a self-signed FreeIPA CA certificate via the <code>ipa-server-install</code> <code>--ca-signing-algorithm</code> option.</p>
<p>In the introduction I mentioned that the CA’s key type determines the public key signature algorithm. That was hand-waving; some key types support multiple signature algorithms. For example, RSA keys support two signature algorithms: <em>PKCS #1 v1.5</em> and <em>RSASSA-PSS</em>. The latter is seldom used in practice.</p>
<p>The SHA-2 family of algorithms (SHA-256, SHA-384 and SHA-512) are the “most modern” digest algorithms standardised for use in X.509 (<a href="https://tools.ietf.org/html/rfc4055#section-2.1">RFC 4055</a>). The Russian <em>GOST R</em> digest and signature algorithms are also supported (<a href="https://tools.ietf.org/html/rfc4491">RFC 4491</a>) although support is not widespread. In 2015 NIST published SHA-3 (based on the <em>Keccak</em> sponge construction). The use of SHA-3 in X.509 has not yet been standardised. There was an <a href="https://tools.ietf.org/html/draft-turner-lamps-adding-sha3-to-pkix-01">Internet-Draft in 2017</a>, but it expired. The current cryptanalysis of SHA-2 suggests there is no urgency to move to SHA-3. But it took a long time to move from SHA-1 (which is now insecure for applications requiring collision resistance) to SHA-2. Therefore it would be good to begin efforts to standardise SHA-3 in X.509 and add library/client support as soon as possible.</p>]]></summary>
</entry>

</feed>
